#@ # 
#@ # Running dc_shell Version C-2009.06-SP4 for linux -- Nov 30, 2009
#@ # Date:   Thu Dec  9 16:54:35 2010
#@ # Run by: hfsken@leopard
#@ 

source /usr/cad/synopsys/synthesis/cur/admin/setup/.synopsys_dc.setup
#@ #
#@ #		".synopsys_dc.setup" Initialization File for
#@ #
#@ #		    Dc_Shell and Design_Analyzer
#@ #
#@ #	The variables in this file define the behavior of many parts
#@ #	of the Synopsys Synthesis Tools.  Upon installation, they should 
#@ #	be reviewed and modified to fit your site's needs.  Each engineer
#@ #	can have a .synopsys file in his/her home directory or current
#@ #	directory to override variable settings in this file.  
#@ #
#@ #  	Each logical grouping of variables is commented as to their 
#@ #	nature and effect on the Synthesis Commands.  Examples of
#@ #	variable groups are the Compile Variable Group, which affects 
#@ #	the designs produced by the COMPILE command, and the Schematic 
#@ #	Variable Group, which affects the output of the create_schematic
#@ #	command.
#@ #
#@ #	You can type "man <group_name>_variables" in dc_shell or 
#@ #	design_analyzer to get help about a group of variables.
#@ #	For instance, to get help about the "system" variable group, 
#@ #	type "help system_variables".  You can also type
#@ #	"man <variable name>", to get help on the that variable's 
#@ #	group.
#@ #
#@ 
#@ # System variables
#@ set sh_command_abbrev_mode       "Anywhere"
#@ set sh_continue_on_error         "true"
#@ update_app_var -default true sh_continue_on_error
#@ set sh_enable_page_mode          "true"
#@ update_app_var -default true sh_enable_page_mode
#@ set sh_source_uses_search_path   "true"
#@ update_app_var -default true sh_source_uses_search_path
#@ set sh_new_variable_message	 "true"
#@ update_app_var -default true sh_new_variable_message
#@ if { [string compare $dc_shell_mode "tcl"] == 0 } {
#@  set sh_enable_line_editing       "true"
#@  set sh_line_editing_mode         "emacs"
#@ }
#@ 
#@ if {$synopsys_program_name == "icc_shell"} {
#@  set sh_output_log_file "icc_output.txt"
#@ 
#@ ## the variable sh_redirect_progress_messages only makes it possible 
#@ ## for some commands to redirect progress messages to the log file,thereby
#@ ## bypassing the console and reducing the volume of messages on the console.
#@  set sh_redirect_progress_messages true
#@  }
#@ 
#@ 
#@ # Suppress new variable messages for the following variables
#@ array set auto_index {}
#@ set auto_oldpath ""
#@ 
#@ # Enable debug output on fatal 
#@ if { $sh_arch == "sparc"   || $sh_arch == "sparcOS5" ||      $sh_arch == "sparc64" || $sh_arch == "hpux10"   ||      $sh_arch == "hp700"   || $sh_arch == "hp32"     ||      $sh_arch == "hp64"    || $sh_arch == "linux" } {
#@    setenv SYNOPSYS_TRACE ""
#@ }
#@ 
#@ #
#@ # Load the procedures which make up part of the user interface.
#@ #
#@ if { [string compare $dc_shell_mode "tcl"] == 0 } {
#@   source $synopsys_root/auxx/syn/.dc_common_procs.tcl
#@   source $synopsys_root/auxx/syn/.dc_procs.tcl
#@   alias list_commands help
#@ }
#@ ##############################################################################
#@ #
#@ #
#@ # FILE:         auxx/syn/.dc_common_procs.tcl
#@ #
#@ # ABSTRACT:     These procedures are part of the PrimeTime and DC
#@ #               user interface.
#@ #               They are loaded by .synopsys_pt.setup and .synopsys_dc.setup.
#@ #
#@ ##############################################################################
#@ #
#@ #
#@ 
#@ 
#@ ##############################################################################
#@ #
#@ #
#@ #  PROCEDURE:   group_variable
#@ #
#@ #  ABSTRACT:    Add a variable to the specified variable group.
#@ #               This command is typically used by the system
#@ #               administrator only.
#@ #
#@ #               Below the proc is the command which creates the command
#@ #               help information and semantic data for the argument.
#@ #
#@ #  RETURNS:     1 if it is successful.
#@ #               error code if the variable does not exist.
#@ #               error code of the variable is already in the group.
#@ #
#@ #  SYNTAX:      group_variable group_name variable_name
#@ #
#@ ##############################################################################
#@ #
#@ 
#@ 
#@ proc group_variable { args } {
#@   global _Variable_Groups
#@ 
#@   parse_proc_arguments -args $args resarr
#@   set group $resarr(group)
#@   set var $resarr(variable_name)
#@ 
#@   if { ![info exists _Variable_Groups($group)] } {
#@    set _Variable_Groups($group) ""
#@   }
#@ 
#@   # Verify that var exists as a global variable
#@ 
#@   set cmd "uplevel #0 \{info exists $var\}"
#@   if { ![eval $cmd] } {
#@     return -code error "Variable '$var' is not defined."
#@   }
#@ 
#@   # Only add it if it's not already there
#@ 
#@   if { [lsearch $_Variable_Groups($group) $var] == -1 } {
#@     lappend _Variable_Groups($group) $var
#@   }
#@ 
#@   return 1
#@ }
#@ 
#@ define_proc_attributes group_variable     -info "Add a variable to a variable group"      -command_group "Builtins" -permanent -dont_abbrev     -define_args { 
#@       {group "Variable group name" group}
#@       {variable_name "Variable name" variable_name}}
#@ 
#@ ##############################################################################
#@ #
#@ #
#@ #  PROCEDURE:   print_variable_group
#@ #
#@ #  ABSTRACT:    Shows variables and their values defined in the given group.
#@ 
#@ #
#@ #               Below the proc is the command which creates the command
#@ #               help information and semantic data for the argument.
#@ #
#@ #  RETURNS:     1 if it is successful.
#@ #               error code of the variable group does not exist.
#@ #
#@ #  SYNTAX:      print_variable_group group_name
#@ #
#@ ##############################################################################
#@ #
#@ 
#@ proc print_variable_group { args } {
#@   global _Variable_Groups
#@ 
#@   parse_proc_arguments -args $args resarr
#@   set group $resarr(group)
#@ 
#@   if { [string compare $group "all"] == 0 } {
#@     set cmd "uplevel #0 \{printvar\}"
#@     return [eval $cmd]
#@   }
#@ 
#@   if { ![info exists _Variable_Groups($group)] } {
#@     return -code error "Variable group '$group' does not exist."
#@   }
#@ 
#@   # Print out each global variable in the list. To be totally bulletproof, 
#@   # test that each variable in the group is still defined.  If not, remove 
#@   # it from the list.
#@  
#@   foreach var [lsort $_Variable_Groups($group)] {
#@     set cmd "uplevel #0 \{info exists $var\}"
#@     if { ![eval $cmd] } {
#@       # Remove it
#@       set n [lsearch $_Variable_Groups($group) $var]
#@       set $_Variable_Groups($group) [lreplace $_Variable_Groups($group) $n $n]
#@     } else {
#@       # Print it.
#@       set cmd "uplevel #0 \{set $var\}"
#@       set val [eval $cmd]
#@       echo [format "%-25s = \"%s\"" $var $val]
#@     }
#@   }
#@ 
#@   return 1
#@ }
#@ 
#@ define_proc_attributes print_variable_group     -info "Print the contents of a variable group"      -command_group "Builtins" -permanent      -define_args {{group "Variable group name" group}}
#@ 
#@ 
#@ 
#@ ##############################################################################
#@ #
#@ #
#@ #  PROCEDURE:   _Variable_Groups_Get_Groups
#@ #
#@ #  ABSTRACT:    Return a list of all variable groups. This command is hidden
#@ #               and is used by Design Vision.
#@ #
#@ #   RETURNS:    Tcl list of all variable groups including group all
#@ #
#@ #  SYNTAX:      _Variable_Groups_Get_Groups
#@ ##############################################################################
#@ #
#@ 
#@ proc _Variable_Groups_Get_Groups { } {
#@    global _Variable_Groups
#@ 
#@    set groups  [array names _Variable_Groups]
#@    append groups " all"
#@    return $groups
#@ }
#@ define_proc_attributes _Variable_Groups_Get_Groups -hidden
#@ 
#@ 
#@ ##############################################################################
#@ #
#@ #
#@ #  PROCEDURE:   _Variable_Groups_Get_Variables_Of_Group
#@ #
#@ #  ABSTRACT:    Return a list of all variables of a variable group.
#@ #               It also works for pseudo group all.
#@ #
#@ #   RETURNS:    Tcl list of all variables of a variable group including
#@ #               pseudo group all
#@ #
#@ #  SYNTAX:      _Variable_Groups_Get_Groups
#@ ##############################################################################
#@ #
#@ 
#@ proc _Variable_Groups_Get_Variables_Of_Group { group } {
#@   global _Variable_Groups
#@ 
#@   if { [string compare $group "all"] == 0 } {
#@     set itr [array startsearch _Variable_Groups]
#@     for {  } { [array anymore _Variable_Groups $itr]} { } {
#@       set index [array nextelement _Variable_Groups $itr]
#@       append vars $_Variable_Groups($index)
#@     }
#@     array donesearch _Variable_Groups $itr
#@     return $vars
#@   }
#@ 
#@   if { ![info exists _Variable_Groups($group)] } {
#@     return -code error "Variable group '$group' does not exist."
#@   }
#@ 
#@   # Test if all variables in the list of variables are still defined.
#@   # Remove not existing variables.
#@   foreach var [lsort $_Variable_Groups($group)] {
#@     set cmd "uplevel #0 \{info exists $var\}"
#@     if { ![eval $cmd] } {
#@       # Remove it
#@       set n [lsearch $_Variable_Groups($group) $var]
#@       set $_Variable_Groups($group) [lreplace $_Variable_Groups($group) $n $n]
#@     }
#@   }
#@   return $_Variable_Groups($group)
#@ }
#@ define_proc_attributes _Variable_Groups_Get_Variables_Of_Group -hidden
#@ 
#@ # -- End source /usr/cad/synopsys/synthesis/cur/auxx/syn/.dc_common_procs.tcl

#@ ##############################################################################
#@ #
#@ #
#@ # FILE:         auxx/syn/.dc_procs.tcl
#@ #
#@ # ABSTRACT:     These procedures are part of the Design Compiler Tcl 
#@ #               user interface.
#@ #               They are loaded by .synopsys_dc.setup.
#@ #
#@ ##############################################################################
#@ #
#@ #
#@ 
#@ ##############################################################################
#@ #
#@ #
#@ #  PROCEDURE:  read_verilog
#@ #
#@ #  ABSTRACT:   Emulate PT's read_verilog command in DC:
#@ #
#@ #  Usage:      read_verilog         #  Read one or more verilog files 
#@ #                *[-hdl_compiler]       (Use HDL Compiler (ignored))
#@ #                file_names             (Files to read)
#@ #
#@ #  Modified: Bharat 11/17/99. Use uplevel to ensure that the command
#@ #            sees user/hidden variables from the top level. Star 92970.
#@ #
#@ #  Modified: Evan Rosser, 12/5/01. Support -netlist and -rtl flags.
#@ #
#@ ##############################################################################
#@ #
#@ 
#@ if { $synopsys_program_name != "icc_shell" } {
#@ proc read_verilog { args } {
#@   parse_proc_arguments -args $args ra
#@ 
#@   set cmd [format {read_file -format verilog %s %s [list %s]}                      [array names ra -rtl]                      [array names ra -netlist]                      $ra(file_names)]
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ define_proc_attributes read_verilog     -info " Read one or more verilog files"     -permanent     -define_args {
#@       {file_names "Files to read" file_names list required}
#@    {-netlist "Use structural Verilog netlist reader" "" boolean optional}
#@    {-rtl "Use RTL Verilog compiler (Presto or HDLC)" "" boolean optional}
#@    {-hdl_compiler "Use HDL Compiler (ignored)" "" boolean {hidden optional}}
#@ }
#@ }
#@ 
#@ ##############################################################################
#@ #
#@ #
#@ #  PROCEDURE:  read_sverilog
#@ #
#@ #  ABSTRACT:   Emulate PT's read_sverilog command in DC:
#@ #
#@ #  Usage:      read_sverilog         #  Read one or more systemverilog files 
#@ #                *[-hdl_compiler]       (Use HDL Compiler (ignored))
#@ #                file_names             (Files to read)
#@ #
#@ #  Modified: Yong Xiao, 01/31/2003: Copied from read_verilog to support 
#@ #            systemverilog input. 
#@ #
#@ ##############################################################################
#@ #
#@ 
#@ proc read_sverilog { args } {
#@   parse_proc_arguments -args $args ra
#@ 
#@   set cmd [format {read_file -format sverilog %s %s [list %s]}                      [array names ra -rtl]                      [array names ra -netlist]                      $ra(file_names)]
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ define_proc_attributes read_sverilog     -info " Read one or more systemverilog files"     -permanent     -define_args {
#@       {file_names "Files to read" file_names list required}
#@    {-netlist "Use structural Verilog netlist reader" "" boolean optional}
#@    {-rtl "Use RTL Systemverilog compiler (Presto or HDLC)" "" boolean optional}
#@    {-hdl_compiler "Use HDL Compiler (ignored)" "" boolean {hidden optional}}
#@ }
#@ 
#@ 
#@ ##############################################################################
#@ #
#@ #
#@ #  PROCEDURE: read_vhdl
#@ #
#@ #  ABSTRACT:  Emulate PT's read_vhdl command in DC:
#@ #
#@ #  Usage:     read_vhdl            #  Read one or more vhdl files
#@ #               file_names             (Files to read)
#@ #
#@ #
#@ ##############################################################################
#@ #
#@ 
#@ proc read_vhdl { args } {
#@   parse_proc_arguments -args $args ra
#@ 
#@   set cmd [format {read_file -format vhdl %s [list %s]} 	       [array names ra -netlist] 	       $ra(file_names)]
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ define_proc_attributes read_vhdl     -info " Read one or more vhdl files"     -permanent     -define_args {
#@ 	{file_names "Files to read" file_names list required}
#@ 	{-netlist "Use structural VHDL netlist reader" "" boolean optional}
#@ }
#@ 
#@ ##############################################################################
#@ #
#@ #
#@ #  PROCEDURE:   read_db
#@ #
#@ #  ABSTRACT:    Emulate PT's read_db command in DC:
#@ #
#@ #  Usage: 
#@ #     read_db              #  Read one or more db files
#@ #       *[-netlist_only]       (Do not read any attributes from db (ignored))
#@ #       *[-library]            (File is a library DB (ignored))
#@ #      file_names             (Files to read)
#@ #
#@ #
#@ ##############################################################################
#@ #
#@ 
#@ proc read_db { args } {
#@   parse_proc_arguments -args $args ra
#@ 
#@   set cmd [format {read_file -format db  [list %s]} $ra(file_names)]
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ define_proc_attributes read_db     -info " Read one or more db files"     -permanent     -define_args {
#@       {file_names "Files to read" file_names list required}
#@       {-netlist_only "Do not read any attributes from db (ignored)" "" boolean {hidden optional}}
#@       {-library "File is a library DB (ignored)" "" boolean {hidden optional}}
#@      }
#@ 
#@ ##############################################################################
#@ #
#@ #
#@ #  PROCEDURE:   read_edif
#@ #
#@ #  ABSTRACT:    Emulate PT's read_edif command in DC: 
#@ #
#@ #  Usage:     
#@ #      read_edif            #  Read one or more edif files
#@ #        *[-complete_language]  (Use ptxr to read the file (ignored))
#@ #        file_names             (Files to read)
#@ #
#@ #
#@ ##############################################################################
#@ #
#@ proc read_edif { args } {
#@   parse_proc_arguments -args $args ra
#@ 
#@   set cmd [format {read_file -format edif  [list %s]} $ra(file_names)]
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ define_proc_attributes read_edif     -info " Read one or more edif files"     -permanent     -define_args {
#@       {file_names "Files to read" file_names list required}
#@       {-complete_language "Use ptxr to read the file (ignored)" "" boolean {hidden optional}}
#@ }
#@ 
#@ 
#@ ##############################################################################
#@ #
#@ #
#@ #  PROCEDURE:   read_ddc
#@ #
#@ #  ABSTRACT:    Shorthand for "read_file -format ddc":
#@ #
#@ #  Usage: 
#@ #     read_ddc             #  Read one or more ddc files
#@ #      *[-scenarios]		only read constraints for specified scenarios
#@ #      *[-active_scenarios]     only activate the specified scenarios
#@ #      file_names             (Files to read)
#@ #
#@ #
#@ ##############################################################################
#@ #
#@ 
#@ proc read_ddc { args } {
#@   parse_proc_arguments -args $args ra
#@ 
#@   set cmd "read_file -format ddc"
#@   if { [ info exists ra(-scenarios) ] } {
#@     set cmd "$cmd -scenarios { $ra(-scenarios) }"
#@   }
#@   if { [ info exists ra(-active_scenarios) ] } {
#@     set cmd "$cmd -active_scenarios { $ra(-active_scenarios) }"
#@   }
#@   set cmd "$cmd { $ra(file_names) }"
#@   return [uplevel \#0 $cmd]
#@ }
#@ 
#@ define_proc_attributes read_ddc     -info "Read one or more ddc files"     -permanent     -define_args {
#@       {file_names "Files to read" file_names list required}
#@       {-scenarios "list of scenarios to be read from ddc file"
#@ 	scenario_list list optional}
#@       {-active_scenarios "list of scenarios to be made active"
#@ 	active_scenario_list list optional}}
#@ 
#@ 
#@ 
#@ ##############################################################################
#@ #
#@ #  PROCEDURE:   source_tcl_file
#@ #
#@ #  ABSTRACT:    generic procedure to source another tcl file
#@ #
#@ #  Arguments:
#@ #               filename    tcl filename
#@ #               dir         directory to check for file
#@ #               msg         verbose message
#@ #               verbose     verbose mode
#@ #
#@ #  Usage:     
#@ #
#@ ##############################################################################
#@ #
#@ proc source_tcl_file { filename dir msg {verbose 1} } {
#@     set __qual_pref_file [file join $dir $filename]
#@     if {[file exists  $__qual_pref_file]} {
#@       if { $verbose } {
#@         echo $msg $__qual_pref_file
#@       }
#@       # use catch to recover from errors in the pref file
#@       echo_trace "Sourcing " $__qual_pref_file
#@       # to speed up sourcing use read and eval
#@       set f [open $__qual_pref_file]
#@       if {[catch {namespace eval :: [read -nonewline $f]} __msg]} {
#@           echo Error: Error during sourcing of $__qual_pref_file
#@           if {$__msg != ""}  { echo $__msg }
#@           # actually, it looks like $__msg is always null after
#@           # source fails
#@       }
#@       close $f
#@     } else {
#@       echo_trace "Info: File '" $__qual_pref_file "' does not exist!"
#@     }
#@ }
#@ define_proc_attributes source_tcl_file -hidden
#@ 
#@ 
#@ 
#@ ##############################################################################
#@ #
#@ #  PROCEDURE:   echo_trace
#@ #
#@ #  ABSTRACT:    echo only in trace modus
#@ #
#@ ##############################################################################
#@ #
#@ proc echo_trace { args } {
#@   if { [info exists ::env(TCL_TRACE)] } {
#@     echo  TRACE\> [join $args "" ]
#@   }
#@ }
#@ define_proc_attributes echo_trace -hidden
#@ 
#@ #############################################################################
#@ #
#@ # Following procedures added for PC write_script
#@ #
#@ #
#@ #
#@ ############################################################################
#@ 
#@ proc set_cell_restriction { args } {
#@   parse_proc_arguments -args $args ra
#@ 
#@     set cmd [format {set_attribute %s -type integer restrictions %s }     	$ra(cell)     	$ra(value)]
#@     return [uplevel #0 $cmd]
#@ 
#@ }
#@ define_proc_attributes set_cell_restriction -hidden   -define_args {            {cell "cell_name" cell string required} 	   {value   "value" value string required}    }
#@ 
#@ 
#@ proc set_cell_soft_keepout {args} {
#@   parse_proc_arguments -args $args ra
#@ 
#@     set cmd [format {set_keepout_margin -type soft -outer {%d %d %d %d} [list %s] }         $ra(llx)         $ra(lly)         $ra(urx)         $ra(ury)     	$ra(objects)]
#@     return [uplevel #0 $cmd]
#@ 
#@ 
#@ }
#@ 
#@ define_proc_attributes set_cell_soft_keepout -hidden  -define_args {          {llx "llx" llx float required}          {lly "lly" lly float required}          {urx "urx" urx float required}          {ury "ury" ury float required}          {objects "objects" objects list  required}  }
#@ 
#@ proc set_cell_hard_keepout {args} {
#@   parse_proc_arguments -args $args ra
#@ 
#@     set cmd [format {set_keepout_margin -type soft -outer {%d %d %d %d} [list %s] }         $ra(llx)         $ra(lly)         $ra(urx)         $ra(ury)     	$ra(objects)]
#@     return [uplevel #0 $cmd]
#@ 
#@ 
#@ }
#@ 
#@ define_proc_attributes set_cell_hard_keepout -hidden  -define_args {          {llx "llx" llx float required}          {lly "lly" lly float required}          {urx "urx" urx float required}          {ury "ury" ury float required}          {objects "objects" objects list  required}  }
#@ 
#@ set mw_use_pdb_lib_format false
#@ 
#@ ##############################################################################
#@ #
#@ #  PROCEDURE:   write_milkyway
#@ #
#@ #  ABSTRACT:    wrapper around save_mw_cel to support original write_milkyway
#@ #               interface
#@ # if { [info commands open_mw_cel] == "open_mw_cel" } {}
#@ #
#@ ##############################################################################
#@ 
#@ if { [string match -nocase {*icc_shell*} $synopsys_program_name] } {
#@ 
#@ proc write_milkyway args {
#@ 
#@   parse_proc_arguments -args $args ra
#@ 
#@   set cmd [format {save_mw_cel -as %s %s %s %s %s}                      $ra(-output)                     [array names ra -overwrite]                      [array names ra -create]                      [array names ra -all]                      [array names ra -dps]]
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ define_proc_attributes write_milkyway -hidden     -info " Saves the design as milkyway CEL"     -define_args       {{-output fileName "Name" string {optional}}       {-overwrite "Overwrite the current version" "" boolean {optional}}       {-create "Create from scratch" "" boolean {hidden optional}}       {-all "Save all modified cells" "" boolean {hidden optional}}       {-dps "Save internal DPS design" "" boolean {hidden optional}}}
#@ 
#@ ##############################################################################
#@ #
#@ #  PROCEDURE:   read_milkyway
#@ #
#@ #  ABSTRACT:    wrapper around open_mw_cel to support original read_milkyway
#@ #               interface
#@ #  MODIFIED:    To support DPS in Galileo we need to pass the filtering
#@ #               parameters to the DPS command. (Pankaj Goswami, Mar09 2005)
#@ #
#@ ##############################################################################
#@ 
#@ proc read_milkyway args {
#@ 
#@   parse_proc_arguments -args $args ra
#@ 
#@   set cmd [format {open_mw_cel %s}                      $ra() ]
#@ 
#@   if {[info exists ra(-library)]} {
#@     set cmd [concat [concat $cmd " -library " ] " $ra(-library) "]
#@   }
#@ 
#@   if {[info exists ra(-read_only)]} {
#@     lappend cmd {-readonly}
#@   }
#@ 
#@ # DPS specific stuff
#@   set dps_cmd "vh_set_current_partition "
#@   set read_mw_with_dps_filter false
#@                                                                                                                                              
#@   if {[info exists ra(-vh_module_only)]} {
#@      append dps_cmd "-vh_module_only "
#@      set read_mw_with_dps_filter true
#@   }
#@                                                                                                                                              
#@   if {[info exists ra(-vh_include)]} {
#@      append dps_cmd [concat " -vh_include " " \{ $ra(-vh_include) \}"]
#@      append dps_cmd " "
#@      set read_mw_with_dps_filter true
#@   }
#@ 
#@   if {[info exists ra(-vh_exclude)]} {
#@      append dps_cmd [concat " -vh_exclude" " \{ $ra(-vh_exclude) \}"]
#@      set read_mw_with_dps_filter true
#@   }
#@                                                                                                                                              
#@   if { $read_mw_with_dps_filter == true } {
#@      # Call the DPS command to store the DPS filtering params.
#@      uplevel #0 $dps_cmd
#@   } else {
#@      # If there is no DPS filtering params, then we need to reset the
#@      # params which might have been stored from the provious command.
#@      append dps_cmd " -vh_reset_partition"
#@      uplevel #0 $dps_cmd
#@   }
#@ # End of DPS stuff
#@ 
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ define_proc_attributes read_milkyway -hidden     -info " Read milkyway CEL from disk"     -define_args       {{-library "library name" "lib_name" string {optional}}       {-read_only "open design in read only mode" "" boolean {optional}}       {-version "version number of the CEL" "number" string {optional}}       {-vh_module_only "open design for DPS module only partition" "" boolean {hidden optional}}       {-vh_include "list of designs to be included in the DPS partition" "include_designs" list {hidden optional}}       {-vh_exclude "list of designs to be excluded in the DPS partition" "exclude_designs" list {hidden optional}}       {"" fileName "CEL name" string {required}}}
#@ 
#@ }
#@ 
#@ ##############################################################################
#@ #
#@ #  PROCEDURE:   set_mw_technology_file
#@ #
#@ #  ABSTRACT:    wrapper around update_mw_lib
#@ #
#@ #  HISTORY :    2009/6/21, yunz, support ALF reader in ICC
#@ #
#@ ##############################################################################
#@ if { [string match -nocase {*icc_shell*} $synopsys_program_name] || 
#@     ([string match -nocase {*dc_shell*} $synopsys_program_name] && [shell_is_mwlib_enabled]) }  {
#@ 
#@ proc set_mw_technology_file args {
#@ 
#@   parse_proc_arguments -args $args ra
#@ 
#@   set cmd ""
#@   set lib_name ""
#@   set pdb_file "tech.pdb"
#@   set log_file "log_file"
#@   set alf_file ""
#@ 
#@   if {[info exists ra(-technology)] && [info exists ra(-plib)]} {
#@       echo "Error: the $ra(-technology) and $ra(-plib) options are mutually exclusive."
#@       return [uplevel #0 $cmd]
#@   } elseif {[info exists ra(-technology)] && [info exists ra(-alf)]} {
#@       echo "Error: the $ra(-technology) and $ra(-alf) options are mutually exclusive."
#@       return [uplevel #0 $cmd]
#@   } elseif {[info exists ra(-plib)] && [info exists ra(-alf)]} {
#@       echo "Error: the $ra(-plib) and $ra(-alf) options are mutually exclusive."
#@       return [uplevel #0 $cmd]
#@   }
#@ 
#@   if {[info exists ra(-technology)]} {
#@ 
#@     set cmd [format {update_mw_lib -technology %s %s} 		     $ra(-technology) 		     $ra() ]
#@   }
#@ 
#@   if {[info exists ra(-plib)]} {
#@ 
#@     set cmd [format {update_mw_lib %s} 		     $ra() ]
#@ 
#@     if {[string match -nocase {*.pdb} $ra(-plib) ] } {
#@       set cmd [concat [concat $cmd " -plib " ] " $ra(-plib) "]
#@     }  
#@     if {[string match -nocase {*.plib} $ra(-plib) ] } {
#@       set subcmd [format {read_lib %s} $ra(-plib)]
#@       redirect -file log_file {uplevel #0 $subcmd}
#@       set f1 [open $log_file]
#@       while {[gets $f1 line] >= 0} {
#@    	set msg1 [lindex $line 3]
#@ 	set msg2 [lindex $line 4]
#@         if {[string match {read} $msg1] &&
#@ 	    [string match {successfully} $msg2] } {
#@ 	  set msg [lindex $line 2]
#@ 	  set len [string length $msg]
#@ 	  set lib_name [string range $msg 1 [expr $len-2] ]
#@ 	  break
#@         }  
#@         if {[string match {old} $msg1] &&
#@             [string match {technology} $msg2] } {
#@ 	  set msg [lindex $line 6]
#@ 	  set len [string length $msg]
#@ 	  set path [string range $msg 1 [expr $len-2] ]
#@ 	  set name1 [lindex [split $path {/}] end]
#@ 	  regexp {(.+?).pdb} $name1 match lib_name
#@ 	  break
#@         }
#@       }
#@       if {$lib_name != ""} {
#@         set subcmd [format {write_lib %s -output %s} $lib_name $pdb_file]
#@         uplevel #0 $subcmd
#@ 
#@         echo "Command is : "
#@         echo $cmd
#@ 
#@         set cmd [concat [concat $cmd " -plib " ] " $pdb_file "]
#@ 
#@         echo "Command is : "
#@         echo $cmd
#@ 
#@       } else {
#@         echo "Error: Can not compile $ra(-plib) to pdb successfully"
#@         return 0;
#@       }
#@     }
#@   }
#@   if {[info exists ra(-alf)]} {
#@ 
#@     set cmd [format {update_mw_lib %s} 		     $ra() ]
#@ 
#@     set cmd [concat [concat $cmd " -alf " ] " $ra(-alf) "]
#@   }
#@ 
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ define_proc_attributes set_mw_technology_file -hide_body     -info " Set technology file for the library "     -define_args       {{-technology "Technology file name" "tech_file" string {optional}}       {-plib "Plib file name" "file_name" string  {optional}}      {-alf "alf file name" "file_name" string  {optional}}      {"" "Library name" "libName" string {required}}}
#@ 
#@ ##############################################################################
#@ #
#@ #  PROCEDURE:   rebuild_mw_lib
#@ #
#@ #  ABSTRACT:    wrapper around update_mw_lib
#@ #
#@ ##############################################################################
#@ 
#@ proc rebuild_mw_lib args {
#@ 
#@   parse_proc_arguments -args $args ra
#@ 
#@   set cmd [format {update_mw_lib -rebuild %s}                         $ra() ]
#@ 
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ define_proc_attributes rebuild_mw_lib -hide_body     -info " Rebuild the library "     -define_args       {{"" "Library name" "libName" string {required}}}
#@ 
#@ ##############################################################################
#@ #
#@ #  PROCEDURE:   set_mw_lib_reference
#@ #
#@ #  ABSTRACT:    Procedure to set ref lib list or ref ctrl file
#@ #
#@ ##############################################################################
#@ 
#@ proc set_mw_lib_reference args {
#@ 
#@   parse_proc_arguments -args $args ra
#@ 
#@   set cmd ""
#@ 
#@   if {[info exists ra(-mw_reference_library)]} {
#@     set cmd [format {set_reference_control_file -reference_libraries {%s} %s}                         $ra(-mw_reference_library)                         $ra() ]
#@   }
#@ 
#@   if {[info exists ra(-reference_control_file)]} {
#@     set cmd [format {set_reference_control_file -file %s %s}                         $ra(-reference_control_file)                         $ra() ]
#@   }
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ define_proc_attributes set_mw_lib_reference -hide_body     -info " Set reference for the library "     -define_args       {{-mw_reference_library "List of reference libraries" "lib_list" list {optional}}       {-reference_control_file "Reference control file" "file_name" string {optional}}       {"" "Library name" "libName" string {required}}}
#@ 
#@ #
#@ ##############################################################################
#@ #
#@ #  PROCEDURE:   create_mw_lib
#@ #
#@ #  ABSTRACT:    wrapper around MWUI create_mw_lib 
#@ #
#@ ##############################################################################
#@ 
#@ proc create_mw_lib args {
#@ 
#@   parse_proc_arguments -args $args ra
#@ 
#@   set cmd ""
#@   set lib_name ""
#@   set pdb_file "tech.pdb"
#@   set log_file "log_file"
#@  
#@   if {[info exists ra(-ignore_case)]} {
#@     set cmd [format {org_create_mw_lib %s}                         $ra() ]
#@   } else {
#@     set cmd [format {org_create_mw_lib -case_sensitive %s}                         $ra() ]
#@   }
#@ 
#@   if {[info exists ra(-technology)]} {
#@     set cmd [concat [concat $cmd " -technology " ] " $ra(-technology) "]
#@   } 
#@ 
#@   if {[info exists ra(-ignore_tf_error)]} {
#@     set cmd [concat $cmd " -ignore_tf_error " ]
#@   }
#@ 
#@   if {[info exists ra(-hier_separator)]} {
#@     set cmd [concat [concat $cmd " -hier_seperator " ] " $ra(-hier_separator) "]
#@   }
#@ 
#@   if {[info exists ra(-bus_naming_style)]} {
#@     set cmd [concat [concat $cmd " -bus_naming_style " ] " {$ra(-bus_naming_style)} "]
#@   }
#@ 
#@   
#@   if {[info exists ra(-reference_control_file)]} {
#@     set cmd [concat [concat $cmd " -reference_control_file " ] " $ra(-reference_control_file) "]
#@   }  
#@ 
#@   if {[info exists ra(-mw_reference_library)]} {
#@     set cmd [concat [concat [concat $cmd " -mw_reference_library {" ] " $ra(-mw_reference_library) "] "}"]
#@   }
#@   
#@   if {[info exists ra(-plib)]} {
#@ 	if {[string match -nocase {*.pdb} $ra(-plib) ] } {
#@   	  set cmd [concat [concat $cmd " -plib " ] " $ra(-plib) "]
#@ 	}  
#@ 	if {[string match -nocase {*.plib} $ra(-plib) ] } {
#@ 	  set subcmd [format {read_lib %s} $ra(-plib)]
#@ 	  redirect -file log_file {uplevel #0 $subcmd}
#@ 	  set f1 [open $log_file]
#@ 	  while {[gets $f1 line] >= 0} {
#@ 	  	set msg1 [lindex $line 3]
#@ 		set msg2 [lindex $line 4]
#@ 	    if {[string match {read} $msg1] &&
#@ 		    [string match {successfully} $msg2] } {
#@ 		  set msg [lindex $line 2]
#@ 		  set len [string length $msg]
#@ 		  set lib_name [string range $msg 1 [expr $len-2] ]
#@ 		  break
#@ 	    }  
#@ 	    if {[string match {old} $msg1] &&
#@ 		[string match {technology} $msg2] } {
#@ 		  set msg [lindex $line 6]
#@ 		  set len [string length $msg]
#@ 		  set path [string range $msg 1 [expr $len-2] ]
#@ 		  set name1 [lindex [split $path {/}] end]
#@ 		  regexp {(.+?).pdb} $name1 match lib_name
#@ 		  break
#@ 	    }
#@ 	  }
#@ 	  if {$lib_name != ""} {
#@ 	    set subcmd [format {write_lib %s -output %s} $lib_name $pdb_file]
#@ 	    uplevel #0 $subcmd
#@ 	    set cmd [concat [concat $cmd " -plib " ] " $pdb_file "]
#@ 	  } else {
#@ 	    echo "Error: Can not compile $ra(-plib) to pdb successfully"
#@ 	    return 0;
#@ 	  }
#@ 	}
#@   }
#@ 
#@   if { ![uplevel #0 $cmd] } {
#@     return 0
#@   }
#@ 
#@   set cmd ""
#@ 
#@   if {[info exists ra(-open)]} {
#@     uplevel #0 $cmd
#@     set cmd [format {open_mw_lib %s}                         $ra() ]
#@   }
#@ 
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ define_proc_attributes create_mw_lib -hide_body     -info " Create a milkyway library "     -define_args       {{-technology "Technology file name" "file_name" string {optional}}           {-ignore_tf_error "Ignore the error in technology file" "" boolean {hidden optional}} 	  {-plib "Plib file name" "file_name" string  {optional}}       {-hier_separator "Hierarchical separator, default is backslash / " "separator" string {optional}}       {-bus_naming_style "Bus naming style" "bus_naming_style" string {optional}}       {-ignore_case "Make case insensitive" "" boolean {hidden optional}}       {-case_sensitive "Make case sensitive" "" boolean {hidden optional}}       {-mw_reference_library "List of reference libraries" "lib_list" list {optional}}       {-reference_control_file "Reference control file" "file_name" string {optional}}       {-open "Open the library after creation" "" boolean {optional}}       {"" "Library name to create" "libName" string {required}}}
#@ 
#@ #
#@ ##############################################################################
#@ #
#@ #  PROCEDURE:   report_mw_lib
#@ #
#@ #  ABSTRACT:    wrapper around MWUI report_mw_lib
#@ #
#@ ##############################################################################
#@ 
#@ proc report_mw_lib args {
#@ 
#@   parse_proc_arguments -args $args ra
#@ 
#@   set cmd ""
#@ 
#@   if {[info exists ra(-mw_reference_library)]} {
#@     if {[info exists ra()]} {
#@       set cmd [format {report_mw_lib_ref_lib_list %s} $ra() ]
#@     } else {
#@       set cmd [format {report_mw_lib_ref_lib_list} ]
#@     }
#@     return [uplevel #0 $cmd]
#@   }
#@ 
#@   if {[info exists ra(-unit_range)]} {
#@     if {[info exists ra()]} {
#@       set cmd [format {org_report_mw_lib -unit_range %s}                         $ra() ]
#@     } else {
#@       echo "Error : Library name must be specified when using this option"
#@       return 0;
#@     }
#@     return [uplevel #0 $cmd]
#@   }
#@ 
#@ }
#@ 
#@ define_proc_attributes report_mw_lib -hide_body     -info " Report information about the library "     -define_args       {{-unit_range "Report unit range of library" "" boolean {optional}}       {-mw_reference_library "Report list of reference libraries" "" boolean {optional}}       {"" "Library to be reported" "libName" string {optional}}}
#@ 
#@ ##############################################################################
#@ #
#@ #  PROCEDURE:   close_mw_lib
#@ #
#@ #  ABSTRACT:    Wrapper around close_mw_lib to handle -save option properly
#@ #      - save_mw_cel to save current cel with dc_netlist
#@ #      - close_mw_cel to close current cel
#@ #      - save_open_cels to save other open cels before closing library
#@ #
#@ ##############################################################################
#@ 
#@ proc close_mw_lib args {
#@ 
#@   parse_proc_arguments -args $args ra
#@ 
#@   if {$args == ""} {
#@     set cmd [format {icc_is_dc_up} ]
#@     if {[uplevel #0 $cmd]} {
#@       set cmd [format {remove_design -quiet -designs} ]
#@     if {[uplevel #0 $cmd]} {
#@     set cmd [format {org_close_mw_lib } ]
#@     return [uplevel #0 $cmd]
#@     } else {
#@       return 0
#@   }
#@     } else {
#@       set cmd [format {org_close_mw_lib } ]
#@       return [uplevel #0 $cmd]
#@   }
#@   }
#@ 
#@   if {[info exists ra(-save)]} {
#@ 
#@     set cmd [format {save_mw_cel} ]
#@     if {![uplevel #0 $cmd]} {
#@       return
#@     }
#@ 
#@     set cmd [format {close_mw_cel} ]
#@     if {![uplevel #0 $cmd]} {
#@       return
#@     }
#@ 
#@     set cmd [format {save_open_cels} ]
#@     if {![uplevel #0 $cmd]} {
#@       return
#@     }
#@   }
#@ 
#@   set cmd [format {org_close_mw_lib} ]
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ if { [string match -nocase {*icc_shell*} $synopsys_program_name] } {
#@   define_proc_attributes close_mw_lib -hide_body       -info " Closes the milkyway library "       -define_args         {{-save "Save open cels" "" boolean {optional}}         {"" "libraries to be closed" "lib list" list {hidden optional}}}
#@ } else {
#@   define_proc_attributes close_mw_lib -hide_body       -info " Closes the milkyway library "       -define_args         {{-no_save "Don't save open cels" "" boolean {hidden optional}}         {"" "libraries to be closed" "lib list" list {hidden optional}}}
#@ }
#@ ##############################################################################
#@ #
#@ #  PROCEDURE:   write_mw_lib_files
#@ #
#@ #  ABSTRACT:    Write technology or reference control file
#@ #
#@ ##############################################################################
#@ proc write_mw_lib_files args {
#@ 
#@   parse_proc_arguments -args $args ra
#@ 
#@   set cmd ""
#@ 
#@   if {[info exists ra(-reference_control_file)]} {
#@    #Option -reference_contrl_file, -plib and -technology are exclusive.
#@    # If both of them are set at the same time, error reported.
#@    # 9000273455, by xqsun, 2009/2/4
#@      if {[info exists ra(-technology)]} {
#@        echo "Error: Cannot specify '-reference_control_file' with '-technology'.(CMD-001)"
#@        return 0
#@      } elseif {[info exists ra(-plib)]} {
#@        echo "Error: Cannot specify '-reference_control_file' with '-plib'.(CMD-001)"
#@        return 0
#@      } else {
#@        set cmd [format {report_mw_lib_ref_ctrl_file -output %s %s}                            $ra(-output)                            $ra() ]
#@        return [uplevel #0 $cmd]
#@      }
#@   }
#@ 
#@   if {[info exists ra(-technology)]} {
#@      if {[info exists ra(-plib)]} {
#@        echo "Error: Cannot specify '-technology' with '-plib'.(CMD-001)"
#@        return 0
#@      } else {
#@        set cmd [format {org_report_mw_lib -output %s %s}                            $ra(-output)                            $ra() ]
#@        return [uplevel #0 $cmd]
#@      }
#@   }
#@ 
#@   if {[info exists ra(-plib)]} {
#@     set cmd [format {write_plib -lib_name %s %s}                         $ra()                         $ra(-output) ]
#@     return [uplevel #0 $cmd]
#@   }
#@ }
#@ 
#@ define_proc_attributes write_mw_lib_files -hide_body     -info " Write technology or reference control file "     -define_args       {{-technology "Dump technology file" "" boolean {optional}} 	  {-plib "Dump plib file" "" boolean {optional}}       {-reference_control_file "Dump reference control file" "" boolean {optional}}       {-output "Output file" "file_name" string {required}}       {"" "Library to be reported" "libName" string {required}}}
#@ }
#@ ##############################################################################
#@ #
#@ #  PROCEDURE:   close_mw_cel
#@ #
#@ #  ABSTRACT:    Wrapper around close_mw_cel to add -save option
#@ #  remove_timing_design is the command to shutdown dc netlist
#@ #
#@ ##############################################################################
#@ if { [string match -nocase {*icc_shell*} $synopsys_program_name] } {
#@ 
#@ proc close_mw_cel args {
#@ 
#@   parse_proc_arguments -args $args ra
#@   
#@   global mw_is_all_views     
#@   set cmd [format {icc_is_dc_up} ]
#@   set dc_is_up [uplevel #0 $cmd]
#@    
#@   set cmd_close [format {org_close_mw_cel} ]
#@   
#@   if {[info exists ra(-all_views)]} {
#@       set cmd_close [format {%s -all_views} $cmd_close]
#@       set mw_is_all_views 1    
#@   }
#@   if {[info exists ra(-all_versions)]} {
#@       set cmd_close [format {%s -all_versions} $cmd_close]
#@   }
#@   if {[info exists ra(-save)]} {
#@       set cmd_close [format {%s -save} $cmd_close]
#@   } 
#@   if {[info exists ra(-verbose)]} {
#@       set cmd_close [format {%s -verbose} $cmd_close]
#@   }
#@   if {[info exists ra(-hierarchy)]} {
#@       set cmd_close [format {%s -hierarchy} $cmd_close]
#@   }
#@ 
#@   ui_util_clean_saved_lib_attr $args
#@   
#@   set cmd ""
#@   set lcels ""
#@   set is_current_closed 1
#@ 
#@   if {[info exists ra()]} {
#@     set lcels $ra()
#@   }
#@   set len [string length $lcels]
#@   if {$len > 0} {
#@     set is_current_closed [is_current_mw_cel $lcels]
#@     set cmd_close [format {%s {%s}} $cmd_close $lcels]
#@   }
#@   if {[uplevel #0 $cmd_close]} {
#@       set mw_is_all_views 0 
#@       if {$dc_is_up == 1} {
#@       if {$is_current_closed == 1} {
#@         set cmd [format {remove_design -quiet -designs} ]
#@         return [uplevel #0 $cmd]
#@       }
#@       return 1
#@     } else {
#@       return 1
#@     }
#@   } else {
#@       set mw_is_all_views 0
#@       return 0
#@   }
#@ }
#@ 
#@ define_proc_attributes close_mw_cel -hide_body     -info " Closes the design "     -define_args       {{-save "Save the design" "" boolean {optional}}       {-discard "Discard any changes" "" boolean {optional hidden}}       {-verbose "Print out debugging messages" "" boolean {optional hidden}}       {-hierarchy "Close top design and its child designs" "" boolean {optional}}       {-all_views "Close all views of the design" "" boolean {optional}}       {-all_versions "Close all versions of the design" "" boolean {optional}}       {"" "designs to be closed" "design list" list {optional}}}
#@ 
#@ ##############################################################################
#@ #
#@ #  PROCEDURE:  save_all_mw_cel 
#@ #
#@ #  ABSTRACT:    Wrapper around save_mw_cel to save all the open cels. Needed for Black box flow.
#@ #
#@ ##############################################################################
#@         
#@ proc save_all_mw_cels { } {
#@   set top_cel [get_attribute [current_mw_cel] name]
#@ 
#@   set cels [fp_get_open_cells]
#@ 
#@   foreach cel $cels {
#@     if {$cel != $top_cel} {
#@       current_mw_cel $cel
#@ 
#@       save_mw_cel
#@     }
#@   }
#@ 
#@   current_mw_cel $top_cel
#@ 
#@   save_mw_cel
#@ }
#@ 
#@ icc_hide_cmd save_all_mw_cels
#@ 
#@ ##############################################################################
#@ #  PROCEDURE:   execute_command_and_create_cel_from_scratch 
#@ #  ABSTRACT:    This procedure executes the given command and creates the CEL
#@ #               from scratch after executing this command.
#@ ##############################################################################
#@ proc execute_command_and_create_cel_from_scratch {org_cmd_name args} {
#@   global mw_create_cel_force
#@   global mw_enable_auto_cel
#@   global mw_force_auto_cel
#@ 
#@   set lib [current_mw_lib]
#@ 
#@   # If no MW lib, design is not from MW. Execute the original command 
#@   # and return.
#@   if {$lib == ""} {
#@     return [eval $org_cmd_name $args]
#@   }
#@ 
#@   # Get values of few variables.
#@   set incr_mode $mw_create_cel_force
#@   set mw_create_cel_force TRUE
#@ 
#@   # Get auto cel mode, disable it temporarily if enabled.
#@   set auto_cel_mode $mw_enable_auto_cel
#@   set mw_enable_auto_cel FALSE
#@ 
#@   # Check if the already existing CEL is auto-CEL.
#@   set auto_cel 0
#@   if {[is_cel_auto_cel]} {
#@       set auto_cel 1
#@   } elseif {![get_top_cel_mwid]} {
#@       set auto_cel 1
#@   }
#@ 
#@ 
#@   # Run the original command, if not successful restore the incr_mode 
#@   # variable and return. No CEL is created.
#@   if {![eval $org_cmd_name $args]} {
#@     set mw_create_cel_force $incr_mode
#@     set mw_enable_auto_cel $auto_cel_mode
#@     return 0
#@   }
#@ 
#@   # Restore auto_cel mode
#@   set mw_enable_auto_cel $auto_cel_mode
#@ 
#@   # Now create auto or real CEL depending on what the original CEL was.
#@   if {$auto_cel == "1"} {
#@   # Force creation of auto-CEL, since commands other than read_def/pdef
#@   # do not decouple CEL from DC.
#@ 
#@   set mw_force_auto_cel TRUE
#@     set cmd [format {save_mw_cel -auto}] 
#@   } else {
#@       if [get_top_cel_mwid] {
#@       set cmd [format {save_mw_cel -create}] 
#@       echo "Information: Command not supported by incr. update or write-thru."
#@       echo "             Creating new CEL from scratch, old CEL will be closed."
#@     }
#@   }
#@ 
#@   # Create the Auto CEL or normal CEL from scratch.
#@   if {![uplevel #0 $cmd]} {
#@     set mw_create_cel_force $incr_mode
#@     set mw_force_auto_cel FALSE
#@     return 0
#@   }
#@ 
#@   set mw_create_cel_force $incr_mode
#@   set mw_force_auto_cel FALSE
#@   return 1
#@ }
#@ 
#@ define_proc_attributes execute_command_and_create_cel_from_scratch -hidden     -hide_body
#@ 
#@ ##############################################################################
#@ #  PROCEDURE:   read_def
#@ #  ABSTRACT:    Wrapper around read_def to handle incremental update properly
#@ #  if MW based read_def is used, bypass the wrapper
#@ #  enable_milkyway_def_reader_writer must be TRUE and use_pdb_lib_format must
#@ # be false for MW read_Def to be run, use wrapper if either condition fails
#@ ##############################################################################
#@ rename -force dc_read_def org_read_def
#@ icc_hide_cmd org_read_def
#@ proc dc_read_def args {
#@   parse_proc_arguments -args $args ra
#@ 
#@   return [eval execute_command_and_create_cel_from_scratch "org_read_def" $args]
#@ }
#@ 
#@ define_proc_attributes dc_read_def -hide_body     -info " Read a def file "     -define_args       {{-design "name of design for which clusters are to be read" "" string {optional}}        {-quiet "do not print out any warnings" "" boolean {optional}}        {-verbose "print out more warnings" "" boolean {optional}}        {-allow_physical_cells "allow physical cells" "" boolean {optional}}        {-allow_physical_ports "allow physical ports" "" boolean {optional}}        {-allow_physical_nets "allow physical nets" "" boolean {optional}}        {-skip_signal_nets "skip signal nets" "" boolean {optional}}        {-incremental "incremental" "" boolean {optional}}        {-enforce_scaling "enforce_scaling" "" boolean {optional}}        {-move_bounds "move bounds" "" boolean {optional}}        {"" "input def file names" "input_def_file_name" string {required}}}
#@ 
#@ 
#@ ##############################################################################
#@ #  PROCEDURE:   group
#@ #  ABSTRACT:    Wrapper around group to handle incremental update properly
#@ ##############################################################################
#@ rename -force group org_group
#@ icc_hide_cmd org_group
#@ proc group args {
#@   parse_proc_arguments -args $args ra
#@   return [eval execute_command_and_create_cel_from_scratch "org_group" $args]
#@ }
#@ 
#@ define_proc_attributes group -hide_body   -info " create new hierarchy"   -define_args    {{-except "cells not to be included in the group" "exclude_list" list {optional}}
#@     {-design_name "name of design created for new hierarchy" "design_name" string {optional}}
#@     {-cell_name "name of cell created for new hierarchy" "cell_name" string {optional}}
#@     {-logic "group any combinational elements" "" boolean {optional}}
#@     {-pla "group any PLA elements" "" boolean {optional}}
#@     {-fsm "group all elements part of a finite state machine" "" boolean {optional}}
#@     {-hdl_block "name of hdl_block to group" "" string {optional}}
#@     {-hdl_bussed "group all bussed gates under this block" "" boolean {optional}}
#@     {-hdl_all_blocks "group all hdl blocks under this block" "" boolean {optional}}
#@     {-soft "set the group_name attribute" "" boolean {optional}}
#@     {"" "cells to be included in the group" "cell_list" list {optional}}}
#@ 
#@ ##############################################################################
#@ #  PROCEDURE:   copy_design
#@ #  ABSTRACT:    Wrapper around copy_design to handle incremental update properly
#@ ##############################################################################
#@ rename -force copy_design org_copy_design
#@ icc_hide_cmd org_copy_design
#@ proc copy_design args {
#@   parse_proc_arguments -args $args ra
#@   return [eval execute_command_and_create_cel_from_scratch "org_copy_design" $args]
#@ }
#@ 
#@ define_proc_attributes copy_design -hide_body   -info " copy_design"   -define_args    {{"" "List of designs to be copied" "design_list" list {required}}
#@     {"" "Name of new design or target file" "target_name" string {required}}}
#@ 
#@ ##############################################################################
#@ #  PROCEDURE:   create_design
#@ #  ABSTRACT:    Wrapper around create_design to handle incremental update properly
#@ ##############################################################################
#@ rename -force create_design org_create_design
#@ icc_hide_cmd org_create_design
#@ proc create_design args {
#@   parse_proc_arguments -args $args ra
#@   return [eval execute_command_and_create_cel_from_scratch "org_create_design" $args]
#@ }
#@ 
#@ define_proc_attributes create_design -hide_body   -info " Creates a design in dc_shell memory"   -define_args    {{"" "name of the design to create" "<design_name>" string {required}}
#@     {"" "name of file for design; optional" "<file_name>" string {optional}}}
#@ 
#@ ##############################################################################
#@ #  PROCEDURE:   reset_design
#@ #  ABSTRACT:    Wrapper around reset_design to handle incremental update properly
#@ ##############################################################################
#@ #rename -force reset_design org_reset_design
#@ #icc_hide_cmd org_reset_design
#@ #proc reset_design args {
#@ #  parse_proc_arguments -args $args ra
#@ #  return [eval execute_command_and_create_cel_from_scratch "org_reset_design" $args]
#@ #}
#@ 
#@ ##############################################################################
#@ #  PROCEDURE:   rename_design
#@ #  ABSTRACT:    Wrapper around rename_design to handle incremental update properly
#@ ##############################################################################
#@ rename -force rename_design org_rename_design
#@ icc_hide_cmd org_rename_design
#@ proc rename_design args {
#@   parse_proc_arguments -args $args ra
#@   return [eval execute_command_and_create_cel_from_scratch "org_rename_design" $args]
#@ }
#@ 
#@ define_proc_attributes rename_design -hide_body   -info " rename_design"   -define_args    {{"" "List of designs to be renamed" "design_list" list {required}}
#@     {"" "Name of new design or target file" "target_name" string {required}}}
#@ 
#@ }
#@ 
#@ ##############################################################################
#@ # If we are in icc_shell (i.e. Galileo) then
#@ # load the procedures to switch between DC and Milkyway collections.
#@ # Set the default to MW collection unless otherwise specified.
#@ ##############################################################################
#@ if { [string match -nocase {*icc_shell*} $synopsys_program_name] } {
#@     # load the procedures that switch between DC and MW collections
#@     source $synopsys_root/auxx/syn/collection_procs.tcl
#@ 
#@     set CS mw 
#@ 
#@     # see if the user wants DC
#@     if {! [catch {getenv USE_DC_COLLECTIONS_ONLY}] &&
#@ 	  [getenv USE_DC_COLLECTIONS_ONLY] } {
#@ 	set CS dc 
#@     }  
#@ 
#@     # set the collection source now
#@     redirect /dev/null {
#@       if {[catch {set_collection_mode -handle $CS}]} {
#@         catch {set_collection_option -handle $CS}
#@       } 
#@     } 
#@     
#@     unset CS
#@ }
#@ 
#@ ##############################################################################
#@ # procedure for route command 
#@ # echo the command to a temp tcl file for seperate process to pick up
#@ ##############################################################################
#@ if { [string match -nocase {*icc_shell*} $synopsys_program_name] } {
#@     rename -force route org_route
#@     icc_hide_cmd org_route
#@     proc route args {
#@         set route_cmd_file_name ".route_cmd.tcl"
#@         set route_cmd_temp_file_name ".route_cmd.tcl.temp"
#@         set fp [open $route_cmd_file_name "w"]
#@         set route_cmd [concat "sep_proc_route " $args " -child"]
#@         puts $fp $route_cmd
#@         close $fp
#@         
#@         uplevel #0 rename -force route route_temp_proc
#@         uplevel #0 rename -force org_route route
#@         set status  [ uplevel #0 route $args  ]
#@         uplevel #0 rename -force route org_route
#@         uplevel #0 rename -force route_temp_proc route
#@         
#@         if { [info exist status ] == 1 } {
#@             return $status
#@         }
#@         return 
#@     }
#@ }
#@ 
#@ ##############################################################################
#@ # Tcl Command: set_ignore_cell
#@ # Description: Load the command only in IC Compiler (icc_shell)
#@ ##############################################################################
#@ if { [string match -nocase {*icc_shell*} $synopsys_program_name] } {
#@     source $synopsys_root/auxx/syn/psyn/ideal_cell.tcl.e
#@ }
#@ 
#@ ##############################################################################
#@ # Tcl Command: check_physical_design
#@ # Description: Load the command only in IC Compiler (icc_shell)
#@ ##############################################################################
#@ if { [string match -nocase {*icc_shell*} $synopsys_program_name] } {
#@     # Load the compiled Tcl byte-code:
#@     source $synopsys_root/auxx/syn/psyn/check_physical_design_core.tbc
#@     source $synopsys_root/auxx/syn/psyn/check_physical_design_utils.tbc
#@     source $synopsys_root/auxx/syn/psyn/check_physical_design_flows.tbc
#@     source $synopsys_root/auxx/syn/psyn/check_physical_design_reports.tbc
#@     source $synopsys_root/auxx/syn/psyn/check_physical_design_ui.tbc
#@     source $synopsys_root/auxx/syn/psyn/create_qor_snapshot.tbc
#@     source $synopsys_root/auxx/syn/psyn/report_qor_snapshot.tbc
#@     source $synopsys_root/auxx/syn/psyn/msgParser.tbc
#@     source $synopsys_root/auxx/syn/psyn/displacement_gui.tbc
#@ }
#@ 
#@ ##############################################################################
#@ # ICC setup and hiding commands/procs etc
#@ ##############################################################################
#@ 
#@ if { [string match -nocase {*icc_shell*} $synopsys_program_name] } {
#@ #set  save_mw_cel_lib_setup  TRUE
#@ #set  auto_restore_mw_cel_lib_setup FALSE
#@ 
#@ alias create_wiring_keepout create_wiring_keepouts
#@ alias get_wiring_keepout get_wiring_keepouts
#@ alias get_placement_keepout get_placement_keepouts
#@ alias create_placement_keepout create_placement_keepouts
#@ 
#@ icc_hide_cmd execute_command_and_create_cel_from_scratch
#@ icc_hide_cmd dc_read_def
#@ icc_hide_cmd read_edif
#@ icc_hide_cmd read_sverilog
#@ icc_hide_cmd read_vhdl
#@ icc_hide_cmd set_collection_mode
#@ icc_hide_cmd return_dc_collection
#@ icc_hide_cmd return_mw_collection
#@ set mw_use_pdb_lib_format true
#@ }
#@ 
#@ 
#@ # -- End source /usr/cad/synopsys/synthesis/cur/auxx/syn/.dc_procs.tcl

#@ 
#@ # Temporary fix for the LMC_HOME variable- set it to an empty string 
#@ 
#@ if { [catch {getenv LMC_HOME } __err ] != 0 } {
#@   setenv LMC_HOME ""
#@ }
#@ 
#@ 
#@ #
#@ #
#@ #       Site-Specific Variables
#@ #
#@ #       These are the variables that are most commonly changed at a
#@ #       specific site, either upon installation of the Synopsys software,
#@ #       or by specific engineers in their local .synopsys files.
#@ #
#@ #
#@ 
#@ # from the System Variable Group 
#@ set link_force_case  "check_reference"
#@ set link_library  { * your_library.db }
#@ 
#@ set search_path [list . ${synopsys_root}/libraries/syn ${synopsys_root}/dw/syn_ver ${synopsys_root}/dw/sim_ver]
#@ set target_library  your_library.db
#@ set synthetic_library  ""
#@ set command_log_file  "./command.log"
#@ set designer  ""
#@ set company  ""
#@ set find_converts_name_lists  "false"
#@ 
#@ set symbol_library  your_library.sdb 
#@ 
#@ # Turn on Formality SVF recording
#@ if { $synopsys_program_name == "dc_shell"      ||      $synopsys_program_name == "design_vision" } { 
#@   set_svf -default default.svf
#@ }
#@ 
#@ # from the Schematic Variable Group 
#@ 
#@ # from the Plot Variable Group 
#@ if { $sh_arch == "hp700" } {
#@   set plot_command "lp -d" 
#@ } else {
#@   set plot_command "lpr -Plw" 
#@ }
#@ 
#@ set view_command_log_file  "./view_command.log"
#@ 
#@ # from the View Variable group
#@ if { $sh_arch == "hp700" } {
#@    set text_print_command  "lp -d" 
#@ } else {
#@    set text_print_command  "lpr -Plw" 
#@ }
#@ #
#@ #       System Variable Group:
#@ #
#@ #       These variables are system-wide variables.
#@ #
#@ set arch_init_path ${synopsys_root}/${sh_arch}/motif/syn/uid
#@ set auto_link_disable  "false"
#@ set auto_link_options  "-all"
#@ set uniquify_naming_style  "%s_%d"
#@ set verbose_messages  "true"
#@ set echo_include_commands  "true"
#@ set svf_file_records_change_names_changes "true"
#@ set change_names_update_inst_tree   "true"
#@ set change_names_dont_change_bus_members false
#@ set default_name_rules ""
#@ #set tdrc_enable_clock_table_creation   "true"
#@ 
#@ #
#@ #       Compile Variable Group:
#@ #
#@ #       These variables affect the designs created by the COMPILE command.
#@ #
#@ set compile_assume_fully_decoded_three_state_busses   "false"
#@ set compile_no_new_cells_at_top_level   "false"
#@ set compile_dont_touch_annotated_cell_during_inplace_opt   "false"
#@ set compile_update_annotated_delays_during_inplace_opt  "true"
#@ set compile_instance_name_prefix   "U"
#@ set compile_instance_name_suffix   ""
#@ set compile_negative_logic_methodology   "false"
#@ set compile_disable_hierarchical_inverter_opt   "false"
#@ set compile_use_fast_delay_mode   "true"
#@ set compile_use_low_timing_effort   "false"
#@ set compile_fix_cell_degradation   "false"
#@ set compile_preserve_subdesign_interfaces   "false"
#@ set port_complement_naming_style   "%s_BAR"
#@ set compile_implementation_selection   "true"
#@ set compile_delete_unloaded_sequential_cells   "true"
#@ set reoptimize_design_changed_list_file_name   ""
#@ set compile_checkpoint_phases "false"
#@ set compile_cpu_limit 0.0
#@ set compile_log_format "  %elap_time %area %wns %tns %drc %endpoint";
#@ set compile_top_all_paths   "false"
#@ set compile_top_acs_partition "false"
#@ set default_port_connection_class "universal"
#@ set compile_hold_reduce_cell_count "false"
#@ set compile_retime_license_behavior "wait"
#@ set dont_touch_nets_with_size_only_cells "false"
#@ set suppress_errors  {PWR-18 OPT-932 OPT-317}
#@ if { $synopsys_program_name == "dc_shell" && [shell_is_in_topographical_mode] } {
#@    set dct_prioritize_area_correlation "false"
#@ }
#@ 
#@ #
#@ # Variable(s) to control the behavior of the optimize_registers command
#@ #
#@ set optimize_reg_always_insert_sequential false 
#@ set optimize_reg_max_time_borrow -1048576.0
#@ set optimize_reg_retime_clock_gating_latches false
#@ 
#@ group_variable retiming optimize_reg_always_insert_sequential
#@ group_variable retiming optimize_reg_max_time_borrow
#@ group_variable retiming optimize_reg_retime_clock_gating_latches
#@ 
#@ 
#@ set ldd_return_val 0
#@ if { [string compare $dc_shell_mode "default"] == 0 } {
#@   set ldd_script ${synopsys_root}/auxx/syn/scripts/list_duplicate_designs.dcsh
#@   alias list_duplicate_designs "include -quiet ldd_script; dc_shell_status = ldd_return_val "
#@ 
#@ }
#@ if { [string compare $dc_shell_mode "tcl"] == 0 } {
#@   source ${synopsys_root}/auxx/syn/scripts/list_duplicate_designs.tcl
#@ }
#@ ####################################################################### 
#@ #
#@ #  list_duplicate_designs.tcl		21 Sept. 2006
#@ #
#@ #  List designs in dc_shell memory that have the same design name
#@ #
#@ #  COPYRIGHT (C) 2006, SYNOPSYS INC., ALL RIGHTS RESERVED.
#@ #
#@ #######################################################################
#@ 
#@ proc list_duplicate_designs { args } {
#@     parse_proc_arguments -args $args ra
#@ 
#@     # Get the list of duplicate designs
#@     set the_pid [pid]
#@     set rand_1 [expr int(rand() * 100000)]
#@     set temp_file_1 [format "/tmp/ldd_design_%s_%s" $the_pid $rand_1]
#@ 
#@     redirect $temp_file_1 { foreach_in_collection ldd_design [find design "*"] {
#@         echo [get_object_name $ldd_design]
#@     } }
#@ 
#@     set rand_2 [expr int(rand() * 100000)]
#@     set temp_file_2 [format "/tmp/ldd_design_%s_%s" $the_pid $rand_2]
#@ 
#@     sh sort $temp_file_1 | uniq -d | tee $temp_file_2
#@     file delete $temp_file_1 
#@ 
#@     # Report duplicates
#@     if { ! [file size $temp_file_2] } {
#@         echo [concat {No duplicate designs found.}]
#@         set ldd_return_val 0
#@     } else {
#@         set rand_3 [expr int(rand() * 100000)]
#@         set temp_file_3 [format "/tmp/ldd_design_%s_%s" $the_pid $rand_3]
#@         echo {Warning:  Multiple designs in memory with the same design name.}
#@         echo {}
#@         echo {   Design            File            Path}
#@         echo {   ------            ----            ----}
#@         list_designs -table > $temp_file_3
#@         echo [sh fgrep -f $temp_file_2 $temp_file_3 | sort | grep -v 'Design.*File.*Path']
#@         file delete $temp_file_3
#@         set ldd_return_val 1
#@     }
#@ 
#@     # Clean up
#@     file delete $temp_file_2
#@ 
#@     set list_duplicate_designs1 $ldd_return_val
#@ }
#@ 
#@ define_proc_attributes list_duplicate_designs     -info " List designs of same names"     -permanent     -define_args {
#@     }
#@ # -- End source /usr/cad/synopsys/synthesis/cur/auxx/syn/scripts/list_duplicate_designs.tcl

#@ 
#@ 
#@ set compile_log_format "  %elap_time %area %wns %tns %drc %endpoint";
#@ 
#@ set compile_top_all_paths "false"
#@ alias compile_inplace_changed_list_file_name                 reoptimize_design_changed_list_file_name
#@ 
#@ #
#@ #  These variables affects compile, report_timing and report_constraints
#@ #  commands.
#@ #
#@ set enable_recovery_removal_arcs  "false"
#@ set timing_report_attributes {dont_touch dont_use map_only size_only ideal_net}
#@ 
#@ #
#@ #       Multibit Variable Group:
#@ #
#@ #       These variables affect the multibit mapping functionality
#@ #
#@ 
#@ set bus_multiple_separator_style  ","
#@ 
#@ #
#@ #       ILM Variable Group:
#@ #
#@ #       These variables affect Interface Logic Model functionality
#@ #
#@ 
#@ set ilm_ignore_percentage 25
#@ 
#@ #
#@ #       Estimator Variable Group:
#@ #
#@ #       These variables affect the designs created by the ESTIMATE command.
#@ #
#@ set estimate_resource_preference  "fast"
#@ alias est_resource_preference estimate_resource_preference
#@ set lbo_lfo_enable_at_pin_count   3
#@ set lbo_cells_in_regions   "false"
#@ 
#@ #     Synthetic Library Group:
#@ #
#@ #       These variable affect synthetic library processing.
#@ #
#@ set cache_dir_chmod_octal   "777"
#@ set cache_file_chmod_octal  "666"
#@ set cache_read   "~"
#@ set cache_read_info  "false"
#@ set cache_write  "~"
#@ set cache_write_info   "false"
#@ set synlib_dont_get_license  {}
#@ set synlib_library_list   {DW01 DW02 DW03 DW04 DW05 DW06 DW07}
#@ set synlib_wait_for_design_license {}
#@ 
#@ #
#@ #       Insert_DFT Variable Group:
#@ #
#@ #set test_default_client_order [list]
#@ set insert_dft_clean_up "true"
#@ set insert_test_design_naming_style  "%s_test_%d"
#@ # /*insert_test_scan_chain_only_one_clock = "false"
#@ # Replace by command line option (star 17215) -- Denis Martin 28-Jan-93*/
#@ set test_clock_port_naming_style  "test_c%s"
#@ set test_scan_clock_a_port_naming_style  "test_sca%s"
#@ set test_scan_clock_b_port_naming_style  "test_scb%s"
#@ set test_scan_clock_port_naming_style   "test_sc%s"
#@ set test_scan_enable_inverted_port_naming_style   "test_sei%s"
#@ set test_scan_enable_port_naming_style   "test_se%s"
#@ set test_scan_in_port_naming_style   "test_si%s%s"
#@ set test_scan_out_port_naming_style  "test_so%s%s"
#@ set test_non_scan_clock_port_naming_style  "test_nsc_%s"
#@ set test_default_min_fault_coverage  95
#@ set test_dedicated_subdesign_scan_outs  "false"
#@ set test_disable_find_best_scan_out  "false"
#@ set test_dont_fix_constraint_violations  "false"
#@ set test_isolate_hier_scan_out  0
#@ set test_mode_port_naming_style  "test_mode%s"
#@ set test_mode_port_inverted_naming_style  "test_mode_i%s"
#@ set compile_dont_use_dedicated_scanout 1
#@ set test_mux_constant_si "false"
#@ 
#@ #
#@ #        Analyze_Scan Variable Group:
#@ #
#@ #     These variables affect the designs created by the PREVIEW_SCAN command.
#@ #
#@ set test_preview_scan_shows_cell_types  "false"
#@ set test_scan_link_so_lockup_key "l"
#@ set test_scan_link_wire_key  "w"
#@ set test_scan_segment_key  "s"
#@ set test_scan_true_key  "t"
#@ 
#@ #
#@ #        bsd Variable Group:
#@ 
#@ #        These variables affect the report generated by the check_bsd command
#@ #        and the BSDLout generated by the write_bsdl command.
#@ #
#@ set test_user_test_data_register_naming_style  "UTDR%d"
#@ 
#@ set test_user_defined_instruction_naming_style  "USER%d"
#@ 
#@ set test_bsdl_default_suffix_name  "bsdl"
#@ 
#@ set test_bsdl_max_line_length  80
#@ 
#@ set test_cc_ir_masked_bits 0
#@ 
#@ set test_cc_ir_value_of_masked_bits 0
#@ 
#@ set test_bsd_allow_tolerable_violations "false" 
#@ set test_bsd_optimize_control_cell "false" 
#@ set test_bsd_control_cell_drive_limit 0
#@ set test_bsd_manufacturer_id 0
#@ set test_bsd_part_number 0
#@ set test_bsd_version_number 0
#@ set bsd_max_in_switching_limit 60000
#@ set bsd_max_out_switching_limit 60000
#@ 
#@ #
#@ #        TestManager Variable Group:
#@ #
#@ #        These variables affect the TestManager methodology.
#@ #
#@ set multi_pass_test_generation  "false"
#@ 
#@ #
#@ #        TestSim Variable Group:
#@ #
#@ #        These variables affect the TestSim behavior.
#@ #
#@ # set testsim_print_stats_file  "true"
#@ 
#@ #      Test DRC Variable Group:
#@ #
#@ #        These variables affect the check_test command.
#@ # 
#@ set test_capture_clock_skew  "small_skew"
#@ set test_allow_clock_reconvergence  "true"
#@ set test_check_port_changes_in_capture  "true"
#@ set test_infer_slave_clock_pulse_after_capture "infer"
#@ 
#@ #
#@ #       Test Variable Group:
#@ #
#@ #       These variables affect the rtldrc, check_test, write_test_protocol
#@ #       and write_test command.
#@ #
#@ set test_default_delay  0.0
#@ set test_default_bidir_delay  0.0
#@ set test_default_strobe  40.0
#@ set test_default_strobe_width  0.0
#@ set test_default_period  100.0
#@ set test_stil_max_line_length 72 
#@ 
#@ #added for B-2008.09-place_opt-004 to disable this option in ICC
#@ 
#@ if { $synopsys_program_name != "icc_shell"} {
#@     set test_write_four_cycle_stil_protocol "false"
#@     set test_protocol_add_cycle "true"
#@     set test_stil_multiclock_capture_procedures "false"
#@     set write_test_new_translation_engine "false"
#@     set test_default_scan_style  "multiplexed_flip_flop"
#@     set test_jump_over_bufs_invs "true"
#@     set test_point_keep_hierarchy "false"
#@     set test_mux_constant_so "false"
#@     set test_use_test_models "false"
#@     set test_stil_netlist_format "db"
#@     group_variable  test  "test_protocol_add_cycle"
#@     group_variable  test  "test_write_four_cycle_stil_protocol"
#@     group_variable  test  "test_stil_multiclock_capture_procedures"
#@     group_variable  test  "test_default_scan_style"
#@     group_variable  preview_scan  "test_jump_over_bufs_invs"
#@     group_variable  insert_dft   "test_point_keep_hierarchy"
#@     group_variable  insert_dft  "test_mux_constant_so"
#@     group_variable  test  "test_stil_netlist_format"
#@ }
#@ set test_rtldrc_latch_check_style "default"
#@ set test_enable_capture_checks "true"
#@ set ctldb_use_old_prot_flow "false"
#@ set test_bsd_default_delay  0.0
#@ set test_bsd_default_bidir_delay  0.0
#@ set test_bsd_default_strobe  95.0
#@ set test_bsd_default_strobe_width  0.0
#@ 
#@ #
#@ #       Write_Test Variable Group:
#@ #
#@ #       These variables affect output of the WRITE_TEST command.
#@ #
#@ set write_test_input_dont_care_value  "X"
#@ set write_test_vector_file_naming_style  "%s_%d.%s"
#@ set write_test_scan_check_file_naming_style   "%s_schk.%s"
#@ set write_test_pattern_set_naming_style  "TC_Syn_%d"
#@ set write_test_max_cycles  0
#@ set write_test_max_scan_patterns  0
#@ # /*retain "tssi_ascii" (equivalent to "tds") for backward compatability */
#@ set write_test_formats   {synopsys tssi_ascii tds verilog vhdl wgl}
#@ set write_test_include_scan_cell_info  "true"
#@ set write_test_round_timing_values "true"
#@ 
#@ 
#@ #
#@ #       Schematic and EDIF and Hdl Variable Groups:
#@ #
#@ #       These variables affect the schematics created by the
#@ #       create_schematic command, define the behavior of the
#@ #       DC system EDIF interface, and are for controlling hdl
#@ #       reading.
#@ #
#@ set bus_dimension_separator_style  {][}
#@ set bus_naming_style  {%s[%d]}
#@ 
#@ 
#@ #
#@ #       Schematic and EDIF Variable Groups:
#@ #
#@ #       These variables affect the schematics created by the
#@ #       create_schematic command and define the behavior of
#@ #       the DC system EDIF interface.
#@ #
#@ set bus_range_separator_style  ":"
#@ 
#@ 
#@ #
#@ # EDIF and Io Variable Groups:
#@ #
#@ # These variables define the behavior of the DC system EDIF interface and
#@ # define the behavior of the DC system interfaces, i.e. LSI, Mentor, TDL, SGE,# etc.
#@ 
#@ set bus_inference_descending_sort  "true"
#@ set bus_inference_style  ""
#@ set write_name_nets_same_as_ports  "false"
#@ #
#@ #       Schematic Variable Group:
#@ #
#@ #       These variables affect the schematics created by the
#@ #       create_schematic command.
#@ #
#@ set font_library  "1_25.font"
#@ set generic_symbol_library  "generic.sdb"
#@ 
#@ #
#@ #       Io Variable Group:
#@ #
#@ #       These variables define the behavior of the DC system
#@ #       interfaces, i.e. LSI, Mentor, TDL, SGE, etc.
#@ #
#@ #set db2sge_output_directory  ""
#@ #set db2sge_scale  "2"
#@ #set db2sge_overwrite   "true"
#@ #set db2sge_display_symbol_names  "false"
#@ 
#@ 
#@ #set db2sge_display_pin_names  "false"
#@ #set db2sge_display_instance_names   "false"
#@ #set db2sge_use_bustaps   "false"
#@ #set db2sge_use_compound_names   "true"
#@ #set db2sge_bit_type   "std_logic"
#@ #set db2sge_bit_vector_type   "std_logic_vector"
#@ #set db2sge_one_name   "'1'"
#@ #set db2sge_zero_name  "'0'"
#@ #set db2sge_unknown_name  "'X'"
#@ #set db2sge_target_xp  "false"
#@ #set db2sge_tcf_package_file  "synopsys_tcf.vhd"
#@ #set db2sge_use_lib_section  ""
#@ #set db2sge_script  ""
#@ #set db2sge_command  ""
#@ 
#@ # set equationout_and_sign  "*"
#@ # set equationout_or_sign  "+"
#@ # set equationout_postfix_negation  "true"
#@ 
#@ # # [wjchen] 2006/08/14: The following variables are obsoleted for DC simpilification.
#@ #set lsiin_net_name_prefix  "NET_"
#@ #set lsiout_inverter_cell  ""
#@ #set lsiout_upcase  "true"
#@ 
#@ #set mentor_bidirect_value  "INOUT"
#@ #set mentor_do_path  ""
#@ #set mentor_input_output_property_name  "PINTYPE"
#@ #set mentor_input_value  "IN"
#@ #set mentor_logic_one_value  "1SF"
#@ #set mentor_logic_zero_one_property_name  "INIT"
#@ #set mentor_logic_zero_value  "0SF"
#@ #set mentor_output_value  "OUT"
#@ #set mentor_primitive_property_name  "PRIMITIVE"
#@ #set mentor_primitive_property_value  "MODULE"
#@ #set mentor_reference_property_name  "COMP"
#@ #set mentor_search_path   ""
#@ #set mentor_write_symbols   "true"
#@ 
#@ ## [wjchen] 0606_simp
#@ #set pla_read_create_flip_flop   "false"
#@ #set tdlout_upcase   "true"
#@ 
#@ # # [wjchen] 2006/08/14: The following4 variables are obsoleted for DC simpilification.
#@ # set xnfout_constraints_per_endpoint   "50"
#@ # set xnfout_default_time_constraints   true
#@ # set xnfout_clock_attribute_style   "CLK_ONLY"
#@ # set xnfout_library_version  ""
#@ 
#@ # # [wjchen] 2006/08/11: The following 8 variables are obsoleted for DC simpilification.
#@ # set xnfin_family   "4000"
#@ # set xnfin_ignore_pins   "GTS GSR GR"
#@ # set xnfin_dff_reset_pin_name             "RD"
#@ # set xnfin_dff_set_pin_name               "SD"
#@ # set xnfin_dff_clock_enable_pin_name      "CE"
#@ # set xnfin_dff_data_pin_name              "D"
#@ # set xnfin_dff_clock_pin_name             "C"
#@ # set xnfin_dff_q_pin_name                 "Q"
#@ # 
#@ 
#@ #
#@ #       EDIF Variable Group:
#@ #
#@ #       These variables define the behavior of the DC system
#@ #       EDIF interface.
#@ #
#@ 
#@ ##[wjchen] 2006/08/24
#@ 
#@ # set bus_extraction_style   {%s[%d:%d]}
#@ 
#@ ##[wjchen] 2006/08/24
#@ #set edifin_autoconnect_offpageconnectors   "false"
#@ #set edifin_autoconnect_ports   "false"
#@ #set edifin_dc_script_flag   ""
#@ #set edifin_delete_empty_cells   "true"
#@ #set edifin_delete_ripper_cells   "true"
#@ #set edifin_ground_net_name   ""
#@ #set edifin_ground_net_property_name   ""
#@ #set edifin_ground_net_property_value   ""
#@ #set edifin_ground_port_name   ""
#@ #set edifin_instance_property_name    ""
#@ #set edifin_portinstance_disabled_property_name   ""
#@ #set edifin_portinstance_disabled_property_value   ""
#@ #set edifin_portinstance_property_name   ""
#@ #set edifin_power_net_name  ""
#@ #set edifin_power_net_property_name  ""
#@ #set edifin_power_net_property_value  ""
#@ #set edifin_power_port_name  ""
#@ #set edifin_use_identifier_in_rename  "false"
#@ #set edifin_view_identifier_property_name  ""
#@ #set edifin_lib_logic_1_symbol  ""
#@ #set edifin_lib_logic_0_symbol  ""
#@ #set edifin_lib_in_port_symbol  ""
#@ #set edifin_lib_out_port_symbol  ""
#@ #set edifin_lib_inout_port_symbol  ""
#@ #set edifin_lib_in_osc_symbol  ""
#@ #set edifin_lib_out_osc_symbol  ""
#@ #set edifin_lib_inout_osc_symbol  ""
#@ #set edifin_lib_mentor_netcon_symbol  ""
#@ #set edifin_lib_ripper_bits_property  ""
#@ #set edifin_lib_ripper_bus_end  ""
#@ #set edifin_lib_ripper_cell_name  ""
#@ #set edifin_lib_ripper_view_name  ""
#@ #set edifin_lib_route_grid  1024
#@ #set edifin_lib_templates  {}
#@ #set edifout_dc_script_flag  ""
#@ #set edifout_design_name  "Synopsys_edif"
#@ #set edifout_designs_library_name  "DESIGNS"
#@ #set edifout_display_instance_names  "false"
#@ #set edifout_display_net_names  "false"
#@ #set edifout_external  "true"
#@ #set edifout_external_graphic_view_name  "Graphic_representation"
#@ #set edifout_external_netlist_view_name  "Netlist_representation"
#@ #set edifout_external_schematic_view_name  "Schematic_representation"
#@ #set edifout_ground_name  "logic_0"
#@ #set edifout_ground_net_name  ""
#@ #set edifout_ground_net_property_name  ""
#@ #set edifout_ground_net_property_value  ""
#@ #set edifout_ground_pin_name  "logic_0_pin"
#@ #set edifout_ground_port_name  "GND"
#@ #set edifout_instance_property_name   ""
#@ #set edifout_instantiate_ports  "false"
#@ #set edifout_library_graphic_view_name  "Graphic_representation"
#@ #set edifout_library_netlist_view_name  "Netlist_representation"
#@ #set edifout_library_schematic_view_name  "Schematic_representation"
#@ #set edifout_merge_libraries  "false"
#@ #set edifout_multidimension_arrays  "false"
#@ #set edifout_name_oscs_different_from_ports  "false"
#@ #set edifout_name_rippers_same_as_wires  "false"
#@ #set edifout_netlist_only   "false"
#@ #set edifout_no_array   "false"
#@ #set edifout_numerical_array_members   "false"
#@ #set edifout_pin_direction_in_value   ""
#@ #set edifout_pin_direction_inout_value   ""
#@ #set edifout_pin_direction_out_value   ""
#@ #set edifout_pin_direction_property_name   ""
#@ #set edifout_pin_name_property_name   ""
#@ #set edifout_portinstance_disabled_property_name    ""
#@ #set edifout_portinstance_disabled_property_value    ""
#@ #set edifout_portinstance_property_name    ""
#@ #set edifout_power_and_ground_representation   "cell"
#@ #set edifout_power_name    "logic_1"
#@ #set edifout_power_net_name   ""
#@ #set edifout_power_net_property_name   ""
#@ #set edifout_power_net_property_value   ""
#@ #set edifout_power_pin_name    "logic_1_pin"
#@ #set edifout_power_port_name    "VDD"
#@ #set edifout_skip_port_implementations   "false"
#@ #set edifout_target_system   ""
#@ #set edifout_top_level_symbol   "true"
#@ #set edifout_translate_origin   ""
#@ #set edifout_unused_property_value   ""
#@ #set edifout_write_attributes   "false"
#@ #set edifout_write_constraints   "false"
#@ #set edifout_write_properties_list   {}
#@ #set read_name_mapping_nowarn_libraries   {}
#@ #set write_name_mapping_nowarn_libraries    {}
#@ 
#@ #
#@ #       Hdl and Vhdlio Variable Groups:
#@ #
#@ #       These variables are for controlling hdl reading, writing,
#@ #       and optimizing.
#@ #
#@ set hdlin_auto_save_templates		"FALSE"
#@ set hdlin_generate_naming_style   	"%s_%d"
#@ set hdlin_generate_separator_style	"_"
#@ set hdlin_ignore_textio_constructs      "TRUE"
#@ set hdlin_infer_function_local_latches	"FALSE"
#@ set hdlin_keep_signal_name		"all_driving"
#@ set hdlin_module_arch_name_splitting	"FALSE"
#@ set hdlin_preserve_sequential           "none"
#@ set hdlin_presto_net_name_prefix	"N"
#@ set hdlin_presto_cell_name_prefix	"C"
#@ set hdlin_sv_ieee_assignment_patterns   1
#@ set hdlin_prohibit_nontri_multiple_drivers  "TRUE"
#@ set hdlin_elab_errors_deep		"FALSE"
#@ set hdlin_mux_size_min			2
#@ set hdlin_subprogram_default_values	"FALSE"
#@ set hdlin_field_naming_style		"" 
#@ set hdlin_upcase_names            	"FALSE"
#@ set hdlin_vhdl_87                 	"FALSE"
#@ set hdlin_vrlg_std                	2001
#@ set hdlin_sverilog_std                	2005
#@ set hdlin_while_loop_iterations   	1024
#@ set hdlin_reporting_level        	"basic"
#@ 
#@ set bus_minus_style   "-%d"
#@ set hdlin_latch_always_async_set_reset   FALSE
#@ set hdlin_ff_always_sync_set_reset   FALSE
#@ set hdlin_ff_always_async_set_reset   TRUE
#@ set hdlin_check_input_netlist   FALSE
#@ set hdlin_check_no_latch   FALSE
#@ set hdlin_infer_mux   "default"
#@ set hdlin_mux_oversize_ratio   100
#@ set hdlin_mux_size_limit   32
#@ set hdlin_mux_size_only    1
#@ set hdlin_infer_multibit   "default_none"
#@ set hdlin_vhdl93_concat	"true"
#@ set hdlin_enable_rtldrc_info "false"
#@ set hdlin_shorten_long_module_name "false"
#@ set hdlin_module_name_limit 256
#@ set hdlin_enable_assertions "FALSE"
#@ set hdlin_enable_configurations "FALSE"
#@ set hdlin_sv_tokens "FALSE"
#@ set hdlin_sv_packages "enable"
#@ set hdlin_optimize_pla_effort 2
#@ set hdlin_enable_elaborate_ref_linking "FALSE"
#@ set hdl_preferred_license   ""
#@ set hdl_keep_licenses   "true"
#@ set hlo_resource_allocation   "constraint_driven"
#@ set sdfout_top_instance_name   ""
#@ set sdfout_time_scale   1.0
#@ set sdfout_min_rise_net_delay   0.
#@ set sdfout_min_fall_net_delay   0.
#@ set sdfout_min_rise_cell_delay   0.
#@ set sdfout_min_fall_cell_delay   0.
#@ set sdfout_write_to_output   "false"
#@ set sdfout_allow_non_positive_constraints   "false"
#@ set sdfin_top_instance_name   ""
#@ set sdfin_min_rise_net_delay   0.
#@ set sdfin_min_fall_net_delay   0. 
#@ set sdfin_min_rise_cell_delay   0.
#@ set sdfin_min_fall_cell_delay   0.
#@ set sdfin_rise_net_delay_type   "maximum"
#@ set sdfin_fall_net_delay_type   "maximum"
#@ set sdfin_rise_cell_delay_type   "maximum"
#@ set sdfin_fall_cell_delay_type   "maximum"
#@ set site_info_file ${synopsys_root}/admin/license/site_info
#@ if { [string compare $dc_shell_mode "tcl"] == 0 } {
#@   alias site_info sh cat $site_info_file
#@ } else {
#@   alias site_info "sh cat site_info_file"
#@ }
#@ set template_naming_style   "%s_%p"
#@ set template_parameter_style   "%s%d"
#@ set template_separator_style   "_"
#@ set verilogout_equation "false" 
#@ set verilogout_ignore_case   "false"
#@ set verilogout_no_tri   "false"
#@ set verilogout_single_bit   "false"
#@ set verilogout_higher_designs_first   "FALSE"
#@ # set verilogout_levelize   "FALSE"
#@ set verilogout_include_files   {}
#@ set verilogout_unconnected_prefix   "SYNOPSYS_UNCONNECTED_"
#@ set verilogout_show_unconnected_pins   "FALSE"
#@ set verilogout_no_negative_index   "FALSE"
#@ #set enable_2003.03_verilog_reader TRUE 
#@ # set vhdlout_architecture_name   "SYN_%a_%u"
#@ set vhdlout_bit_type   "std_logic"
#@ # set vhdlout_bit_type_resolved   "TRUE"
#@ set vhdlout_bit_vector_type   "std_logic_vector"
#@ # set vhdlout_conversion_functions   {}
#@ # set vhdlout_dont_write_types   "FALSE"
#@ set vhdlout_equations   "FALSE"
#@ set vhdlout_one_name   "'1'"
#@ set vhdlout_package_naming_style   "CONV_PACK_%d"
#@ set vhdlout_preserve_hierarchical_types   "VECTOR"
#@ set vhdlout_separate_scan_in   "FALSE"
#@ set vhdlout_single_bit   "USER"
#@ set vhdlout_target_simulator   ""
#@ set vhdlout_three_state_name   "'Z'"
#@ set vhdlout_three_state_res_func   ""
#@ # set vhdlout_time_scale   1.0
#@ set vhdlout_top_configuration_arch_name   "A"
#@ set vhdlout_top_configuration_entity_name   "E"
#@ set vhdlout_top_configuration_name  "CFG_TB_E"
#@ set vhdlout_unknown_name   "'X'"
#@ set vhdlout_upcase   "FALSE"
#@ set vhdlout_use_packages   {IEEE.std_logic_1164}
#@ set vhdlout_wired_and_res_func   ""
#@ set vhdlout_wired_or_res_func   ""
#@ set vhdlout_write_architecture   "TRUE"
#@ set vhdlout_write_components   "TRUE"
#@ set vhdlout_write_entity   "TRUE"
#@ set vhdlout_write_top_configuration   "FALSE"
#@ # set vhdlout_synthesis_off   "TRUE"
#@ set vhdlout_zero_name   "'0'"
#@ #set vhdlout_levelize   "FALSE"
#@ set vhdlout_dont_create_dummy_nets   "FALSE"
#@ set vhdlout_follow_vector_direction   "TRUE"
#@ 
#@ 
#@ # vhdl netlist reader variables 
#@ set enable_vhdl_netlist_reader "FALSE"
#@ 
#@ # variables pertaining to VHDL library generation 
#@ set vhdllib_timing_mesg   "true"
#@ set vhdllib_timing_xgen   "false"
#@ set vhdllib_timing_checks   "true"
#@ set vhdllib_negative_constraint   "false"
#@ set vhdllib_glitch_handle   "true"
#@ set vhdllib_pulse_handle   "use_vhdllib_glitch_handle"
#@ # /*vhdllib_architecture = {FTBM, UDSM, FTSM, FTGS, VITAL}; */
#@ set vhdllib_architecture   {VITAL}
#@ set vhdllib_tb_compare   0
#@ set vhdllib_tb_x_eq_dontcare   FALSE
#@ set vhdllib_logic_system   "ieee-1164"
#@ set vhdllib_logical_name   ""
#@ 
#@ # variables pertaining to technology library processing 
#@ set read_db_lib_warnings   FALSE
#@ set read_translate_msff    TRUE
#@ set libgen_max_differences   -1
#@ 
#@ #
#@ # Gui Variable Group
#@ #  used for design_vision and psyn_gui
#@ #
#@ set gui_auto_start 0
#@ set gui_start_option_no_windows 0
#@ group_variable  gui_variables  "gui_auto_start" 
#@ group_variable  gui_variables  "gui_start_option_no_windows"
#@ 
#@ #
#@ # If you like emacs, uncomment the next line 
#@ # set text_editor_command  "emacs -fn 8x13 %s &" ; 
#@ 
#@ # You can delete pairs from this list, but you can't add new ones
#@ # unless you also update the UIL files.  So, customers can not add
#@ # dialogs to this list, only Synopsys can do that.
#@ #
#@ set view_independent_dialogs   { "test_report"    " Test Reports "                              "report_print"   " Report "                              "report_options" " Report Options "                              "report_win"     " Report Output "                              "manual_page"    " Manual Page " } 
#@ 
#@ # if color Silicon Graphics workstation 
#@ if { [info exists x11_vendor_string] && [info exists x11_is_color]} {
#@   if {  $x11_vendor_string == "Silicon" && $x11_is_color == "true" } {
#@     set x11_set_cursor_foreground "magenta" 
#@     set view_use_small_cursor "true"
#@     set view_set_selecting_color "white"
#@   } 
#@ } 
#@ 
#@ # if running on an Apollo machine 
#@ set found_x11_vendor_string_apollo 0
#@ set found_arch_apollo 0
#@ if { [info exists x11_vendor_string]} {
#@   if { $x11_vendor_string == "Apollo "} {
#@     set found_x11_vendor_string_apollo 1
#@   }
#@ }
#@ if { [info exists arch]} {
#@   if { $arch == "apollo"} {
#@     set found_arch_apollo 1
#@   }
#@ }
#@ if { $found_x11_vendor_string_apollo == 1 || $found_arch_apollo == 1} {
#@   set enable_page_mode  "false"
#@ } else {
#@   set enable_page_mode  "true"
#@ }
#@ 
#@ # don't work around this bug on the Apollo 
#@ if { $found_x11_vendor_string_apollo == 1} {
#@   set view_extend_thick_lines "false"
#@ } else {
#@   set view_extend_thick_lines "true" 
#@ }
#@ 
#@ #
#@ #        Suffix Variable Group:
#@ #
#@ #        Suffixes recognized by the Design Analyzer menu in file choices
#@ #
#@ if { $synopsys_program_name == "design_vision" || $synopsys_program_name == "psyn_gui" } { 
#@   # For star 93040 do NOT include NET in list, 108991 : pdb suffix added
#@   set view_read_file_suffix    {db gdb sdb pdb edif eqn fnc lsi mif pla st tdl v vhd vhdl xnf}
#@ } else {
#@   set view_read_file_suffix    {db gdb sdb edif eqn fnc lsi mif NET pla st tdl v vhd vhdl xnf} 
#@ }
#@ 
#@ set view_analyze_file_suffix    {v vhd vhdl} 
#@ set view_write_file_suffix   {gdb db sdb do edif eqn fnc lsi NET neted pla st tdl v vhd vhdl xnf} 
#@ set view_execute_script_suffix   {.script .scr .dcs .dcv .dc .con} 
#@ set view_arch_types   {sparcOS5 hpux10 rs6000 sgimips} 
#@ 
#@ #
#@ #        links_to_layout Variable Group:
#@ #
#@ #        These variables affect the read_timing, write_timing
#@ #        set_annotated_delay, compile, create_wire_load and reoptimize_design
#@ #        commands.
#@ #
#@ set rtl_load_resistance_factor 0.0
#@ set auto_wire_load_selection   "true" 
#@ set compile_create_wire_load_table   "false" 
#@ 
#@ #      power Variable Group:
#@ #
#@ #      These variables affect the behavior of power optimization and analysis.
#@ #
#@ 
#@ set power_keep_license_after_power_commands   "false"
#@ set power_rtl_saif_file                       "power_rtl.saif"
#@ set power_sdpd_saif_file                      "power_sdpd.saif"
#@ set power_preserve_rtl_hier_names             "false"
#@ set power_do_not_size_icg_cells               "true"
#@ set power_hdlc_do_not_split_cg_cells          "false"
#@ set power_cg_flatten                          "false"
#@ set power_opto_extra_high_dynamic_power_effort "false"
#@ set power_default_static_probability          0.5
#@ set power_default_toggle_rate                 0.1
#@ set power_default_toggle_rate_type            "fastest_clock"
#@ set power_model_preference                    "nlpm"
#@ set power_sa_propagation_effort               "low"
#@ set power_sa_propagation_verbose              "false"
#@ set power_fix_sdpd_annotation                 "true"
#@ set power_fix_sdpd_annotation_verbose         "false"
#@ set power_sdpd_message_tolerance              0.00001
#@ set do_operand_isolation                      "false"
#@ set power_cg_module_naming_style              ""
#@ set power_cg_cell_naming_style                ""
#@ set power_cg_gated_clock_net_naming_style     ""
#@ set power_rclock_use_asynch_inputs            "false"
#@ set power_rclock_inputs_use_clocks_fanout     "true"
#@ set power_rclock_unrelated_use_fastest        "true"
#@ set power_lib2saif_rise_fall_pd               "false"
#@ set power_min_internal_power_threshold        ""
#@ 
#@ #
#@ # Control FSM auto-inferring
#@ #
#@ set fsm_auto_inferring                        "false"
#@ 
#@ # SystemC related variables
#@ set systemcout_levelize "true"
#@ set systemcout_debug_mode "false"
#@ 
#@ # ACS Variables
#@ if { [info exists acs_work_dir] } {
#@   set acs_area_report_suffix                  "area"
#@   set acs_autopart_max_area                   "0.0"
#@   set acs_autopart_max_percent                "0.0"
#@   set acs_budgeted_cstr_suffix                "con"
#@   set acs_compile_script_suffix               "autoscr"
#@   set acs_constraint_file_suffix              "con"
#@   set acs_cstr_report_suffix                  "cstr"
#@   set acs_db_suffix                           "db"
#@   set acs_dc_exec                             ""
#@   set acs_default_pass_name                   "pass"
#@   set acs_exclude_extensions                  {}
#@   set acs_exclude_list                        [list $synopsys_root]
#@   set acs_global_user_compile_strategy_script "default"
#@   set acs_hdl_verilog_define_list             {}
#@   set acs_hdl_source                          {}
#@   set acs_lic_wait                              0
#@   set acs_log_file_suffix                     "log"
#@   set acs_make_args                           "set acs_make_args" 
#@   set acs_make_exec                           "gmake"
#@   set acs_makefile_name                       "Makefile"
#@   set acs_num_parallel_jobs                     1
#@   set acs_override_report_suffix              "report"
#@   set acs_override_script_suffix              "scr"
#@   set acs_qor_report_suffix                   "qor"
#@   set acs_timing_report_suffix                "tim"
#@   set acs_use_autopartition                   "false"
#@   set acs_use_default_delays                  "false"
#@   set acs_user_budgeting_script               "budget.scr"
#@   set acs_user_compile_strategy_script_suffix "compile"
#@   set acs_verilog_extensions                  {.v}
#@   set acs_vhdl_extensions                     {.vhd}
#@   set acs_work_dir                            [pwd]
#@   set check_error_list [list         CMD-004 CMD-006 CMD-007 CMD-008 CMD-009 CMD-010 CMD-011 CMD-012         CMD-014 CMD-015 CMD-016 CMD-019 CMD-026 CMD-031 CMD-037         DB-1         DCSH-11         DES-001 	ACS-193         FILE-1 FILE-2 FILE-3 FILE-4         LINK-7 LINT-7 LINT-20 LNK-023         OPT-100 OPT-101 OPT-102 OPT-114 OPT-124 OPT-127 OPT-128 OPT-155 	OPT-157 OPT-181 OPT-462         UI-11 UI-14 UI-15 UI-16 UI-17 UI-19 UI-20 UI-21 UI-22 UI-23 UI-40         UI-41          UID-4 UID-6 UID-7 UID-8 UID-9 UID-13 UID-14 UID-15 UID-19 UID-20         UID-25 UID-27 UID-28 UID-29 UID-30 UID-32 UID-58 UID-87 UID-103         UID-109 UID-270  UID-272 UID-403 UID-440 UID-444          UIO-2 UIO-3 UIO-4 UIO-25 UIO-65 UIO-66 UIO-75 UIO-94 UIO-95         EQN-6 EQN-11 EQN-15 EQN-16 EQN-18 EQN-20       ]
#@   set ilm_preserve_core_constraints                       "false"
#@ }
#@ 
#@ #
#@ #     eco variable group
#@ # 
#@ #     These variables affect ECO Compiler functionality
#@ #
#@ #
#@ set eco_align_design_verbose            "false"
#@ set eco_allow_register_type_difference  "false"
#@ set eco_connect_resource_cell_inputs    "true"
#@ set eco_correspondence_analysis_verbose "false"
#@ set eco_directives_verbose              "false"
#@ set eco_implement_effort_level          "low"
#@ set eco_instance_name_prefix            "eco_"
#@ set eco_recycle_verbose                 "true"
#@ set eco_remap_register_verbose          "false"
#@ set eco_reuse_verbose                   "false"
#@ 
#@ #
#@ #        DesignTime Variable Group
#@ #
#@ #        The variables which affect the DesignTime timing engine
#@ #
#@ 
#@ set case_analysis_log_file ""
#@ set case_analysis_sequential_propagate "false"
#@ set case_analysis_with_logic_constants "false"
#@ set create_clock_no_input_delay "false"
#@ set disable_auto_time_borrow "false"
#@ set disable_case_analysis "false"
#@ set disable_conditional_mode_analysis "false"
#@ set disable_library_transition_degradation "false"
#@ set dont_bind_unused_pins_to_logic_constant "false"
#@ set enable_slew_degradation "true"
#@ set high_fanout_net_pin_capacitance 1.000000
#@ set high_fanout_net_threshold 1000
#@ set lib_thresholds_per_lib "true"
#@ set rc_adjust_rd_when_less_than_rnet "true"
#@ set rc_ceff_delay_min_diff_ps 0.250000
#@ set rc_degrade_min_slew_when_rd_less_than_rnet "false"
#@ set rc_driver_model_max_error_pct 0.160000
#@ set rc_filter_rd_less_than_rnet "true"
#@ set rc_input_threshold_pct_fall 50.000000
#@ set rc_input_threshold_pct_rise 50.000000
#@ set rc_output_threshold_pct_fall 50.000000
#@ set rc_output_threshold_pct_rise 50.000000
#@ set rc_rd_less_than_rnet_threshold 0.450000
#@ set rc_slew_derate_from_library 1.000000
#@ set rc_slew_lower_threshold_pct_fall 20.000000
#@ set rc_slew_lower_threshold_pct_rise 20.000000
#@ set rc_slew_upper_threshold_pct_fall 80.000000
#@ set rc_slew_upper_threshold_pct_rise 80.000000
#@ set timing_disable_cond_default_arcs "false"
#@ set timing_enable_multiple_clocks_per_reg "false"
#@ set timing_report_attributes {dont_touch dont_use map_only size_only ideal_net}
#@ set timing_self_loops_no_skew "false"
#@ set when_analysis_permitted "true"
#@ set when_analysis_without_case_analysis "false"
#@ 
#@ 
#@ #
#@ #        Variable Group Definitions:
#@ #
#@ #        The group_variable() command groups variables for display
#@ #        in the "File/Defaults" dialog and defines groups of variables
#@ #        for the list() command.
#@ #
#@ 
#@ set enable_instances_in_report_net   "true"
#@ # Set report options env variables
#@ set view_report_interactive     "true"
#@ set view_report_output2file     "false"
#@ set view_report_append          "true"
#@ 
#@ if { $synopsys_program_name != "ptxr" } {
#@ 
#@   group_variable  report_variables  "enable_instances_in_report_net" 
#@   group_variable  report_variables  "view_report_interactive"
#@   group_variable  report_variables  "view_report_output2file"
#@   group_variable  report_variables  "view_report_append"
#@ 
#@   # "links_to_layout" variables are used by multiple commands 
#@   # auto_wire_load_selection is also in the "compile" variable group. 
#@   group_variable  links_to_layout  "auto_wire_load_selection" 
#@ 
#@   # variables starting with "compile" are also in the compile variable group 
#@   group_variable  links_to_layout  "compile_dont_touch_annotated_cell_during_inplace_opt" 
#@ 
#@   group_variable  links_to_layout  "compile_update_annotated_delays_during_inplace_opt" 
#@   group_variable  links_to_layout  "compile_create_wire_load_table" 
#@ 
#@   group_variable  links_to_layout  "reoptimize_design_changed_list_file_name" 
#@   group_variable  links_to_layout  "sdfout_allow_non_positive_constraints" 
#@ 
#@ }	;# $synopsys_program_name != "ptxr"
#@ 
#@ #
#@ # to find the XErrorDB and XKeySymDB for X11 file 
#@ set motif_files ${synopsys_root}/admin/setup
#@ # set filename for logging input file 
#@ set filename_log_file   "filenames.log"  
#@ # whether to delete the filename log after the normal exits 
#@ set exit_delete_filename_log_file   "true"
#@ 
#@ # executable to fire off RTLA/BCV 
#@ set xterm_executable   "xterm"
#@ 
#@ if { $synopsys_program_name != "ptxr" } {
#@ 
#@   # "system" variables are used by multiple commands 
#@   group_variable  system  auto_link_disable 
#@   group_variable  system  auto_link_options 
#@   group_variable  system  command_log_file 
#@   group_variable  system  company  
#@   group_variable  system  compatibility_version 
#@ 
#@   if { [string compare $dc_shell_mode "default"] == 0 } {
#@     group_variable  system  "current_design"  
#@     group_variable  system  "current_instance" 
#@     group_variable  system  "dc_shell_status"  
#@   } else {
#@     set current_design   ""
#@     set current_instance ""
#@     group_variable  system  "current_design"  
#@     group_variable  system  "current_instance" 
#@   }
#@ 
#@   group_variable  system  "designer"  
#@   group_variable  system  "echo_include_commands"  
#@   group_variable  system  "enable_page_mode"  
#@   group_variable  system  "change_names_update_inst_tree"  
#@   group_variable  system  "change_names_dont_change_bus_members"  
#@   group_variable  system  "default_name_rules"  
#@   group_variable  system  "verbose_messages" 
#@   group_variable  system  "link_library"  
#@   group_variable  system  "link_force_case"  
#@   group_variable  system  "search_path"  
#@   group_variable  system  "synthetic_library"  
#@   group_variable  system  "target_library"  
#@   group_variable  system  "uniquify_naming_style"  
#@   group_variable  system  "suppress_errors"  
#@   group_variable  system  "find_converts_name_lists" 
#@   group_variable  system  "filename_log_file" 
#@   group_variable  system  "exit_delete_filename_log_file" 
#@   group_variable  system  "syntax_check_status" 
#@   group_variable  system  "context_check_status" 
#@ 
#@   #/* "compile" variables are used by the compile command */
#@   group_variable  compile  "compile_assume_fully_decoded_three_state_busses"  
#@   group_variable  compile  "compile_no_new_cells_at_top_level"  
#@   group_variable  compile  "compile_dont_touch_annotated_cell_during_inplace_opt"
#@   group_variable  compile  "reoptimize_design_changed_list_file_name" 
#@   group_variable  compile  "compile_create_wire_load_table" 
#@   group_variable  compile  "compile_update_annotated_delays_during_inplace_opt"
#@   group_variable  compile  "compile_instance_name_prefix"  
#@   group_variable  compile  "compile_instance_name_suffix"  
#@   group_variable  compile  "compile_negative_logic_methodology"  
#@   group_variable  compile  "compile_disable_hierarchical_inverter_opt" 
#@ 
#@   group_variable  compile  "port_complement_naming_style"  
#@   group_variable  compile  "auto_wire_load_selection"  
#@   group_variable  compile  "rtl_load_resistance_factor"
#@   group_variable  compile  "compile_implementation_selection"  
#@   group_variable  compile  "compile_use_fast_delay_mode"  
#@   group_variable  compile  "compile_use_low_timing_effort"  
#@   group_variable  compile  "compile_fix_cell_degradation"  
#@   group_variable  compile  "compile_preserve_subdesign_interfaces" 
#@   group_variable  compile  "compile_delete_unloaded_sequential_cells" 
#@   group_variable  compile  "enable_recovery_removal_arcs" 
#@   group_variable  compile  "compile_checkpoint_phases"
#@   group_variable  compile  "compile_cpu_limit"
#@   group_variable  compile  "compile_top_all_paths"  
#@   group_variable  compile  "compile_top_all_paths"
#@   group_variable  compile  "compile_top_acs_partition"
#@   group_variable  compile  "default_port_connection_class"
#@   group_variable  compile  "compile_retime_license_behavior"
#@   group_variable  compile  "dont_touch_nets_with_size_only_cells"
#@   group_variable  compile  "compile_seqmap_no_scan_cell"
#@ 
#@   if { $synopsys_program_name == "dc_shell" && [shell_is_in_topographical_mode] } {
#@     group_variable  compile  "dct_prioritize_area_correlation"
#@   }
#@ 
#@   # "multibit" variables are used by the the multibit mapping functionality 
#@ 
#@   group_variable  multibit  "bus_multiple_separator_style" 
#@ 
#@   # "ilm" variables are used by Interface Logic Model functionality 
#@ 
#@   group_variable  ilm  "ilm_ignore_percentage" 
#@ 
#@   # "estimate" variables are used by the estimate command 
#@   # The estimate command also recognizes the "compile" variables. 
#@   group_variable  estimate  "estimate_resource_preference"  
#@ 
#@   # "synthetic_library" variables 
#@   group_variable  synlib  "cache_dir_chmod_octal"  
#@   group_variable  synlib  "cache_file_chmod_octal"  
#@   group_variable  synlib  "cache_read"  
#@   group_variable  synlib  "cache_read_info"  
#@   group_variable  synlib  "cache_write"  
#@   group_variable  synlib  "cache_write_info"  
#@   group_variable  synlib  "synlib_dont_get_license"  
#@   group_variable  synlib  "synlib_wait_for_design_license"
#@   group_variable  synlib  "synthetic_library"
#@ 
#@   # "insert_dft" variables are used by the insert_dft and preview_dft commands
#@   #group_variable insert_dft   "test_default_client_order"
#@   group_variable  insert_dft   "insert_dft_clean_up"
#@   group_variable  insert_dft  "insert_test_design_naming_style"  
#@   group_variable  insert_dft  "test_clock_port_naming_style"  
#@   group_variable  insert_dft  "test_default_min_fault_coverage" 
#@   group_variable  insert_dft  "test_scan_clock_a_port_naming_style"  
#@   group_variable  insert_dft  "test_scan_clock_b_port_naming_style"  
#@   group_variable  insert_dft  "test_scan_clock_port_naming_style"  
#@   group_variable  insert_dft  "test_scan_enable_inverted_port_naming_style"  
#@   group_variable  insert_dft  "test_scan_enable_port_naming_style"  
#@   group_variable  insert_dft  "test_scan_in_port_naming_style"  
#@   group_variable  insert_dft  "test_scan_out_port_naming_style"  
#@   group_variable  insert_dft  "test_non_scan_clock_port_naming_style" 
#@   group_variable  insert_dft  "test_dedicated_subdesign_scan_outs" 
#@   group_variable  insert_dft  "test_disable_find_best_scan_out" 
#@   group_variable  insert_dft  "test_dont_fix_constraint_violations" 
#@   group_variable  insert_dft  "test_isolate_hier_scan_out" 
#@   group_variable  insert_dft  "test_mode_port_naming_style" 
#@   group_variable  insert_dft  "test_mode_port_inverted_naming_style" 
#@   group_variable  insert_dft  "compile_dont_use_dedicated_scanout" 
#@   group_variable  insert_dft  "test_mux_constant_si" 
#@ 
#@   # "preview_scan" variables are used by the preview_scan command 
#@   group_variable preview_scan "test_preview_scan_shows_cell_types" 
#@   group_variable  preview_scan  "test_scan_link_so_lockup_key" 
#@   group_variable  preview_scan  "test_scan_link_wire_key" 
#@   group_variable  preview_scan  "test_scan_segment_key" 
#@   group_variable  preview_scan  "test_scan_true_key" 
#@ 
#@   # "bsd" variables are used by the check_bsd and write_bsdl commands 
#@   group_variable  bsd  "test_user_test_data_register_naming_style" 
#@   group_variable  bsd  "test_user_defined_instruction_naming_style" 
#@   group_variable  bsd  "test_bsdl_default_suffix_name" 
#@   group_variable  bsd  "test_bsdl_max_line_length" 
#@   group_variable  bsd  "test_cc_ir_masked_bits" 
#@   group_variable  bsd  "test_cc_ir_value_of_masked_bits" 
#@ 
#@   group_variable  bsd  "test_bsd_allow_tolerable_violations" 
#@   group_variable  bsd  "test_bsd_optimize_control_cell" 
#@   group_variable  bsd  "test_bsd_control_cell_drive_limit" 
#@   group_variable  bsd  "test_bsd_manufacturer_id" 
#@   group_variable  bsd  "test_bsd_part_number" 
#@   group_variable  bsd  "test_bsd_version_number" 
#@   group_variable  bsd  "bsd_max_in_switching_limit" 
#@   group_variable  bsd  "bsd_max_out_switching_limit" 
#@ 
#@   # testmanager variables 
#@   group_variable  testmanager  "multi_pass_test_generation"  
#@ 
#@   # "testsim" variables 
#@   # group_variable  testsim  "testsim_print_stats_file"  
#@ 
#@   # "test" variables 
#@   group_variable  test  "test_default_bidir_delay" 
#@   group_variable  test  "test_default_delay" 
#@   group_variable  test  "test_default_period" 
#@   group_variable  test  "test_default_strobe" 
#@   group_variable  test  "test_default_strobe_width" 
#@   group_variable  test  "test_capture_clock_skew" 
#@   group_variable  test  "test_allow_clock_reconvergence" 
#@   group_variable  test  "test_check_port_changes_in_capture" 
#@   group_variable  test  "test_stil_max_line_length"
#@   group_variable  test  "test_infer_slave_clock_pulse_after_capture"
#@   group_variable  test  "test_rtldrc_latch_check_style"
#@   group_variable  test  "test_enable_capture_checks"
#@ 
#@   # "write_test" variables are used by the write_test command 
#@   group_variable  write_test  "write_test_formats" 
#@   group_variable  write_test  "write_test_include_scan_cell_info" 
#@   group_variable  write_test  "write_test_input_dont_care_value" 
#@   group_variable  write_test  "write_test_max_cycles" 
#@   group_variable  write_test  "write_test_max_scan_patterns" 
#@   group_variable  write_test  "write_test_pattern_set_naming_style" 
#@   group_variable  write_test  "write_test_scan_check_file_naming_style" 
#@   group_variable  write_test  "write_test_vector_file_naming_style" 
#@   group_variable  write_test  "write_test_round_timing_values" 
#@ 
#@   group_variable  view  "test_design_analyzer_uses_insert_scan"
#@ 
#@   # "io" variables are used by the read, read_lib, db2sge and write commands 
#@   group_variable  io  "bus_inference_descending_sort"
#@   group_variable  io  "bus_inference_style"
#@   #group_variable  io  "db2sge_output_directory"
#@   #group_variable  io  "db2sge_scale"
#@   #group_variable  io  "db2sge_overwrite"
#@   #group_variable  io  "db2sge_display_symbol_names"
#@   #group_variable  io  "db2sge_display_pin_names"
#@   #group_variable  io  "db2sge_display_instance_names"
#@   #group_variable  io  "db2sge_use_bustaps"
#@   #group_variable  io  "db2sge_use_compound_names"
#@   #group_variable  io  "db2sge_bit_type"
#@   #group_variable  io  "db2sge_bit_vector_type"
#@   #group_variable  io  "db2sge_one_name"
#@   #group_variable  io  "db2sge_zero_name"
#@   #group_variable  io  "db2sge_unknown_name"
#@   #group_variable  io  "db2sge_target_xp"
#@   #group_variable  io  "db2sge_tcf_package_file"
#@   #group_variable  io  "db2sge_use_lib_section"
#@   #group_variable  io  "db2sge_script"
#@   #group_variable  io  "db2sge_command" 
#@ 
#@ #  group_variable  io  "equationout_and_sign"
#@ #  group_variable  io  "equationout_or_sign"
#@ #  group_variable  io  "equationout_postfix_negation"
#@ 
#@   #  group_variable  io  "lsiin_net_name_prefix"
#@   #  group_variable  io  "lsiout_inverter_cell"
#@   #  group_variable  io  "lsiout_upcase"
#@ 
#@   #group_variable  io  "mentor_bidirect_value"
#@   #group_variable  io  "mentor_do_path"
#@   #group_variable  io  "mentor_input_output_property_name"
#@   #group_variable  io  "mentor_input_value"
#@   #group_variable  io  "mentor_logic_one_value"
#@   #group_variable  io  "mentor_logic_zero_one_property_name"
#@   #group_variable  io  "mentor_logic_zero_value"
#@   #group_variable  io  "mentor_output_value"
#@   #group_variable  io  "mentor_primitive_property_name"
#@   #group_variable  io  "mentor_primitive_property_value"
#@   #group_variable  io  "mentor_reference_property_name"
#@   #group_variable  io  "mentor_search_path"
#@   #group_variable  io  "mentor_write_symbols"
#@ #  group_variable  io  "pla_read_create_flip_flop"
#@ #  group_variable  io  "tdlout_upcase"
#@   group_variable  io  "write_name_nets_same_as_ports"
#@  
#@  # # [wjchen] 2006/08/14: The following 4 variables are obsoleted for DC simpilification.
#@  
#@  # group_variable  io  "xnfout_constraints_per_endpoint"
#@  # group_variable  io  "xnfout_default_time_constraints"
#@  # group_variable  io  "xnfout_clock_attribute_style"
#@  # group_variable  io  "xnfout_library_version"
#@ 
#@  # # [wjchen] 2006/08/11: The following 8 variables are obsoleted for DC simpilification.
#@  # group_variable  io  "xnfin_family"
#@  # group_variable  io  "xnfin_ignore_pins"
#@  # group_variable  io  "xnfin_dff_reset_pin_name"
#@  # group_variable  io  "xnfin_dff_set_pin_name"
#@  # group_variable  io  "xnfin_dff_clock_enable_pin_name"
#@  # group_variable  io  "xnfin_dff_data_pin_name"
#@  # group_variable  io  "xnfin_dff_clock_pin_name"  ;
#@  # group_variable  io  "xnfin_dff_q_pin_name";
#@  
#@   group_variable  io  "sdfin_min_rise_net_delay" ;
#@   group_variable  io  "sdfin_min_fall_net_delay" ;
#@   group_variable  io  "sdfin_min_rise_cell_delay" ;
#@   group_variable  io  "sdfin_min_fall_cell_delay" ;
#@   group_variable  io  "sdfin_rise_net_delay_type" ;
#@   group_variable  io  "sdfin_fall_net_delay_type" ;
#@   group_variable  io  "sdfin_rise_cell_delay_type" ;
#@   group_variable  io  "sdfin_fall_cell_delay_type" ;
#@   group_variable  io  "sdfin_top_instance_name" ;
#@   group_variable  io  "sdfout_time_scale" ;
#@   group_variable  io  "sdfout_write_to_output" ;
#@   group_variable  io  "sdfout_top_instance_name" ;
#@   group_variable  io  "sdfout_min_rise_net_delay" ;
#@   group_variable  io  "sdfout_min_fall_net_delay" ;
#@   group_variable  io  "sdfout_min_rise_cell_delay" ;
#@   group_variable  io  "sdfout_min_fall_cell_delay" ;
#@   group_variable  io  "read_db_lib_warnings" ;
#@   group_variable  io  "read_translate_msff" ;
#@   group_variable  io  "libgen_max_differences" ;
#@ 
#@ # #[wjchen] 2006/08/22: The following variables are hidden for XG mode for DC simpilification. 
#@   # group_variable  io "read_name_mapping_nowarn_libraries"  ;
#@   # group_variable  io "write_name_mapping_nowarn_libraries"  ;
#@ 
#@ 
#@   # "edif" variables are used by the EDIF format read, read_lib, write,
#@   #        and write_lib commands 
#@   # group_variable  edif  "bus_dimension_separator_style"  ;
#@   # group_variable  edif  "bus_extraction_style"  ;
#@   group_variable  edif  "bus_inference_descending_sort"  ;
#@   group_variable  edif  "bus_inference_style"  ;
#@   group_variable  edif  "bus_naming_style"  ;
#@   group_variable  edif  "bus_range_separator_style"  ;
#@   # group_variable  edif  "edifin_autoconnect_offpageconnectors"  ;
#@   # group_variable  edif  "edifin_autoconnect_ports"  ;
#@   # group_variable  edif  "edifin_delete_empty_cells"  ;
#@   # group_variable  edif  "edifin_delete_ripper_cells"  ;
#@   # group_variable  edif  "edifin_ground_net_name"  ;
#@   # group_variable  edif  "edifin_ground_net_property_name"  ;
#@   # group_variable  edif  "edifin_ground_net_property_value"  ;
#@   # group_variable  edif  "edifin_ground_port_name"  ;
#@   # group_variable  edif  "edifin_instance_property_name"  ;
#@   # group_variable  edif  "edifin_portinstance_disabled_property_name"  ;
#@   # group_variable  edif  "edifin_portinstance_disabled_property_value"  ;
#@   # group_variable  edif  "edifin_portinstance_property_name"  ;
#@   # group_variable  edif  "edifin_power_net_name"  ;
#@   # group_variable  edif  "edifin_power_net_property_name"  ;
#@   # group_variable  edif  "edifin_power_net_property_value"  ;
#@   # group_variable  edif  "edifin_power_port_name"  ;
#@   # group_variable  edif  "edifin_use_identifier_in_rename"  ;
#@   # group_variable  edif  "edifin_view_identifier_property_name"  ;
#@   # group_variable  edif  "edifin_dc_script_flag"  ;
#@   # group_variable  edif  "edifin_lib_logic_1_symbol"  ;
#@   # group_variable  edif  "edifin_lib_logic_0_symbol"  ;
#@   # group_variable  edif  "edifin_lib_in_port_symbol"  ;
#@   # group_variable  edif  "edifin_lib_out_port_symbol"  ;
#@   # group_variable  edif  "edifin_lib_inout_port_symbol"  ;
#@   # group_variable  edif  "edifin_lib_in_osc_symbol"  ;
#@   # group_variable  edif  "edifin_lib_out_osc_symbol"  ;
#@   # group_variable  edif  "edifin_lib_inout_osc_symbol"  ;
#@   # group_variable  edif  "edifin_lib_mentor_netcon_symbol"  ;
#@   # group_variable  edif  "edifin_lib_ripper_bits_property"  ;
#@   # group_variable  edif  "edifin_lib_ripper_bus_end"  ;
#@   # group_variable  edif  "edifin_lib_ripper_cell_name"  ;
#@   # group_variable  edif  "edifin_lib_ripper_view_name"  ;
#@   # group_variable  edif  "edifin_lib_route_grid"  ;
#@   # group_variable  edif  "edifin_lib_templates"  ;
#@   # group_variable  edif  "edifout_dc_script_flag"  ;
#@   # group_variable  edif  "edifout_design_name"  ;
#@   # group_variable  edif  "edifout_designs_library_name"  ;
#@   # group_variable  edif  "edifout_display_instance_names"  ;
#@   # group_variable  edif  "edifout_display_net_names"  ;
#@   # group_variable  edif  "edifout_external"  ;
#@   # group_variable  edif  "edifout_external_graphic_view_name" ;
#@   # group_variable  edif  "edifout_external_netlist_view_name" ;
#@   # group_variable  edif "edifout_external_schematic_view_name" ;
#@   # group_variable  edif  "edifout_ground_name" ;
#@   # group_variable  edif  "edifout_ground_net_name" ;
#@   # group_variable  edif  "edifout_ground_net_property_name" ;
#@   # group_variable  edif  "edifout_ground_net_property_value" ;
#@   # group_variable  edif  "edifout_ground_pin_name" ;
#@   # group_variable  edif  "edifout_ground_port_name" ;
#@   # group_variable  edif  "edifout_instance_property_name" ;
#@   # group_variable  edif  "edifout_instantiate_ports" ;
#@   # group_variable  edif  "edifout_library_graphic_view_name" ;
#@   # group_variable  edif  "edifout_library_netlist_view_name" ;
#@   # group_variable  edif  "edifout_library_schematic_view_name" ;
#@   # group_variable  edif  "edifout_merge_libraries" ;
#@   # group_variable  edif  "edifout_multidimension_arrays" ;
#@   # group_variable  edif  "edifout_name_oscs_different_from_ports" ;
#@   # group_variable  edif  "edifout_name_rippers_same_as_wires" ;
#@   # group_variable  edif  "edifout_netlist_only" ;
#@   # group_variable  edif  "edifout_no_array" ;
#@   # group_variable  edif  "edifout_numerical_array_members" ;
#@   # group_variable  edif  "edifout_pin_direction_property_name" ;
#@   # group_variable  edif  "edifout_pin_direction_in_value" ;
#@   # group_variable  edif  "edifout_pin_direction_inout_value" ;
#@   # group_variable  edif  "edifout_pin_direction_out_value" ;
#@   # group_variable  edif  "edifout_pin_name_property_name" ;
#@   # group_variable  edif  "edifout_portinstance_disabled_property_name" ;
#@   # group_variable  edif  "edifout_portinstance_disabled_property_value" ;
#@   # group_variable  edif  "edifout_portinstance_property_name"
#@   # group_variable  edif  "edifout_power_and_ground_representation"
#@   # group_variable  edif  "edifout_power_name"
#@   # group_variable  edif  "edifout_power_net_name"
#@   # group_variable  edif  "edifout_power_net_property_name"
#@   # group_variable  edif  "edifout_power_net_property_value"
#@   # group_variable  edif  "edifout_power_pin_name"
#@   # group_variable  edif  "edifout_power_port_name"
#@   # group_variable  edif  "edifout_skip_port_implementations"
#@   # group_variable  edif  "edifout_target_system"
#@   # group_variable  edif  "edifout_top_level_symbol"
#@   # group_variable  edif  "edifout_translate_origin"
#@   # group_variable  edif  "edifout_unused_property_value"
#@   # group_variable  edif  "edifout_write_attributes"
#@   # group_variable  edif  "edifout_write_constraints"
#@   # group_variable  edif  "edifout_write_properties_list"
#@   # group_variable  edif  "write_name_nets_same_as_ports"
#@ 
#@   # "hdl" variables are variables pertaining to hdl reading and optimizing 
#@   group_variable hdl "bus_dimension_separator_style"
#@   group_variable hdl "bus_minus_style"
#@   group_variable hdl "bus_naming_style"
#@   group_variable hdl "hdlin_ignore_textio_constructs"
#@   group_variable hdl "hdlin_latch_always_async_set_reset"
#@   group_variable hdl "hdlin_ff_always_sync_set_reset"
#@   group_variable hdl "hdlin_ff_always_async_set_reset"
#@   group_variable hdl "hdlin_check_input_netlist"
#@   group_variable hdl "hdlin_check_no_latch"
#@   group_variable hdl "hdlin_reporting_level"
#@   group_variable hdl "hdlin_infer_mux"
#@   group_variable hdl "hdlin_mux_oversize_ratio"
#@   group_variable hdl "hdlin_mux_size_limit"
#@   group_variable hdl "hdlin_infer_multibit"
#@   group_variable hdl "hdl_preferred_license"
#@   group_variable hdl "hdl_keep_licenses"
#@   group_variable hdl "hlo_resource_allocation"
#@   group_variable hdl "template_naming_style"
#@   group_variable hdl "template_parameter_style"
#@   group_variable hdl "template_separator_style"
#@   group_variable hdl "verilogout_equation"
#@   group_variable hdl "verilogout_ignore_case"
#@   group_variable hdl "verilogout_no_tri"
#@   group_variable hdl "verilogout_single_bit"
#@   group_variable hdl "verilogout_higher_designs_first"
#@ #  group_variable hdl "verilogout_levelize"
#@   group_variable hdl "verilogout_include_files"
#@   group_variable hdl "verilogout_unconnected_prefix"
#@   group_variable hdl "verilogout_show_unconnected_pins"
#@   group_variable hdl "verilogout_no_negative_index"
#@   group_variable hdl "hdlin_enable_rtldrc_info"
#@   group_variable hdl "hdlin_infer_function_local_latches"
#@   group_variable hdl "hdlin_module_arch_name_splitting"
#@   group_variable hdl "hdlin_mux_size_min"
#@   group_variable hdl "hdlin_prohibit_nontri_multiple_drivers"
#@   group_variable hdl "hdlin_subprogram_default_values"
#@   group_variable hdl "hdlin_upcase_names"
#@   group_variable hdl "hdlin_vhdl_87"
#@   group_variable hdl "hdlin_vhdl93_concat"
#@   group_variable hdl "hdlin_vrlg_std"
#@   group_variable hdl "hdlin_while_loop_iterations"
#@   group_variable hdl "hdlin_auto_save_templates"
#@   group_variable hdl "hdlin_elab_errors_deep"
#@   group_variable hdl "hdlin_enable_assertions"
#@   group_variable hdl "hdlin_enable_configurations"
#@   group_variable hdl "hdlin_field_naming_style"
#@   group_variable hdl "hdlin_generate_naming_style"
#@   group_variable hdl "hdlin_generate_separator_style"
#@   group_variable hdl "hdlin_keep_signal_name"
#@   group_variable hdl "hdlin_module_name_limit"
#@   group_variable hdl "hdlin_mux_size_only"
#@   group_variable hdl "hdlin_optimize_pla_effort"
#@   group_variable hdl "hdlin_preserve_sequential"
#@   group_variable hdl "hdlin_presto_cell_name_prefix"
#@   group_variable hdl "hdlin_presto_net_name_prefix"
#@   group_variable hdl "hdlin_shorten_long_module_name"
#@   group_variable hdl "hdlin_sv_ieee_assignment_patterns"
#@   group_variable hdl "hdlin_sv_packages"
#@   group_variable hdl "hdlin_sv_tokens"
#@   group_variable hdl "hdlin_enable_elaborate_ref_linking"
#@ 
#@ 
#@   # "vhdlio" variables are variables pertaining to VHDL generation 
#@   group_variable vhdlio "vhdllib_timing_mesg"
#@   group_variable vhdlio "vhdllib_timing_xgen"
#@   group_variable vhdlio "vhdllib_timing_checks"
#@   group_variable vhdlio "vhdllib_negative_constraint"
#@   group_variable vhdlio "vhdllib_pulse_handle"
#@   group_variable vhdlio "vhdllib_glitch_handle"
#@   group_variable vhdlio "vhdllib_architecture"
#@   group_variable vhdlio "vhdllib_tb_compare"
#@   group_variable vhdlio "vhdllib_tb_x_eq_dontcare"
#@   group_variable vhdlio "vhdllib_logic_system"
#@   group_variable vhdlio "vhdllib_logical_name"
#@ 
#@ #  group_variable vhdlio "vhdlout_architecture_name"
#@   group_variable vhdlio "vhdlout_bit_type"
#@ #  group_variable vhdlio "vhdlout_bit_type_resolved"
#@   group_variable vhdlio "vhdlout_bit_vector_type"
#@ #  group_variable vhdlio "vhdlout_conversion_functions"
#@ #  group_variable vhdlio "vhdlout_dont_write_types"
#@   group_variable vhdlio "vhdlout_equations"
#@   group_variable vhdlio "vhdlout_one_name"
#@   group_variable vhdlio "vhdlout_package_naming_style"
#@   group_variable vhdlio "vhdlout_preserve_hierarchical_types"
#@   group_variable vhdlio "vhdlout_separate_scan_in"
#@   group_variable vhdlio "vhdlout_single_bit"
#@   group_variable vhdlio "vhdlout_target_simulator"
#@   group_variable vhdlio "vhdlout_top_configuration_arch_name"
#@   group_variable vhdlio "vhdlout_top_configuration_entity_name"
#@   group_variable vhdlio "vhdlout_top_configuration_name"
#@   group_variable vhdlio "vhdlout_three_state_name"
#@   group_variable vhdlio "vhdlout_three_state_res_func"
#@ #  group_variable vhdlio "vhdlout_time_scale"
#@   group_variable vhdlio "vhdlout_unknown_name"
#@   group_variable vhdlio "vhdlout_use_packages"
#@   group_variable vhdlio "vhdlout_wired_and_res_func"
#@   group_variable vhdlio "vhdlout_wired_or_res_func"
#@   group_variable vhdlio "vhdlout_write_architecture"
#@   group_variable vhdlio "vhdlout_write_entity"
#@   group_variable vhdlio "vhdlout_write_top_configuration"
#@ #  group_variable vhdlio "vhdlout_synthesis_off"
#@   group_variable vhdlio "vhdlout_write_components"
#@   group_variable vhdlio "vhdlout_zero_name"
#@ #  group_variable vhdlio "vhdlout_levelize"
#@   group_variable vhdlio "vhdlout_dont_create_dummy_nets"
#@   group_variable vhdlio "vhdlout_follow_vector_direction"
#@  
#@   # "suffix" variables are used to find the suffixes of different file types 
#@   group_variable suffix "view_execute_script_suffix"
#@   group_variable suffix "view_read_file_suffix"
#@   group_variable suffix "view_analyze_file_suffix"
#@   group_variable suffix "view_write_file_suffix"
#@ 
#@   # Meenakshi: Added new group scc (for SystemC compiler)
#@   group_variable scc {systemcout_levelize}
#@   group_variable scc {systemcout_debug_mode}
#@ 
#@   # "power" variables are for power-analysis. 
#@   group_variable power {power_keep_license_after_power_commands}
#@   group_variable power {power_preserve_rtl_hier_names}
#@   group_variable power {power_do_not_size_icg_cells}
#@   group_variable power {power_hdlc_do_not_split_cg_cells}
#@   group_variable power {power_rtl_saif_file}
#@   group_variable power {power_sdpd_saif_file}
#@   group_variable power {power_cg_flatten}
#@   group_variable power {power_opto_extra_high_dynamic_power_effort}
#@   group_variable power {power_default_static_probability}
#@   group_variable power {power_default_toggle_rate}
#@   group_variable power {power_default_toggle_rate_type}
#@   group_variable power {power_model_preference}
#@   group_variable power {power_sa_propagation_effort}
#@   group_variable power {power_sa_propagation_verbose}
#@   group_variable power {power_fix_sdpd_annotation}
#@   group_variable power {power_fix_sdpd_annotation_verbose}
#@   group_variable power {power_sdpd_message_tolerance}
#@   group_variable power {power_rclock_use_asynch_inputs}
#@   group_variable power {power_rclock_inputs_use_clocks_fanout}
#@   group_variable power {power_rclock_unrelated_use_fastest}
#@   group_variable power {power_lib2saif_rise_fall_pd}
#@   group_variable power {power_min_internal_power_threshold}
#@   group_variable power {power_cg_module_naming_style}
#@   group_variable power {power_cg_cell_naming_style}
#@   group_variable power {power_cg_gated_clock_net_naming_style}
#@   group_variable power {do_operand_isolation}
#@ 
#@   # dpcm variables are used by DPCM lib and controllong DC when using DPCM
#@ 
#@   if { [info exists dpcm_debuglevel] } {
#@     group_variable dpcm "dpcm_debuglevel"
#@     group_variable dpcm "dpcm_rulespath"
#@     group_variable dpcm "dpcm_rulepath"
#@     group_variable dpcm "dpcm_tablepath"
#@     group_variable dpcm "dpcm_libraries"
#@     group_variable dpcm "dpcm_version"
#@     group_variable dpcm "dpcm_level"
#@     group_variable dpcm "dpcm_temperaturescope"
#@     group_variable dpcm "dpcm_voltagescope"
#@     group_variable dpcm "dpcm_functionscope"
#@     group_variable dpcm "dpcm_wireloadscope"
#@     group_variable dpcm "dpcm_slewlimit"
#@     group_variable dpcm "dpcm_arc_sense_mapping"
#@ 
#@   }
#@ 
#@   set dpcm_slewlimit "TRUE"
#@ 
#@   # executable to fire off RTLA/BCV 
#@   group_variable hdl {xterm_executable}
#@ 
#@   # Variable group for Chip Compiler
#@   if {[info exists acs_work_dir]} {
#@     group_variable acs acs_area_report_suffix 
#@     group_variable acs acs_autopart_max_area
#@     group_variable acs acs_autopart_max_percent
#@     group_variable acs acs_budgeted_cstr_suffix
#@     group_variable acs acs_compile_script_suffix
#@     group_variable acs acs_constraint_file_suffix  
#@     group_variable acs acs_cstr_report_suffix 
#@     group_variable acs acs_db_suffix
#@     group_variable acs acs_dc_exec
#@     group_variable acs acs_default_pass_name
#@     group_variable acs acs_exclude_extensions
#@     group_variable acs acs_exclude_list
#@     group_variable acs acs_global_user_compile_strategy_script
#@     group_variable acs acs_hdl_verilog_define_list
#@     group_variable acs acs_hdl_source
#@     group_variable acs acs_lic_wait
#@     group_variable acs acs_log_file_suffix
#@     group_variable acs acs_make_args
#@     group_variable acs acs_make_exec
#@     group_variable acs acs_makefile_name 
#@     group_variable acs acs_num_parallel_jobs
#@     group_variable acs acs_override_report_suffix
#@     group_variable acs acs_override_script_suffix
#@     group_variable acs acs_qor_report_suffix
#@     group_variable acs acs_timing_report_suffix
#@     group_variable acs acs_use_autopartition
#@     group_variable acs acs_use_default_delays
#@     group_variable acs acs_user_budgeting_script
#@     group_variable acs acs_user_compile_strategy_script_suffix
#@     group_variable acs acs_verilog_extensions 
#@     group_variable acs acs_vhdl_extensions 
#@     group_variable acs acs_work_dir
#@     group_variable acs check_error_list
#@     group_variable acs ilm_preserve_core_constraints
#@ 
#@   }
#@ 
#@   # eco group includes variables related to ECO Compiler
#@   group_variable eco "eco_align_design_verbose"
#@   group_variable eco "eco_allow_register_type_difference"
#@   group_variable eco "eco_connect_resource_cell_inputs" 
#@   group_variable eco "eco_correspondence_analysis_verbose" 
#@   group_variable eco "eco_directives_verbose"
#@   group_variable eco "eco_implement_effort_level"
#@   group_variable eco "eco_instance_name_prefix"         
#@   group_variable eco "eco_recycle_verbose"           
#@   group_variable eco "eco_remap_register_verbose"
#@   group_variable eco "eco_reuse_verbose"         
#@  
#@   #
#@   # DesignTime Variable Group timing
#@   #
#@ 
#@   group_variable timing case_analysis_log_file
#@   group_variable timing case_analysis_sequential_propagate
#@   group_variable timing case_analysis_with_logic_constants
#@   group_variable timing create_clock_no_input_delay
#@   group_variable timing disable_auto_time_borrow
#@   group_variable timing disable_case_analysis
#@   group_variable timing disable_conditional_mode_analysis
#@   group_variable timing disable_library_transition_degradation
#@   group_variable timing dont_bind_unused_pins_to_logic_constant
#@   group_variable timing enable_slew_degradation
#@   group_variable timing high_fanout_net_pin_capacitance
#@   group_variable timing high_fanout_net_threshold
#@   group_variable timing lib_thresholds_per_lib
#@   group_variable timing rc_adjust_rd_when_less_than_rnet
#@   group_variable timing rc_ceff_delay_min_diff_ps
#@   group_variable timing rc_degrade_min_slew_when_rd_less_than_rnet
#@   group_variable timing rc_driver_model_max_error_pct
#@   group_variable timing rc_filter_rd_less_than_rnet
#@   group_variable timing rc_input_threshold_pct_fall
#@   group_variable timing rc_input_threshold_pct_rise
#@   group_variable timing rc_output_threshold_pct_fall
#@   group_variable timing rc_output_threshold_pct_rise
#@   group_variable timing rc_rd_less_than_rnet_threshold
#@   group_variable timing rc_slew_derate_from_library
#@   group_variable timing rc_slew_lower_threshold_pct_fall
#@   group_variable timing rc_slew_lower_threshold_pct_rise
#@   group_variable timing rc_slew_upper_threshold_pct_fall
#@   group_variable timing rc_slew_upper_threshold_pct_rise
#@   group_variable timing timing_disable_cond_default_arcs
#@   group_variable timing timing_enable_multiple_clocks_per_reg
#@   group_variable timing timing_report_attributes
#@   group_variable timing timing_self_loops_no_skew
#@   group_variable timing when_analysis_permitted
#@   group_variable timing when_analysis_without_case_analysis
#@ 
#@ }	;# $synopsys_program_name != "ptxr"
#@ 
#@ if { $synopsys_program_name == "icc_shell"} {
#@ #
#@ #       IC Compile Variable Group:
#@ #
#@ #       These variables affect the designs created by the route_opt command.
#@ #
#@   group_variable routeopt routeopt_checkpoint
#@   group_variable routeopt routeopt_disable_cpulimit
#@ }
#@ 
#@ if { $synopsys_program_name == "icc_shell"} {
#@ #
#@ #       IC Compiler Variable Group: MCMM
#@ #
#@ #       These variables affect Multi-Corner/Multi-Mode. Currently, MCMM is 
#@ #       only supported in ICC--hence the "icc_shell" qualification, above
#@ #
#@   group_variable MCMM mcmm_enable_high_capacity_flow
#@ }
#@ 
#@ # Aliases for backwards compatibility or other reasons 
#@ group_variable compile  {compile_log_format}
#@ alias view_cursor_number x11_set_cursor_number
#@ alias set_internal_load set_load
#@ alias set_internal_arrival set_arrival
#@ alias set_connect_delay    "set_annotated_delay -net"
#@ alias create_test_vectors  create_test_patterns
#@ alias compile_test         insert_test
#@ alias check_clocks      check_timing
#@ alias lint              check_design
#@ alias verify            compare_design
#@ # gen removed; alias gen               create_schematic
#@ alias free              remove_design
#@ alias group_bus         create_bus
#@ alias ungroup_bus       remove_bus
#@ alias groupvar          group_variable
#@ alias report_constraints report_constraint
#@ alias report_attributes report_attribute
#@ alias fsm_reduce        reduce_fsm
#@ alias fsm_minimize      minimize_fsm
#@ alias disable_timing    set_disable_timing
#@ alias dont_touch        set_dont_touch
#@ alias dont_touch_network set_dont_touch_network
#@ alias dont_use          set_dont_use
#@ alias fix_hold          set_fix_hold
#@ alias prefer            set_prefer
#@ alias remove_package "echo remove_package command is obsolete: packages are stored on disk not in-memory:"
#@ alias analyze_scan      preview_scan
#@ alias get_clock         get_clocks
#@ alias dc_shell_is_in_incr_mode	shell_is_in_xg_mode
#@ alias set_vh_module_options set_dps_module_options
#@ alias set_vh_physopt_options set_dps_options
#@ alias update_vh_design update_dps_design
#@ alias vh_start dps_start
#@ alias vh_end dps_end
#@ alias all_vh_modules all_dps_modules
#@ alias all_designs_of_vh all_designs_of_dps
#@ alias vh_use_auto_partitioning dps_auto_partitioning
#@ alias vh_write_changes dps_write_changes
#@ alias vh_read_changes dps_read_changes
#@ alias vh_write_module_clock dps_write_module_clock
#@ 
#@ # Enable unsupported psyn commands
#@ if { $synopsys_program_name == "psyn_shell" || $synopsys_program_name == "icc_shell"} {
#@   proc enable_unsupported_commands { { arg "default" } } {
#@     global cgpi_use_new_wire_factors
#@     global cgpi_use_relative_wire_factors
#@     global cgpi_use_new_path_factors
#@     global pwlm_use_new_wire_factors
#@     global pwlm_use_relative_wire_factors
#@     global pwlm_use_new_path_factors
#@     global psyn_unsupported_commands_dir
#@     global synopsys_root
#@     if {![info exists psyn_unsupported_commands_dir]} {
#@       set psyn_unsupported_commands_dir $synopsys_root/auxx/syn/psyn/unsupported_commands
#@     }
#@     set psyn_unsupported_commands_option1 $arg
#@     if {[file readable $psyn_unsupported_commands_dir/setup.tcl]} {
#@       source $psyn_unsupported_commands_dir/setup.tcl
#@     } else {
#@       source -encrypted $psyn_unsupported_commands_dir/setup.tcl.e
#@     }
#@   }
#@ }
#@ # For Intel
#@ if { $synopsys_program_name == "icc_shell"} {
#@       set psyn_unsupported_commands_dir $synopsys_root/auxx/syn/psyn/unsupported_commands
#@       source -encrypted $psyn_unsupported_commands_dir/max_dist.tcl.e
#@ }	
#@ 
#@ 
#@ if { $synopsys_program_name == "icc_shell"} {
#@   # to enable CLE readline-ish terminal by default for ICC
#@   set sh_enable_line_editing true
#@ 
#@   # Astro forms create an enormous number of new variables which are
#@   # very annoying for users to see, so the default of this variable
#@   # for ICC is false
#@   set sh_new_variable_message false
#@ }
#@ 
#@ if { $synopsys_program_name == "icc_shell" ||      (($synopsys_program_name == "dc_shell") && ([shell_is_in_topographical_mode])) } {
#@     source $synopsys_root/auxx/syn/psyn/verify_ilm.tcl
#@ }
#@ 
#@ # Enable vh psyn commands
#@ if { $synopsys_program_name == "psyn_shell" } {
#@   proc enable_vh_flow { } {
#@     global VH_SCRIPT_FILE
#@     global synopsys_root
#@     global suppress_errors
#@     set suppress_errors "$suppress_errors CMD-041 UID-95 SEL-003 SEL-005" 
#@     if {![info exists VH_SCRIPT_FILE]} {
#@       set VH_SCRIPT_FILE $synopsys_root/auxx/syn/psyn/vh_pc.tcl.e
#@     }
#@     if {[file readable $VH_SCRIPT_FILE]} {
#@       if {[string match *.tcl $VH_SCRIPT_FILE]} {
#@         source $VH_SCRIPT_FILE
#@       } else {
#@         source -encrypted $VH_SCRIPT_FILE
#@       }
#@     } else {
#@       puts "Error: VH script file $VH_SCRIPT_FILE not found."
#@     }
#@   }
#@ }
#@ 
#@ 
#@ #Turn on enable_netl_view to true by default.
#@ set enable_netl_view  "TRUE"
#@ 
#@ 
#@ #Turn on physopt_bypass_multiple_plib_check by default
#@ if { $synopsys_program_name == "psyn_shell" } {
#@  set physopt_bypass_multiple_plib_check  TRUE
#@ }
#@ 
#@ # The ls command is gone, now it is just an alias for dc_shell eqn mode
#@ 
#@ if { [string compare $dc_shell_mode "default"] == 0 } {
#@   if {  ( $sh_arch == {mips}) && ( ( $synopsys_program_name == {design_analyzer}) || ( $isatty == 0)) } {
#@     alias ls "sh ls -a "
#@   } else {
#@    if {  ( $sh_arch == {mips}) || ( $sh_arch == {necmips}) } {
#@       alias ls "sh ls -aC "
#@    } else {
#@       alias ls "sh ls -aC "
#@    }
#@   }
#@ }
#@ 
#@ # Aliases for RouteCompiler
#@ alias run_rodeo_router route66
#@ 
#@ # Removing route_global from the code. Earlier it was hidden. --Mukesh
#@ #proc route_global {} {
#@ #	global route_global_keep_tmp_data
#@ #	global rt66_dont_lock_dir
#@ #
#@ #	set rt66_dont_lock_dir TRUE
#@ #
#@ #	for { set i 0} {1==1} {incr i} {
#@ #		set wdir [file join [pwd] ".route_global.$i"]
#@ #		if {[file exist $wdir] == 0} {
#@ #			break;
#@ #		}
#@ #	}
#@ #		
#@ #	set_routing_options -cut_out_covered_port CORE_ONLY
#@ #	set_routing_options -internal_routing FALSE
#@ #	set_routing_options -stick_routing FALSE
#@ #
#@ #	###puts "wdir = $wdir"
#@ # 
#@ #	set success [route66 -global -dontstop -dir $wdir]
#@ #
#@ #	#clean tmp data if required:
#@ #	if { $success == 1 } {
#@ #		if [catch {string toupper $route_global_keep_tmp_data} result] {
#@ #			#variable is not defined
#@ #			###puts "result_1 =  $result => removing dir ..."
#@ #			catch { file delete -force $wdir }
#@ #		} else {
#@ #			#variable is set to FALSE
#@ #			if { [string compare $result "TRUE"] != 0} {
#@ #				###puts "result_2 =  $result => removing dir ..."
#@ #				catch { file delete -force $wdir }
#@ #			}
#@ #		}
#@ #	}
#@ #
#@ #	set rt66_dont_lock_dir FALSE
#@ #	return 1
#@ #}
#@ #define_proc_attributes route_global -hidden
#@ 
#@ #/* Aliases added for report command */
#@ alias report_clock_constraint   "report_timing -path end -to all_registers(-data_pins)"
#@ alias report_clock_fanout         "report_transitive_fanout -clock_tree"
#@ alias report_clocks             report_clock
#@ alias report_synthetic          report_cell
#@ 
#@ # Alias added for Ultra backward compatibility mode
#@ alias set_ultra_mode          set_ultra_optimization
#@ 
#@ # alias for write_sge and menu item in DA for db2sge 
#@ 
#@ #if { [string compare $dc_shell_mode "tcl"] == 0 } {
#@ #  set db2sge_script ${synopsys_root}/admin/setup/.dc_write_sge.tcl
#@ #} else {
#@ #  set db2sge_script ${synopsys_root}/admin/setup/.dc_write_sge
#@ #}
#@ 
#@ #set db2sge_command ${synopsys_root}/${sh_arch}/syn/bin/db2sge
#@ set view_script_submenu_items "\"DA to SGE Transfer\" write_sge"
#@ 
#@ 
#@ if { $synopsys_program_name != "lc_shell"} {
#@   # read schematic annotation setup file 
#@   #source ${synopsys_root}/admin/setup/.dc_annotate
#@ 
#@   # setup the default layer settings 
#@   #source ${synopsys_root}/admin/setup/.dc_layers
#@ 
#@   source ${synopsys_root}/admin/setup/.dc_name_rules
#@ } else {
#@   #for read_lib -html	
#@   source ${synopsys_root}/auxx/syn/lc/read_lib_html_msg_list.tcl
#@ }
#@ #
#@ 
#@ #	.dc_name_rules Initialization file for
#@ 
#@ #	   Dc_Shell and Design_Analyzer
#@ 
#@ #	This files defines name rules for target systems. Change_names
#@ #	will use this rules to fix the object names.
#@ 
#@ #*/
#@ 
#@ 
#@ define_name_rules sverilog -type net -allow "a-z A-Z 0-9 _ " 					  -first_restrict "_ 0-9"		
#@ 
#@ define_name_rules sverilog -type port -allow "a-z A-Z 0-9 _ " 					  -first_restrict "_ 0-9"		
#@ 
#@ define_name_rules sverilog -type cell -allow "a-z A-Z 0-9 _ " 					  -first_restrict "_ 0-9"		
#@ define_name_rules sverilog -reserved { "always" "always_comb" "always_ff"	"always_latch" "and" "assert" "assert_strobe" "assign" "automatic"	"begin" "bit" "break" "buf" "bufif0" "bufif1" "byte" "case" "casex" "casez"	"cell" "changed" "char" "cmos" "config" "const" "continue" "deassign"	"default" "defparam" "design" "disable" "do" "edge" "else" "end"	"endcase" "endconfig" "endfunction" "endgenerate" "endinterface" "endmodule" "endprimitive"	"endspecify" "endtable" "endtask" "endtransition" "enum" "event" "export" "extern"	"for" "force" "forever" "fork" "forkjoin" "function" "generate" "genvar"	"highz0" "highz1" "if" "iff" "ifnone" "import" "incdir" "include" "initial"	"inout" "input" "instance" "int" "integer" "interface" "join" "large"	"liblist" "library" "localparam" "logic" "longint" "longreal" "macromodule" "medium"	"modport" "module" "nand" "negedge" "nmos" "nor" "noshowcancelled" "not" "notif0"	"notif1" "or" "output" "packed" "parameter" "pmos" "posedge"	"primitive" "process" "priority" "pull0" "pull1" "pullup"  "pulldown"	"pulsestyle_onevent" "pulsestyle_ondetect"	"rcmos" "real" "realtime" "reg" "release" "repeat" "return" "rnmos" "rpmos" "rtran"	"rtranif0" "rtranif1" "scalared" "shortint" "shortreal" "showcancelled"	"signed" "small" "specify" "specparam" "static"	"strong0" "strong1" "struct" "supply0" "supply1" "table" "task"	"time" "timeprecision" "timeunit" "tran" "tranif0" "tranif1" "transition" "tri" "tri0" "tri1"	"triand" "trior" "trireg" "type" "typedef" "union" "unique" "use" "unsigned" "vectored"	"void" "wait" "wand" "weak0" "weak1" "while" "wire" "wor" "xor" "xnor" }		-special verilog -target_bus_naming_style {%s[%d]}		-flatten_multi_dimension_busses          -check_internal_net_name 	-check_bus_indexing 
#@ 
#@ define_name_rules verilog -type net -allow "a-z A-Z 0-9 _ " 					  -first_restrict "_ 0-9"		
#@ 
#@ define_name_rules verilog -type port -allow "a-z A-Z 0-9 _ " 					  -first_restrict "_ 0-9"		
#@ 
#@ define_name_rules verilog -type cell -allow "a-z A-Z 0-9 _ " 					  -first_restrict "_ 0-9"		
#@ define_name_rules verilog -reserved { "always"	"and" "assign" "automatic"	"begin" "buf" "bufif0" "bufif1" "case" "casex" "casez"	"cell" "cmos" "config" "deassign"	"default" "defparam" "design" "disable" "edge" "else" "end"	"endcase" "endconfig" "endfunction" "endgenerate" "endmodule" "endprimitive"	"endspecify" "endtable" "endtask" "event" "for" "force" "forever" "fork" "function" "generate" "genvar"	"highz0" "highz1" "if" "ifnone" "incdir" "include" "initial"	"inout" "input" "instance" "integer" "join" "large"	"liblist" "library" "localparam" "macromodule" "medium"	"module" "nand" "negedge" "nmos" "nor" "noshowcancelled" "not" "notif0"	"notif1" "or" "output" "parameter" "pmos" "posedge"	"primitive" "pull0" "pull1" "pullup"  "pulldown"	"pulsestyle_onevent" "pulsestyle_ondetect"	"rcmos" "real" "realtime" "reg" "release" "repeat" "rnmos" "rpmos" "rtran"	"rtranif0" "rtranif1" "scalared" "showcancelled"	"signed" "small" "specify" "specparam"	"strong0" "strong1" "supply0" "supply1" "table" "task"	"time" "tran" "tranif0" "tranif1" "tri" "tri0" "tri1"	"triand" "trior" "trireg" "unsigned" "use" "vectored"	"wait" "wand" "weak0" "weak1" "while" "wire" "wor" "xor" "xnor" }		-special verilog -target_bus_naming_style {%s[%d]}		-flatten_multi_dimension_busses  	-check_internal_net_name         -check_bus_indexing
#@ 
#@ define_name_rules verilog_1995 -type net -allow "a-z A-Z 0-9 _ " 					  -first_restrict "_ 0-9"		
#@ 
#@ define_name_rules verilog_1995 -type port -allow "a-z A-Z 0-9 _ " 					  -first_restrict "_ 0-9"		
#@ 
#@ define_name_rules verilog_1995 -type cell -allow "a-z A-Z 0-9 _ " 					  -first_restrict "_ 0-9"		
#@ define_name_rules verilog_1995 -reserved { "always"	"and" "assign"	"begin" "buf" "bufif0" "bufif1" "case" "casex" "casez"	"cell" "cmos" "deassign"	"default" "defparam" "design" "disable" "edge" "else" "end"	"endcase" "endfunction" "endmodule" "endprimitive"	"endspecify" "endtable" "endtask" "event" "for" "force" "forever" "fork" "function"	"highz0" "highz1" "if" "ifnone" "initial"	"inout" "input" "integer" "join" "large"	"macromodule" "medium"	"module" "nand" "negedge" "nmos" "nor" "notif0"	"notif1" "or" "output" "parameter" "pmos" "posedge"	"primitive" "pull0" "pull1" "pullup"  "pulldown"	"rcmos" "real" "realtime" "reg" "release" "repeat" "rnmos" "rpmos" "rtran"	"rtranif0" "rtranif1" "scalared"	"small" "specify" "specparam"	"strong0" "strong1" "supply0" "supply1" "table" "task"	"time" "tran" "tranif0" "tranif1" "tri" "tri0" "tri1"	"triand" "trior" "trireg" "vectored"	"wait" "wand" "weak0" "weak1" "while" "wire" "wor" "xor" "xnor" }		-special verilog -target_bus_naming_style {%s[%d]}		-flatten_multi_dimension_busses  	-check_internal_net_name 	-check_bus_indexing
#@ 
#@ 
#@ ####/* Name rule for VHDL */
#@ 
#@ ####/* Name rule for VHDL */
#@ 
#@ ####/* Name rule for VHDL */
#@ 
#@ define_name_rules vhdl -reserved_words {                                        "abs"  "access"  "after" "alias"  "all"  "and"                          "architecture"  "array"  "assert" "attribute"                   \                  
#@         "begin"  "block"  "body"  "buffer"  "bus"                               "case" "component"  "configuration"  "constant"                         "disconnect" "downto"                                                   "else"  "elsif"  "end"  "entity"  "exit"                                "file" "for"  "function"                                                "generate"  "generic" "group" "guarded"                                 "if" "impure" "in" "inertial" "inout"  "is"                             "label"  "library"  "linkage" "literal" "loop"                          "map"  "mod"                                                            "nand"  "new"  "next"  "nor"  "not"  "null"                             "of"  "on"  "open"  "or"  "others"  "out"                               "package"  "port" "postponed" "procedure"  "process" "pure"             "range"  "record"  "register" "reject" "rem"                            "report"  "return"  "rol" "ror"                                         "select"  "severity"  "signal" "shared" "sla" "sll"                     "sra" "srl" "subtype"                                                   "then"  "to"  "transport"  "type"                                       "unaffected" "units"  "until"  "use"                                    "variable"                                                              "wait"  "when"  "while"  "with"                                         "xnor" "xor"}                                                   	-case_insensitive 							-target_bus_naming_style "%s(%d)"					-replacement_char "x"							-special vhdl
#@ define_name_rules vhdl -type net						-allowed "A-Z a-z _ 0-9 " 						-first_restricted "0-9 _"  						-last_restricted "_"
#@ define_name_rules vhdl -type port						-allowed "A-Z a-z _ 0-9 " 						-first_restricted "0-9 _"  						-last_restricted "_"
#@ define_name_rules vhdl -type cell						-allowed "A-Z a-z _ 0-9" 						-first_restricted "0-9 _"  						-last_restricted "_"						
#@ define_name_rules vhdl -map { {{"__","_"},{"_$",""}} }
#@ 
#@ ####/* Name rule for VHDL */
#@ # -- End source /usr/cad/synopsys/synthesis/cur/admin/setup/.dc_name_rules

#@ 
#@ if { $synopsys_program_name == "psyn_gui"} {
#@     # read RouteCompiler GUI file for timing critical pathes.
#@     source ${synopsys_root}/auxx/syn/route_gui/write_route_timing_path.tcl
#@ }
#@ 
#@ # Set physopt_dw_opto to false
#@ if { [string match -nocase {*icc_shell*} $synopsys_program_name] } {
#@     set physopt_dw_opto FALSE
#@ }
#@ 
#@ #/* Read budgeting setup script  */
#@ 
#@ if { [string compare $dc_shell_mode "default"] == 0 } {
#@ 
#@ #  Need a encrypted file in Tcl format for budget.setup.et
#@   if { $sh_arch != "msvc50" && $sh_arch != "alpha_nt" } {
#@ #    source  -e synopsys_root + "/admin/setup/budget.setup.et"
#@   }
#@ }
#@ 
#@ if { $synopsys_program_name == "icc_shell"} {
#@   source $synopsys_root/auxx/syn/.icc_procs.tcl
#@   source -encrypted $synopsys_root/auxx/syn/cts/fast_atomic_cts.tcl.e
#@ }
#@ 
#@ if { $synopsys_program_name == "icc_shell"} {
#@   alias report_scenario report_scenarios
#@ }
#@ 
#@ # floorplanning preferences globals
#@ global fp_snap_type
#@ 
#@ set fp_snap_type(port) wiretrack
#@ set fp_snap_type(cell) litho
#@ set fp_snap_type(pin) wiretrack
#@ set fp_snap_type(movebound) litho
#@ set fp_snap_type(port_shape) wiretrack
#@ set fp_snap_type(wiring_keepout) wiretrack
#@ set fp_snap_type(placement_keepout) litho
#@ set fp_snap_type(net_shape) wiretrack
#@ set fp_snap_type(route_shape) wiretrack
#@ set fp_snap_type(none) litho
#@ 
#@ # 6/24/05 cpark requested to add to GA image
#@ set suppress_errors "$suppress_errors RCCALC-010 RCCALC-011"
#@ 
#@ # alias for write_sge is always the last line of the setup file
#@ #if { [string compare $dc_shell_mode "tcl"] == 0 } {
#@ #   alias write_sge "source db2sge_script"
#@ #} else {
#@ #   alias write_sge "include db2sge_script"
#@ #}
#@ 
#@ if { $dc_shell_mode == "tcl" } {
#@         # Configure Execute script dialog to display .tcl files
#@ 	  set view_execute_script_suffix "$view_execute_script_suffix .tcl"
#@    }
#@ 
#@ #
#@ # Shirley Lu 5/15/2007
#@ #
#@ # Invoke NCX validation/correlation/fomatter from lc_shell:
#@ #
#@ # UNIX shell:
#@ # setenv SYNOPSYS_NCX_ROOT /mydisk/ncx_2007.06
#@ #
#@ 
#@ if {[info exists env(SYNOPSYS_NCX_ROOT)]} {
#@ 
#@   set ncx_path $env(SYNOPSYS_NCX_ROOT)/ncx/${sh_arch}/bin
#@ 
#@ #
#@ # check_ccs_lib
#@ # use libchecker under $ncx_path defined above
#@ #
#@ proc check_ccs_lib {args} {
#@     global ncx_path
#@     set cmdStr [linsert  $args 0 ${ncx_path}/libchecker -lc_shell]
#@     set cmd [open "| $cmdStr 2>@ stdout"]
#@     catch {
#@       while {[gets $cmd info] >= 0} {
#@         echo $info
#@       }
#@     }
#@     if {[catch {close $cmd} msg]} {
#@     }
#@ }
#@ 
#@ #
#@ # format_lib
#@ # use ncx under $ncx_path defined above
#@ #
#@ proc format_lib {args} {
#@     global ncx_path
#@     set cmdStr [linsert  $args 0 ${ncx_path}/ncx -lc_shell]
#@     set cmd [open "| $cmdStr 2>@ stdout"]
#@     catch {
#@       while {[gets $cmd info] >= 0} {
#@         echo $info
#@       }
#@     }
#@     if {[catch {close $cmd} msg]} {
#@     }
#@ }
#@ 
#@ }
#@ 
#@ # -- End source /usr/cad/synopsys/synthesis/cur/admin/setup/.synopsys_dc.setup

gui_start
#@ # tk.tcl --
#@ #
#@ # Initialization script normally executed in the interpreter for each
#@ # Tk-based application.  Arranges class bindings for widgets.
#@ #
#@ # RCS: @(#) $Id: //sde/tcl/tk8.4r/rel1/library/tk.tcl#1 $
#@ #
#@ # Copyright (c) 1992-1994 The Regents of the University of California.
#@ # Copyright (c) 1994-1996 Sun Microsystems, Inc.
#@ # Copyright (c) 1998-2000 Ajuba Solutions.
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ 
#@ # Insist on running with compatible versions of Tcl and Tk.
#@ package require -exact Tk 8.4
#@ package require -exact Tcl 8.4
#@ 
#@ # Create a ::tk namespace
#@ namespace eval ::tk {
#@     # Set up the msgcat commands
#@     namespace eval msgcat {
#@ 	namespace export mc mcmax        
#@         if {[interp issafe] || [catch {package require msgcat}]} {
#@             # The msgcat package is not available.  Supply our own
#@             # minimal replacement.
#@             proc mc {src args} {
#@                 return [eval [list format $src] $args]
#@             }
#@             proc mcmax {args} {
#@                 set max 0
#@                 foreach string $args {
#@                     set len [string length $string]
#@                     if {$len>$max} {
#@                         set max $len
#@                     }
#@                 }
#@                 return $max
#@             }
#@         } else {
#@             # Get the commands from the msgcat package that Tk uses.
#@             namespace import ::msgcat::mc
#@             namespace import ::msgcat::mcmax
#@             ::msgcat::mcload [file join $::tk_library msgs]
#@         }
#@     }
#@     namespace import ::tk::msgcat::*
#@ }
#@ # msgcat.tcl --
#@ #
#@ #	This file defines various procedures which implement a
#@ #	message catalog facility for Tcl programs.  It should be
#@ #	loaded with the command "package require msgcat".
#@ #
#@ # Copyright (c) 1998-2000 by Ajuba Solutions.
#@ # Copyright (c) 1998 by Mark Harrison.
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ # 
#@ # RCS: @(#) $Id: //sde/tcl/tcl8.4r/rel3/library/msgcat/msgcat.tcl#1 $
#@ 
#@ package require Tcl 8.2
#@ # When the version number changes, be sure to update the pkgIndex.tcl file,
#@ # and the installation directory in the Makefiles.
#@ package provide msgcat 1.3.1
#@ 
#@ namespace eval msgcat {
#@     namespace export mc mcload mclocale mcmax mcmset mcpreferences mcset 	    mcunknown
#@ 
#@     # Records the current locale as passed to mclocale
#@     variable Locale ""
#@ 
#@     # Records the list of locales to search
#@     variable Loclist {}
#@ 
#@     # Records the mapping between source strings and translated strings.  The
#@     # array key is of the form "<locale>,<namespace>,<src>" and the value is
#@     # the translated string.
#@     array set Msgs {}
#@ 
#@     # Map of language codes used in Windows registry to those of ISO-639
#@     array set WinRegToISO639 {
#@         01 ar 0401 ar_SA 0801 ar_IQ 0c01 ar_EG 1001 ar_LY 1401 ar_DZ
#@               1801 ar_MA 1c01 ar_TN 2001 ar_OM 2401 ar_YE 2801 ar_SY
#@               2c01 ar_JO 3001 ar_LB 3401 ar_KW 3801 ar_AE 3c01 ar_BH
#@               4001 ar_QA
#@         02 bg 0402 bg_BG
#@         03 ca 0403 ca_ES
#@         04 zh 0404 zh_TW 0804 zh_CN 0c04 zh_HK 1004 zh_SG 1404 zh_MO
#@         05 cs 0405 cs_CZ
#@         06 da 0406 da_DK
#@         07 de 0407 de_DE 0807 de_CH 0c07 de_AT 1007 de_LU 1407 de_LI
#@         08 el 0408 el_GR
#@         09 en 0409 en_US 0809 en_GB 0c09 en_AU 1009 en_CA 1409 en_NZ
#@               1809 en_IE 1c09 en_ZA 2009 en_JM 2409 en_GD 2809 en_BZ
#@               2c09 en_TT 3009 en_ZW 3409 en_PH
#@         0a es 040a es_ES 080a es_MX 0c0a es_ES@modern 100a es_GT 140a es_CR
#@               180a es_PA 1c0a es_DO 200a es_VE 240a es_CO 280a es_PE
#@               2c0a es_AR 300a es_EC 340a es_CL 380a es_UY 3c0a es_PY
#@               400a es_BO 440a es_SV 480a es_HN 4c0a es_NI 500a es_PR
#@         0b fi 040b fi_FI
#@         0c fr 040c fr_FR 080c fr_BE 0c0c fr_CA 100c fr_CH 140c fr_LU
#@               180c fr_MC
#@         0d he 040d he_IL
#@         0e hu 040e hu_HU
#@         0f is 040f is_IS
#@         10 it 0410 it_IT 0810 it_CH
#@         11 ja 0411 ja_JP
#@         12 ko 0412 ko_KR
#@         13 nl 0413 nl_NL 0813 nl_BE
#@         14 no 0414 no_NO 0814 nn_NO
#@         15 pl 0415 pl_PL
#@         16 pt 0416 pt_BR 0816 pt_PT
#@         17 rm 0417 rm_CH
#@         18 ro 0418 ro_RO
#@         19 ru
#@         1a hr 041a hr_HR 081a sr_YU 0c1a sr_YU@cyrillic
#@         1b sk 041b sk_SK
#@         1c sq 041c sq_AL
#@         1d sv 041d sv_SE 081d sv_FI
#@         1e th 041e th_TH
#@         1f tr 041f tr_TR
#@         20 ur 0420 ur_PK 0820 ur_IN
#@         21 id 0421 id_ID
#@         22 uk 0422 uk_UA
#@         23 be 0423 be_BY
#@         24 sl 0424 sl_SI
#@         25 et 0425 et_EE
#@         26 lv 0426 lv_LV
#@         27 lt 0427 lt_LT
#@         28 tg 0428 tg_TJ
#@         29 fa 0429 fa_IR
#@         2a vi 042a vi_VN
#@         2b hy 042b hy_AM
#@         2c az 042c az_AZ@latin 082c az_AZ@cyrillic
#@         2d eu
#@         2e wen 042e wen_DE
#@         2f mk 042f mk_MK
#@         30 bnt 0430 bnt_TZ
#@         31 ts 0431 ts_ZA
#@         33 ven 0433 ven_ZA
#@         34 xh 0434 xh_ZA
#@         35 zu 0435 zu_ZA
#@         36 af 0436 af_ZA
#@         37 ka 0437 ka_GE
#@         38 fo 0438 fo_FO
#@         39 hi 0439 hi_IN
#@         3a mt 043a mt_MT
#@         3b se 043b se_NO
#@         043c gd_UK 083c ga_IE
#@         3d yi 043d yi_IL
#@         3e ms 043e ms_MY 083e ms_BN
#@         3f kk 043f kk_KZ
#@         40 ky 0440 ky_KG
#@         41 sw 0441 sw_KE
#@         42 tk 0442 tk_TM
#@         43 uz 0443 uz_UZ@latin 0843 uz_UZ@cyrillic
#@         44 tt 0444 tt_RU
#@         45 bn 0445 bn_IN
#@         46 pa 0446 pa_IN
#@         47 gu 0447 gu_IN
#@         48 or 0448 or_IN
#@         49 ta
#@         4a te 044a te_IN
#@         4b kn 044b kn_IN
#@         4c ml 044c ml_IN
#@         4d as 044d as_IN
#@         4e mr 044e mr_IN
#@         4f sa 044f sa_IN
#@         50 mn
#@         51 bo 0451 bo_CN
#@         52 cy 0452 cy_GB
#@         53 km 0453 km_KH
#@         54 lo 0454 lo_LA
#@         55 my 0455 my_MM
#@         56 gl 0456 gl_ES
#@         57 kok 0457 kok_IN
#@         58 mni 0458 mni_IN
#@         59 sd
#@         5a syr 045a syr_TR
#@         5b si 045b si_LK
#@         5c chr 045c chr_US
#@         5d iu 045d iu_CA
#@         5e am 045e am_ET
#@         5f ber 045f ber_MA
#@         60 ks 0460 ks_PK 0860 ks_IN
#@         61 ne 0461 ne_NP 0861 ne_IN
#@         62 fy 0462 fy_NL
#@         63 ps
#@         64 tl 0464 tl_PH
#@         65 div 0465 div_MV
#@         66 bin 0466 bin_NG
#@         67 ful 0467 ful_NG
#@         68 ha 0468 ha_NG
#@         69 nic 0469 nic_NG
#@         6a yo 046a yo_NG
#@         70 ibo 0470 ibo_NG
#@         71 kau 0471 kau_NG
#@         72 om 0472 om_ET
#@         73 ti 0473 ti_ET
#@         74 gn 0474 gn_PY
#@         75 cpe 0475 cpe_US
#@         76 la 0476 la_VA
#@         77 so 0477 so_SO
#@         78 sit 0478 sit_CN
#@         79 pap 0479 pap_AN
#@     }
#@ }
#@ 
#@ # msgcat::mc --
#@ #
#@ #	Find the translation for the given string based on the current
#@ #	locale setting. Check the local namespace first, then look in each
#@ #	parent namespace until the source is found.  If additional args are
#@ #	specified, use the format command to work them into the traslated
#@ #	string.
#@ #
#@ # Arguments:
#@ #	src	The string to translate.
#@ #	args	Args to pass to the format command
#@ #
#@ # Results:
#@ #	Returns the translatd string.  Propagates errors thrown by the 
#@ #	format command.
#@ 
#@ proc msgcat::mc {src args} {
#@     # Check for the src in each namespace starting from the local and
#@     # ending in the global.
#@ 
#@     variable Msgs
#@     variable Loclist
#@     variable Locale
#@ 
#@     set ns [uplevel 1 [list ::namespace current]]
#@     
#@     while {$ns != ""} {
#@ 	foreach loc $Loclist {
#@ 	    if {[info exists Msgs($loc,$ns,$src)]} {
#@ 		if {[llength $args] == 0} {
#@ 		    return $Msgs($loc,$ns,$src)
#@ 		} else {
#@ 		    return [uplevel 1 			    [linsert $args 0 ::format $Msgs($loc,$ns,$src)]]
#@ 		}
#@ 	    }
#@ 	}
#@ 	set ns [namespace parent $ns]
#@     }
#@     # we have not found the translation
#@     return [uplevel 1 	    [linsert $args 0 [::namespace origin mcunknown] $Locale $src]]
#@ }
#@ 
#@ # msgcat::mclocale --
#@ #
#@ #	Query or set the current locale.
#@ #
#@ # Arguments:
#@ #	newLocale	(Optional) The new locale string. Locale strings
#@ #			should be composed of one or more sublocale parts
#@ #			separated by underscores (e.g. en_US).
#@ #
#@ # Results:
#@ #	Returns the current locale.
#@ 
#@ proc msgcat::mclocale {args} {
#@     variable Loclist
#@     variable Locale
#@     set len [llength $args]
#@ 
#@     if {$len > 1} {
#@ 	error {wrong # args: should be "mclocale ?newLocale?"}
#@     }
#@ 
#@     if {$len == 1} {
#@ 	set Locale [string tolower [lindex $args 0]]
#@ 	set Loclist {}
#@ 	set word ""
#@ 	foreach part [split $Locale _] {
#@ 	    set word [string trimleft "${word}_${part}" _]
#@ 	    set Loclist [linsert $Loclist 0 $word]
#@ 	}
#@     }
#@     return $Locale
#@ }
#@ 
#@ # msgcat::mcpreferences --
#@ #
#@ #	Fetch the list of locales used to look up strings, ordered from
#@ #	most preferred to least preferred.
#@ #
#@ # Arguments:
#@ #	None.
#@ #
#@ # Results:
#@ #	Returns an ordered list of the locales preferred by the user.
#@ 
#@ proc msgcat::mcpreferences {} {
#@     variable Loclist
#@     return $Loclist
#@ }
#@ 
#@ # msgcat::mcload --
#@ #
#@ #	Attempt to load message catalogs for each locale in the
#@ #	preference list from the specified directory.
#@ #
#@ # Arguments:
#@ #	langdir		The directory to search.
#@ #
#@ # Results:
#@ #	Returns the number of message catalogs that were loaded.
#@ 
#@ proc msgcat::mcload {langdir} {
#@     set x 0
#@     foreach p [mcpreferences] {
#@ 	set langfile [file join $langdir $p.msg]
#@ 	if {[file exists $langfile]} {
#@ 	    incr x
#@ 	    set fid [open $langfile "r"]
#@ 	    fconfigure $fid -encoding utf-8
#@             uplevel 1 [read $fid]
#@ 	    close $fid
#@ 	}
#@     }
#@     return $x
#@ }
#@ 
#@ # msgcat::mcset --
#@ #
#@ #	Set the translation for a given string in a specified locale.
#@ #
#@ # Arguments:
#@ #	locale		The locale to use.
#@ #	src		The source string.
#@ #	dest		(Optional) The translated string.  If omitted,
#@ #			the source string is used.
#@ #
#@ # Results:
#@ #	Returns the new locale.
#@ 
#@ proc msgcat::mcset {locale src {dest ""}} {
#@     variable Msgs
#@     if {[string equal $dest ""]} {
#@ 	set dest $src
#@     }
#@ 
#@     set ns [uplevel 1 [list ::namespace current]]
#@ 
#@     set Msgs([string tolower $locale],$ns,$src) $dest
#@     return $dest
#@ }
#@ 
#@ # msgcat::mcmset --
#@ #
#@ #	Set the translation for multiple strings in a specified locale.
#@ #
#@ # Arguments:
#@ #	locale		The locale to use.
#@ #	pairs		One or more src/dest pairs (must be even length)
#@ #
#@ # Results:
#@ #	Returns the number of pairs processed
#@ 
#@ proc msgcat::mcmset {locale pairs } {
#@     variable Msgs
#@ 
#@     set length [llength $pairs]
#@     if {$length % 2} {
#@ 	error {bad translation list: should be "mcmset locale {src dest ...}"}
#@     }
#@     
#@     set locale [string tolower $locale]
#@     set ns [uplevel 1 [list ::namespace current]]
#@     
#@     foreach {src dest} $pairs {
#@         set Msgs($locale,$ns,$src) $dest
#@     }
#@     
#@     return $length
#@ }
#@ 
#@ # msgcat::mcunknown --
#@ #
#@ #	This routine is called by msgcat::mc if a translation cannot
#@ #	be found for a string.  This routine is intended to be replaced
#@ #	by an application specific routine for error reporting
#@ #	purposes.  The default behavior is to return the source string.  
#@ #	If additional args are specified, the format command will be used
#@ #	to work them into the traslated string.
#@ #
#@ # Arguments:
#@ #	locale		The current locale.
#@ #	src		The string to be translated.
#@ #	args		Args to pass to the format command
#@ #
#@ # Results:
#@ #	Returns the translated value.
#@ 
#@ proc msgcat::mcunknown {locale src args} {
#@     if {[llength $args]} {
#@ 	return [uplevel 1 [linsert $args 0 ::format $src]]
#@     } else {
#@ 	return $src
#@     }
#@ }
#@ 
#@ # msgcat::mcmax --
#@ #
#@ #	Calculates the maximun length of the translated strings of the given 
#@ #	list.
#@ #
#@ # Arguments:
#@ #	args	strings to translate.
#@ #
#@ # Results:
#@ #	Returns the length of the longest translated string.
#@ 
#@ proc msgcat::mcmax {args} {
#@     set max 0
#@     foreach string $args {
#@ 	set translated [uplevel 1 [list [namespace origin mc] $string]]
#@         set len [string length $translated]
#@         if {$len>$max} {
#@             set max $len
#@         }
#@     }
#@     return $max
#@ }
#@ 
#@ # Convert the locale values stored in environment variables to a form
#@ # suitable for passing to [mclocale]
#@ proc msgcat::ConvertLocale {value} {
#@     # Assume $value is of form: $language[_$territory][.$codeset][@modifier]
#@     # Convert to form: $language[_$territory][_$modifier]
#@     #
#@     # Comment out expanded RE version -- bugs alleged
#@     # regexp -expanded {
#@     #	^		# Match all the way to the beginning
#@     #	([^_.@]*)	# Match "lanugage"; ends with _, ., or @
#@     #	(_([^.@]*))?	# Match (optional) "territory"; starts with _
#@     #	([.]([^@]*))?	# Match (optional) "codeset"; starts with .
#@     #	(@(.*))?	# Match (optional) "modifier"; starts with @
#@     #	$		# Match all the way to the end
#@     # } $value -> language _ territory _ codeset _ modifier
#@     regexp {^([^_.@]*)(_([^.@]*))?([.]([^@]*))?(@(.*))?$} $value 	    -> language _ territory _ codeset _ modifier
#@     set ret $language
#@     if {[string length $territory]} {
#@ 	append ret _$territory
#@     }
#@     if {[string length $modifier]} {
#@ 	append ret _$modifier
#@     }
#@     return $ret
#@ }
#@ 
#@ # Initialize the default locale
#@ proc msgcat::Init {} {
#@     #
#@     # set default locale, try to get from environment
#@     #
#@     foreach varName {LC_ALL LC_MESSAGES LANG} {
#@ 	if {[info exists ::env($varName)] 
#@ 		&& ![string equal "" $::env($varName)]} {
#@             mclocale [ConvertLocale $::env($varName)]
#@ 	    return
#@ 	}
#@     }
#@     #
#@     # The rest of this routine is special processing for Windows;
#@     # all other platforms, get out now.
#@     #
#@     if { ![string equal $::tcl_platform(platform) windows] } {
#@ 	mclocale C
#@ 	return
#@     }
#@     #
#@     # On Windows, try to set locale depending on registry settings,
#@     # or fall back on locale of "C".  
#@     #
#@     set key {HKEY_CURRENT_USER\Control Panel\International}
#@     if {[catch {package require registry}] 	    || [catch {registry get $key "locale"} locale]} {
#@         mclocale C
#@ 	return
#@     }
#@     #
#@     # Keep trying to match against smaller and smaller suffixes
#@     # of the registry value, since the latter hexadigits appear
#@     # to determine general language and earlier hexadigits determine
#@     # more precise information, such as territory.  For example,
#@     #     0409 - English - United States
#@     #     0809 - English - United Kingdom
#@     # Add more translations to the WinRegToISO639 array above.
#@     #
#@     variable WinRegToISO639
#@     set locale [string tolower $locale]
#@     while {[string length $locale]} {
#@         if {![catch {mclocale [ConvertLocale $WinRegToISO639($locale)]}]} {
#@ 	    return
#@ 	}
#@ 	set locale [string range $locale 1 end]
#@     }
#@     #
#@     # No translation known.  Fall back on "C" locale
#@     #
#@     mclocale C
#@ }
#@ msgcat::Init
#@ # -- End source /usr/cad/synopsys/synthesis/cur/auxx/tcllib/lib/tcl8.4/msgcat/msgcat.tcl

#@ 
#@ # Add Tk's directory to the end of the auto-load search path, if it
#@ # isn't already on the path:
#@ 
#@ if {[info exists ::auto_path] && [string compare {} $::tk_library] && 	[lsearch -exact $::auto_path $::tk_library] < 0} {
#@     lappend ::auto_path $::tk_library
#@ }
#@ 
#@ # Turn off strict Motif look and feel as a default.
#@ 
#@ set ::tk_strictMotif 0
#@ 
#@ # Turn on useinputmethods (X Input Methods) by default.
#@ # We catch this because safe interpreters may not allow the call.
#@ 
#@ catch {tk useinputmethods 1}
#@ 
#@ # ::tk::PlaceWindow --
#@ #   place a toplevel at a particular position
#@ # Arguments:
#@ #   toplevel	name of toplevel window
#@ #   ?placement?	pointer ?center? ; places $w centered on the pointer
#@ #		widget widgetPath ; centers $w over widget_name
#@ #		defaults to placing toplevel in the middle of the screen
#@ #   ?anchor?	center or widgetPath
#@ # Results:
#@ #   Returns nothing
#@ #
#@ proc ::tk::PlaceWindow {w {place ""} {anchor ""}} {
#@     wm withdraw $w
#@     update idletasks
#@     set checkBounds 1
#@     if {[string equal $place ""]} {
#@ 	set x [expr {([winfo screenwidth $w]-[winfo reqwidth $w])/2}]
#@ 	set y [expr {([winfo screenheight $w]-[winfo reqheight $w])/2}]
#@ 	set checkBounds 0
#@     } elseif {[string equal -len [string length $place] $place "pointer"]} {
#@ 	## place at POINTER (centered if $anchor == center)
#@ 	if {[string equal -len [string length $anchor] $anchor "center"]} {
#@ 	    set x [expr {[winfo pointerx $w]-[winfo reqwidth $w]/2}]
#@ 	    set y [expr {[winfo pointery $w]-[winfo reqheight $w]/2}]
#@ 	} else {
#@ 	    set x [winfo pointerx $w]
#@ 	    set y [winfo pointery $w]
#@ 	}
#@     } elseif {[string equal -len [string length $place] $place "widget"] && 	    [winfo exists $anchor] && [winfo ismapped $anchor]} {
#@ 	## center about WIDGET $anchor, widget must be mapped
#@ 	set x [expr {[winfo rootx $anchor] + 		([winfo width $anchor]-[winfo reqwidth $w])/2}]
#@ 	set y [expr {[winfo rooty $anchor] + 		([winfo height $anchor]-[winfo reqheight $w])/2}]
#@     } else {
#@ 	set x [expr {([winfo screenwidth $w]-[winfo reqwidth $w])/2}]
#@ 	set y [expr {([winfo screenheight $w]-[winfo reqheight $w])/2}]
#@ 	set checkBounds 0
#@     }
#@     if {$checkBounds} {
#@ 	if {$x < 0} {
#@ 	    set x 0
#@ 	} elseif {$x > ([winfo screenwidth $w]-[winfo reqwidth $w])} {
#@ 	    set x [expr {[winfo screenwidth $w]-[winfo reqwidth $w]}]
#@ 	}
#@ 	if {$y < 0} {
#@ 	    set y 0
#@ 	} elseif {$y > ([winfo screenheight $w]-[winfo reqheight $w])} {
#@ 	    set y [expr {[winfo screenheight $w]-[winfo reqheight $w]}]
#@ 	}
#@ 	if {[tk windowingsystem] eq "macintosh" 		|| [tk windowingsystem] eq "aqua"} {
#@ 	    # Avoid the native menu bar which sits on top of everything.
#@ 	    if {$y < 20} { set y 20 }
#@ 	}
#@     }
#@     wm geometry $w +$x+$y
#@     wm deiconify $w
#@ }
#@ 
#@ # ::tk::SetFocusGrab --
#@ #   swap out current focus and grab temporarily (for dialogs)
#@ # Arguments:
#@ #   grab	new window to grab
#@ #   focus	window to give focus to
#@ # Results:
#@ #   Returns nothing
#@ #
#@ proc ::tk::SetFocusGrab {grab {focus {}}} {
#@     set index "$grab,$focus"
#@     upvar ::tk::FocusGrab($index) data
#@ 
#@     lappend data [focus]
#@     set oldGrab [grab current $grab]
#@     lappend data $oldGrab
#@     if {[winfo exists $oldGrab]} {
#@ 	lappend data [grab status $oldGrab]
#@     }
#@     # The "grab" command will fail if another application
#@     # already holds the grab.  So catch it.
#@     catch {grab $grab}
#@     if {[winfo exists $focus]} {
#@ 	focus $focus
#@     }
#@ }
#@ 
#@ # ::tk::RestoreFocusGrab --
#@ #   restore old focus and grab (for dialogs)
#@ # Arguments:
#@ #   grab	window that had taken grab
#@ #   focus	window that had taken focus
#@ #   destroy	destroy|withdraw - how to handle the old grabbed window
#@ # Results:
#@ #   Returns nothing
#@ #
#@ proc ::tk::RestoreFocusGrab {grab focus {destroy destroy}} {
#@     set index "$grab,$focus"
#@     if {[info exists ::tk::FocusGrab($index)]} {
#@ 	foreach {oldFocus oldGrab oldStatus} $::tk::FocusGrab($index) { break }
#@ 	unset ::tk::FocusGrab($index)
#@     } else {
#@ 	set oldGrab ""
#@     }
#@ 
#@     catch {focus $oldFocus}
#@     grab release $grab
#@     if {[string equal $destroy "withdraw"]} {
#@ 	wm withdraw $grab
#@     } else {
#@ 	destroy $grab
#@     }
#@     if {[winfo exists $oldGrab] && [winfo ismapped $oldGrab]} {
#@ 	if {[string equal $oldStatus "global"]} {
#@ 	    grab -global $oldGrab
#@ 	} else {
#@ 	    grab $oldGrab
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::GetSelection --
#@ #   This tries to obtain the default selection.  On Unix, we first try
#@ #   and get a UTF8_STRING, a type supported by modern Unix apps for
#@ #   passing Unicode data safely.  We fall back on the default STRING
#@ #   type otherwise.  On Windows, only the STRING type is necessary.
#@ # Arguments:
#@ #   w	The widget for which the selection will be retrieved.
#@ #	Important for the -displayof property.
#@ #   sel	The source of the selection (PRIMARY or CLIPBOARD)
#@ # Results:
#@ #   Returns the selection, or an error if none could be found
#@ #
#@ if {[string equal $tcl_platform(platform) "unix"]} {
#@     proc ::tk::GetSelection {w {sel PRIMARY}} {
#@ 	if {[catch {selection get -displayof $w -selection $sel 		-type UTF8_STRING} txt] 		&& [catch {selection get -displayof $w -selection $sel} txt]} {
#@ 	    return -code error "could not find default selection"
#@ 	} else {
#@ 	    return $txt
#@ 	}
#@     }
#@ } else {
#@     proc ::tk::GetSelection {w {sel PRIMARY}} {
#@ 	if {[catch {selection get -displayof $w -selection $sel} txt]} {
#@ 	    return -code error "could not find default selection"
#@ 	} else {
#@ 	    return $txt
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::ScreenChanged --
#@ # This procedure is invoked by the binding mechanism whenever the
#@ # "current" screen is changing.  The procedure does two things.
#@ # First, it uses "upvar" to make variable "::tk::Priv" point at an
#@ # array variable that holds state for the current display.  Second,
#@ # it initializes the array if it didn't already exist.
#@ #
#@ # Arguments:
#@ # screen -		The name of the new screen.
#@ 
#@ proc ::tk::ScreenChanged screen {
#@     set x [string last . $screen]
#@     if {$x > 0} {
#@ 	set disp [string range $screen 0 [expr {$x - 1}]]
#@     } else {
#@ 	set disp $screen
#@     }
#@ 
#@     uplevel #0 upvar #0 ::tk::Priv.$disp ::tk::Priv
#@     variable ::tk::Priv
#@     global tcl_platform
#@ 
#@     if {[info exists Priv]} {
#@ 	set Priv(screen) $screen
#@ 	return
#@     }
#@     array set Priv {
#@ 	activeMenu	{}
#@ 	activeItem	{}
#@ 	afterId		{}
#@ 	buttons		0
#@ 	buttonWindow	{}
#@ 	dragging	0
#@ 	focus		{}
#@ 	grab		{}
#@ 	initPos		{}
#@ 	inMenubutton	{}
#@ 	listboxPrev	{}
#@ 	menuBar		{}
#@ 	mouseMoved	0
#@ 	oldGrab		{}
#@ 	popup		{}
#@ 	postedMb	{}
#@ 	pressX		0
#@ 	pressY		0
#@ 	prevPos		0
#@ 	selectMode	char
#@     }
#@     set Priv(screen) $screen
#@     set Priv(tearoff) [string equal [tk windowingsystem] "x11"]
#@     set Priv(window) {}
#@ }
#@ 
#@ # Do initial setup for Priv, so that it is always bound to something
#@ # (otherwise, if someone references it, it may get set to a non-upvar-ed
#@ # value, which will cause trouble later).
#@ 
#@ tk::ScreenChanged [winfo screen .]
#@ 
#@ # ::tk::EventMotifBindings --
#@ # This procedure is invoked as a trace whenever ::tk_strictMotif is
#@ # changed.  It is used to turn on or turn off the motif virtual
#@ # bindings.
#@ #
#@ # Arguments:
#@ # n1 - the name of the variable being changed ("::tk_strictMotif").
#@ 
#@ proc ::tk::EventMotifBindings {n1 dummy dummy} {
#@     upvar $n1 name
#@     
#@     if {$name} {
#@ 	set op delete
#@     } else {
#@ 	set op add
#@     }
#@ 
#@     event $op <<Cut>> <Control-Key-w>
#@     event $op <<Copy>> <Meta-Key-w> 
#@     event $op <<Paste>> <Control-Key-y>
#@     event $op <<Undo>> <Control-underscore>
#@ }
#@ 
#@ #----------------------------------------------------------------------
#@ # Define common dialogs on platforms where they are not implemented 
#@ # using compiled code.
#@ #----------------------------------------------------------------------
#@ 
#@ if {[string equal [info commands tk_chooseColor] ""]} {
#@     proc ::tk_chooseColor {args} {
#@ 	return [eval tk::dialog::color:: $args]
#@     }
#@ }
#@ if {[string equal [info commands tk_getOpenFile] ""]} {
#@     proc ::tk_getOpenFile {args} {
#@ 	if {$::tk_strictMotif} {
#@ 	    return [eval tk::MotifFDialog open $args]
#@ 	} else {
#@ 	    return [eval ::tk::dialog::file:: open $args]
#@ 	}
#@     }
#@ }
#@ if {[string equal [info commands tk_getSaveFile] ""]} {
#@     proc ::tk_getSaveFile {args} {
#@ 	if {$::tk_strictMotif} {
#@ 	    return [eval tk::MotifFDialog save $args]
#@ 	} else {
#@ 	    return [eval ::tk::dialog::file:: save $args]
#@ 	}
#@     }
#@ }
#@ if {[string equal [info commands tk_messageBox] ""]} {
#@     proc ::tk_messageBox {args} {
#@ 	return [eval tk::MessageBox $args]
#@     }
#@ }
#@ if {[string equal [info command tk_chooseDirectory] ""]} {
#@     proc ::tk_chooseDirectory {args} {
#@ 	return [eval ::tk::dialog::file::chooseDir:: $args]
#@     }
#@ }
#@ 
#@ #----------------------------------------------------------------------
#@ # Define the set of common virtual events.
#@ #----------------------------------------------------------------------
#@ 
#@ switch [tk windowingsystem] {
#@     "x11" {
#@ 	event add <<Cut>> <Control-Key-x> <Key-F20> 
#@ 	event add <<Copy>> <Control-Key-c> <Key-F16>
#@ 	event add <<Paste>> <Control-Key-v> <Key-F18>
#@ 	event add <<PasteSelection>> <ButtonRelease-2>
#@ 	event add <<Undo>> <Control-Key-z>
#@ 	event add <<Redo>> <Control-Key-Z>
#@ 	# Some OS's define a goofy (as in, not <Shift-Tab>) keysym
#@ 	# that is returned when the user presses <Shift-Tab>.  In order for
#@ 	# tab traversal to work, we have to add these keysyms to the 
#@ 	# PrevWindow event.
#@ 	# We use catch just in case the keysym isn't recognized.
#@ 	# This is needed for XFree86 systems
#@ 	catch { event add <<PrevWindow>> <ISO_Left_Tab> }
#@ 	# This seems to be correct on *some* HP systems.
#@ 	catch { event add <<PrevWindow>> <hpBackTab> }
#@ 
#@ 	trace variable ::tk_strictMotif w ::tk::EventMotifBindings
#@ 	set ::tk_strictMotif $::tk_strictMotif
#@     }
#@     "win32" {
#@ 	event add <<Cut>> <Control-Key-x> <Shift-Key-Delete>
#@ 	event add <<Copy>> <Control-Key-c> <Control-Key-Insert>
#@ 	event add <<Paste>> <Control-Key-v> <Shift-Key-Insert>
#@ 	event add <<PasteSelection>> <ButtonRelease-2>
#@   	event add <<Undo>> <Control-Key-z>
#@ 	event add <<Redo>> <Control-Key-y>
#@     }
#@     "aqua" {
#@ 	event add <<Cut>> <Command-Key-x> <Key-F2> 
#@ 	event add <<Copy>> <Command-Key-c> <Key-F3>
#@ 	event add <<Paste>> <Command-Key-v> <Key-F4>
#@ 	event add <<PasteSelection>> <ButtonRelease-2>
#@ 	event add <<Clear>> <Clear>
#@   	event add <<Undo>> <Command-Key-z>
#@ 	event add <<Redo>> <Command-Key-y>
#@     }
#@     "classic" {
#@ 	event add <<Cut>> <Control-Key-x> <Key-F2> 
#@ 	event add <<Copy>> <Control-Key-c> <Key-F3>
#@ 	event add <<Paste>> <Control-Key-v> <Key-F4>
#@ 	event add <<PasteSelection>> <ButtonRelease-2>
#@ 	event add <<Clear>> <Clear>
#@ 	event add <<Undo>> <Control-Key-z> <Key-F1>
#@ 	event add <<Redo>> <Control-Key-Z>
#@     }
#@ }
#@ # ----------------------------------------------------------------------
#@ # Read in files that define all of the class bindings.
#@ # ----------------------------------------------------------------------
#@ 
#@ if {$::tk_library ne ""} {
#@     if {[string equal $tcl_platform(platform) "macintosh"]} {
#@ 	proc ::tk::SourceLibFile {file} {
#@ 	    if {[catch {
#@ 		namespace eval :: 			[list source [file join $::tk_library $file.tcl]]
#@ 	    }]} {
#@ 		namespace eval :: [list source -rsrc $file]
#@ 	    }
#@ 	}
#@     } else {
#@ 	proc ::tk::SourceLibFile {file} {
#@ 	    namespace eval :: [list source [file join $::tk_library $file.tcl]]
#@ 	}	
#@     }
#@     namespace eval ::tk {
#@ 	SourceLibFile button
#@ 	SourceLibFile entry
#@ 	SourceLibFile listbox
#@ 	SourceLibFile menu
#@ 	SourceLibFile panedwindow
#@ 	SourceLibFile scale
#@ 	SourceLibFile scrlbar
#@ 	SourceLibFile spinbox
#@ 	SourceLibFile text
#@     }
#@ }
#@ # button.tcl --
#@ #
#@ # This file defines the default bindings for Tk label, button,
#@ # checkbutton, and radiobutton widgets and provides procedures
#@ # that help in implementing those bindings.
#@ #
#@ # RCS: @(#) $Id: //sde/tcl/tk8.4r/rel1/library/button.tcl#1 $
#@ #
#@ # Copyright (c) 1992-1994 The Regents of the University of California.
#@ # Copyright (c) 1994-1996 Sun Microsystems, Inc.
#@ # Copyright (c) 2002 ActiveState Corporation.
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ #
#@ 
#@ #-------------------------------------------------------------------------
#@ # The code below creates the default class bindings for buttons.
#@ #-------------------------------------------------------------------------
#@ 
#@ if {[string equal [tk windowingsystem] "classic"]
#@ 	|| [string equal [tk windowingsystem] "aqua"]} {
#@     bind Radiobutton <Enter> {
#@ 	tk::ButtonEnter %W
#@     }
#@     bind Radiobutton <1> {
#@ 	tk::ButtonDown %W
#@     }
#@     bind Radiobutton <ButtonRelease-1> {
#@ 	tk::ButtonUp %W
#@     }
#@     bind Checkbutton <Enter> {
#@ 	tk::ButtonEnter %W
#@     }
#@     bind Checkbutton <1> {
#@ 	tk::ButtonDown %W
#@     }
#@     bind Checkbutton <ButtonRelease-1> {
#@ 	tk::ButtonUp %W
#@     }
#@ }
#@ if {[string equal "windows" $tcl_platform(platform)]} {
#@     bind Checkbutton <equal> {
#@ 	tk::CheckRadioInvoke %W select
#@     }
#@     bind Checkbutton <plus> {
#@ 	tk::CheckRadioInvoke %W select
#@     }
#@     bind Checkbutton <minus> {
#@ 	tk::CheckRadioInvoke %W deselect
#@     }
#@     bind Checkbutton <1> {
#@ 	tk::CheckRadioDown %W
#@     }
#@     bind Checkbutton <ButtonRelease-1> {
#@ 	tk::ButtonUp %W
#@     }
#@     bind Checkbutton <Enter> {
#@ 	tk::CheckRadioEnter %W
#@     }
#@ 
#@     bind Radiobutton <1> {
#@ 	tk::CheckRadioDown %W
#@     }
#@     bind Radiobutton <ButtonRelease-1> {
#@ 	tk::ButtonUp %W
#@     }
#@     bind Radiobutton <Enter> {
#@ 	tk::CheckRadioEnter %W
#@     }
#@ }
#@ if {[string equal "x11" [tk windowingsystem]]} {
#@     bind Checkbutton <Return> {
#@ 	if {!$tk_strictMotif} {
#@ 	    tk::CheckRadioInvoke %W
#@ 	}
#@     }
#@     bind Radiobutton <Return> {
#@ 	if {!$tk_strictMotif} {
#@ 	    tk::CheckRadioInvoke %W
#@ 	}
#@     }
#@     bind Checkbutton <1> {
#@ 	tk::CheckRadioInvoke %W
#@     }
#@     bind Radiobutton <1> {
#@ 	tk::CheckRadioInvoke %W
#@     }
#@     bind Checkbutton <Enter> {
#@ 	tk::ButtonEnter %W
#@     }
#@     bind Radiobutton <Enter> {
#@ 	tk::ButtonEnter %W
#@     }
#@ }
#@ 
#@ bind Button <space> {
#@     tk::ButtonInvoke %W
#@ }
#@ bind Checkbutton <space> {
#@     tk::CheckRadioInvoke %W
#@ }
#@ bind Radiobutton <space> {
#@     tk::CheckRadioInvoke %W
#@ }
#@ 
#@ bind Button <FocusIn> {}
#@ bind Button <Enter> {
#@     tk::ButtonEnter %W
#@ }
#@ bind Button <Leave> {
#@     tk::ButtonLeave %W
#@ }
#@ bind Button <1> {
#@     tk::ButtonDown %W
#@ }
#@ bind Button <ButtonRelease-1> {
#@     tk::ButtonUp %W
#@ }
#@ 
#@ bind Checkbutton <FocusIn> {}
#@ bind Checkbutton <Leave> {
#@     tk::ButtonLeave %W
#@ }
#@ 
#@ bind Radiobutton <FocusIn> {}
#@ bind Radiobutton <Leave> {
#@     tk::ButtonLeave %W
#@ }
#@ 
#@ if {[string equal "windows" $tcl_platform(platform)]} {
#@ 
#@ #########################
#@ # Windows implementation 
#@ #########################
#@ 
#@ # ::tk::ButtonEnter --
#@ # The procedure below is invoked when the mouse pointer enters a
#@ # button widget.  It records the button we're in and changes the
#@ # state of the button to active unless the button is disabled.
#@ #
#@ # Arguments:
#@ # w -		The name of the widget.
#@ 
#@ proc ::tk::ButtonEnter w {
#@     variable ::tk::Priv
#@     if {[$w cget -state] ne "disabled"} {
#@ 
#@ 	# If the mouse button is down, set the relief to sunken on entry.
#@ 	# Overwise, if there's an -overrelief value, set the relief to that.
#@ 
#@ 	set Priv($w,relief) [$w cget -relief]
#@ 	if {$Priv(buttonWindow) eq $w} {
#@ 	    $w configure -relief sunken -state active
#@ 	    set Priv($w,prelief) sunken
#@ 	} elseif {[set over [$w cget -overrelief]] ne ""} {
#@ 	    $w configure -relief $over
#@ 	    set Priv($w,prelief) $over
#@ 	}
#@     }
#@     set Priv(window) $w
#@ }
#@ 
#@ # ::tk::ButtonLeave --
#@ # The procedure below is invoked when the mouse pointer leaves a
#@ # button widget.  It changes the state of the button back to inactive.
#@ # Restore any modified relief too.
#@ #
#@ # Arguments:
#@ # w -		The name of the widget.
#@ 
#@ proc ::tk::ButtonLeave w {
#@     variable ::tk::Priv
#@     if {[$w cget -state] ne "disabled"} {
#@ 	$w configure -state normal
#@     }
#@ 
#@     # Restore the original button relief if it was changed by Tk.
#@     # That is signaled by the existence of Priv($w,prelief).
#@ 
#@     if {[info exists Priv($w,relief)]} {
#@ 	if {[info exists Priv($w,prelief)] && 		$Priv($w,prelief) eq [$w cget -relief]} {
#@ 	    $w configure -relief $Priv($w,relief)
#@ 	}
#@ 	unset -nocomplain Priv($w,relief) Priv($w,prelief)
#@     }
#@ 
#@     set Priv(window) ""
#@ }
#@ 
#@ # ::tk::ButtonDown --
#@ # The procedure below is invoked when the mouse button is pressed in
#@ # a button widget.  It records the fact that the mouse is in the button,
#@ # saves the button's relief so it can be restored later, and changes
#@ # the relief to sunken.
#@ #
#@ # Arguments:
#@ # w -		The name of the widget.
#@ 
#@ proc ::tk::ButtonDown w {
#@     variable ::tk::Priv
#@ 
#@     # Only save the button's relief if it does not yet exist.  If there
#@     # is an overrelief setting, Priv($w,relief) will already have been set,
#@     # and the current value of the -relief option will be incorrect.
#@ 
#@     if {![info exists Priv($w,relief)]} {
#@ 	set Priv($w,relief) [$w cget -relief]
#@     }
#@ 
#@     if {[$w cget -state] ne "disabled"} {
#@ 	set Priv(buttonWindow) $w
#@ 	$w configure -relief sunken -state active
#@ 	set Priv($w,prelief) sunken
#@ 
#@ 	# If this button has a repeatdelay set up, get it going with an after
#@ 	after cancel $Priv(afterId)
#@ 	set delay [$w cget -repeatdelay]
#@ 	set Priv(repeated) 0
#@ 	if {$delay > 0} {
#@ 	    set Priv(afterId) [after $delay [list tk::ButtonAutoInvoke $w]]
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::ButtonUp --
#@ # The procedure below is invoked when the mouse button is released
#@ # in a button widget.  It restores the button's relief and invokes
#@ # the command as long as the mouse hasn't left the button.
#@ #
#@ # Arguments:
#@ # w -		The name of the widget.
#@ 
#@ proc ::tk::ButtonUp w {
#@     variable ::tk::Priv
#@     if {$Priv(buttonWindow) eq $w} {
#@ 	set Priv(buttonWindow) ""
#@ 
#@ 	# Restore the button's relief if it was cached.
#@ 
#@ 	if {[info exists Priv($w,relief)]} {
#@ 	    if {[info exists Priv($w,prelief)] && 		    $Priv($w,prelief) eq [$w cget -relief]} {
#@ 		$w configure -relief $Priv($w,relief)
#@ 	    }
#@ 	    unset -nocomplain Priv($w,relief) Priv($w,prelief)
#@ 	}
#@ 
#@ 	# Clean up the after event from the auto-repeater
#@ 	after cancel $Priv(afterId)
#@ 
#@ 	if {$Priv(window) eq $w && [$w cget -state] ne "disabled"} {
#@ 	    $w configure -state normal
#@ 
#@ 	    # Only invoke the command if it wasn't already invoked by the
#@ 	    # auto-repeater functionality
#@ 	    if { $Priv(repeated) == 0 } {
#@ 		uplevel #0 [list $w invoke]
#@ 	    }
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::CheckRadioEnter --
#@ # The procedure below is invoked when the mouse pointer enters a
#@ # checkbutton or radiobutton widget.  It records the button we're in
#@ # and changes the state of the button to active unless the button is
#@ # disabled.
#@ #
#@ # Arguments:
#@ # w -		The name of the widget.
#@ 
#@ proc ::tk::CheckRadioEnter w {
#@     variable ::tk::Priv
#@     if {[$w cget -state] ne "disabled"} {
#@ 	if {$Priv(buttonWindow) eq $w} {
#@ 	    $w configure -state active
#@ 	}
#@ 	if {[set over [$w cget -overrelief]] ne ""} {
#@ 	    set Priv($w,relief)  [$w cget -relief]
#@ 	    set Priv($w,prelief) $over
#@ 	    $w configure -relief $over
#@ 	}
#@     }
#@     set Priv(window) $w
#@ }
#@ 
#@ # ::tk::CheckRadioDown --
#@ # The procedure below is invoked when the mouse button is pressed in
#@ # a button widget.  It records the fact that the mouse is in the button,
#@ # saves the button's relief so it can be restored later, and changes
#@ # the relief to sunken.
#@ #
#@ # Arguments:
#@ # w -		The name of the widget.
#@ 
#@ proc ::tk::CheckRadioDown w {
#@     variable ::tk::Priv
#@     if {![info exists Priv($w,relief)]} {
#@ 	set Priv($w,relief) [$w cget -relief]
#@     }
#@     if {[$w cget -state] ne "disabled"} {
#@ 	set Priv(buttonWindow) $w
#@ 	set Priv(repeated) 0
#@ 	$w configure -state active
#@     }
#@ }
#@ 
#@ }
#@ 
#@ if {[string equal "x11" [tk windowingsystem]]} {
#@ 
#@ #####################
#@ # Unix implementation
#@ #####################
#@ 
#@ # ::tk::ButtonEnter --
#@ # The procedure below is invoked when the mouse pointer enters a
#@ # button widget.  It records the button we're in and changes the
#@ # state of the button to active unless the button is disabled.
#@ #
#@ # Arguments:
#@ # w -		The name of the widget.
#@ 
#@ proc ::tk::ButtonEnter {w} {
#@     variable ::tk::Priv
#@     if {[$w cget -state] ne "disabled"} {
#@ 	# On unix the state is active just with mouse-over
#@ 	$w configure -state active
#@ 
#@ 	# If the mouse button is down, set the relief to sunken on entry.
#@ 	# Overwise, if there's an -overrelief value, set the relief to that.
#@ 
#@ 	set Priv($w,relief) [$w cget -relief]
#@ 	if {$Priv(buttonWindow) eq $w} {
#@ 	    $w configure -relief sunken
#@ 	    set Priv($w,prelief) sunken
#@ 	} elseif {[set over [$w cget -overrelief]] ne ""} {
#@ 	    $w configure -relief $over
#@ 	    set Priv($w,prelief) $over
#@ 	}
#@     }
#@     set Priv(window) $w
#@ }
#@ 
#@ # ::tk::ButtonLeave --
#@ # The procedure below is invoked when the mouse pointer leaves a
#@ # button widget.  It changes the state of the button back to inactive.
#@ # Restore any modified relief too.
#@ #
#@ # Arguments:
#@ # w -		The name of the widget.
#@ 
#@ proc ::tk::ButtonLeave w {
#@     variable ::tk::Priv
#@     if {[$w cget -state] ne "disabled"} {
#@ 	$w configure -state normal
#@     }
#@ 
#@     # Restore the original button relief if it was changed by Tk.
#@     # That is signaled by the existence of Priv($w,prelief).
#@ 
#@     if {[info exists Priv($w,relief)]} {
#@ 	if {[info exists Priv($w,prelief)] && 		$Priv($w,prelief) eq [$w cget -relief]} {
#@ 	    $w configure -relief $Priv($w,relief)
#@ 	}
#@ 	unset -nocomplain Priv($w,relief) Priv($w,prelief)
#@     }
#@ 
#@     set Priv(window) ""
#@ }
#@ 
#@ # ::tk::ButtonDown --
#@ # The procedure below is invoked when the mouse button is pressed in
#@ # a button widget.  It records the fact that the mouse is in the button,
#@ # saves the button's relief so it can be restored later, and changes
#@ # the relief to sunken.
#@ #
#@ # Arguments:
#@ # w -		The name of the widget.
#@ 
#@ proc ::tk::ButtonDown w {
#@     variable ::tk::Priv
#@ 
#@     # Only save the button's relief if it does not yet exist.  If there
#@     # is an overrelief setting, Priv($w,relief) will already have been set,
#@     # and the current value of the -relief option will be incorrect.
#@ 
#@     if {![info exists Priv($w,relief)]} {
#@ 	set Priv($w,relief) [$w cget -relief]
#@     }
#@ 
#@     if {[$w cget -state] ne "disabled"} {
#@ 	set Priv(buttonWindow) $w
#@ 	$w configure -relief sunken
#@ 	set Priv($w,prelief) sunken
#@ 
#@ 	# If this button has a repeatdelay set up, get it going with an after
#@ 	after cancel $Priv(afterId)
#@ 	set delay [$w cget -repeatdelay]
#@ 	set Priv(repeated) 0
#@ 	if {$delay > 0} {
#@ 	    set Priv(afterId) [after $delay [list tk::ButtonAutoInvoke $w]]
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::ButtonUp --
#@ # The procedure below is invoked when the mouse button is released
#@ # in a button widget.  It restores the button's relief and invokes
#@ # the command as long as the mouse hasn't left the button.
#@ #
#@ # Arguments:
#@ # w -		The name of the widget.
#@ 
#@ proc ::tk::ButtonUp w {
#@     variable ::tk::Priv
#@     if {[string equal $w $Priv(buttonWindow)]} {
#@ 	set Priv(buttonWindow) ""
#@ 
#@ 	# Restore the button's relief if it was cached.
#@ 
#@ 	if {[info exists Priv($w,relief)]} {
#@ 	    if {[info exists Priv($w,prelief)] && 		    $Priv($w,prelief) eq [$w cget -relief]} {
#@ 		$w configure -relief $Priv($w,relief)
#@ 	    }
#@ 	    unset -nocomplain Priv($w,relief) Priv($w,prelief)
#@ 	}
#@ 
#@ 	# Clean up the after event from the auto-repeater
#@ 	after cancel $Priv(afterId)
#@ 
#@ 	if {$Priv(window) eq $w && [$w cget -state] ne "disabled"} {
#@ 	    # Only invoke the command if it wasn't already invoked by the
#@ 	    # auto-repeater functionality
#@ 	    if { $Priv(repeated) == 0 } {
#@ 		uplevel #0 [list $w invoke]
#@ 	    }
#@ 	}
#@     }
#@ }
#@ 
#@ }
#@ 
#@ if {[string equal [tk windowingsystem] "classic"]
#@ 	|| [string equal [tk windowingsystem] "aqua"]} {
#@ 
#@ ####################
#@ # Mac implementation
#@ ####################
#@ 
#@ # ::tk::ButtonEnter --
#@ # The procedure below is invoked when the mouse pointer enters a
#@ # button widget.  It records the button we're in and changes the
#@ # state of the button to active unless the button is disabled.
#@ #
#@ # Arguments:
#@ # w -		The name of the widget.
#@ 
#@ proc ::tk::ButtonEnter {w} {
#@     variable ::tk::Priv
#@     if {[$w cget -state] ne "disabled"} {
#@ 
#@ 	# If there's an -overrelief value, set the relief to that.
#@ 
#@ 	if {$Priv(buttonWindow) eq $w} {
#@ 	    $w configure -state active
#@ 	} elseif {[set over [$w cget -overrelief]] ne ""} {
#@ 	    set Priv($w,relief)  [$w cget -relief]
#@ 	    set Priv($w,prelief) $over
#@ 	    $w configure -relief $over
#@ 	}
#@     }
#@     set Priv(window) $w
#@ }
#@ 
#@ # ::tk::ButtonLeave --
#@ # The procedure below is invoked when the mouse pointer leaves a
#@ # button widget.  It changes the state of the button back to
#@ # inactive.  If we're leaving the button window with a mouse button
#@ # pressed (Priv(buttonWindow) == $w), restore the relief of the
#@ # button too.
#@ #
#@ # Arguments:
#@ # w -		The name of the widget.
#@ 
#@ proc ::tk::ButtonLeave w {
#@     variable ::tk::Priv
#@     if {$w eq $Priv(buttonWindow)} {
#@ 	$w configure -state normal
#@     }
#@ 
#@     # Restore the original button relief if it was changed by Tk.
#@     # That is signaled by the existence of Priv($w,prelief).
#@ 
#@     if {[info exists Priv($w,relief)]} {
#@ 	if {[info exists Priv($w,prelief)] && 		$Priv($w,prelief) eq [$w cget -relief]} {
#@ 	    $w configure -relief $Priv($w,relief)
#@ 	}
#@ 	unset -nocomplain Priv($w,relief) Priv($w,prelief)
#@     }
#@ 
#@     set Priv(window) ""
#@ }
#@ 
#@ # ::tk::ButtonDown --
#@ # The procedure below is invoked when the mouse button is pressed in
#@ # a button widget.  It records the fact that the mouse is in the button,
#@ # saves the button's relief so it can be restored later, and changes
#@ # the relief to sunken.
#@ #
#@ # Arguments:
#@ # w -		The name of the widget.
#@ 
#@ proc ::tk::ButtonDown w {
#@     variable ::tk::Priv
#@ 
#@     if {[$w cget -state] ne "disabled"} {
#@ 	set Priv(buttonWindow) $w
#@ 	$w configure -state active
#@ 
#@ 	# If this button has a repeatdelay set up, get it going with an after
#@ 	after cancel $Priv(afterId)
#@ 	set Priv(repeated) 0
#@ 	if { ![catch {$w cget -repeatdelay} delay] } {
#@ 	    if {$delay > 0} {
#@ 		set Priv(afterId) [after $delay [list tk::ButtonAutoInvoke $w]]
#@ 	    }
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::ButtonUp --
#@ # The procedure below is invoked when the mouse button is released
#@ # in a button widget.  It restores the button's relief and invokes
#@ # the command as long as the mouse hasn't left the button.
#@ #
#@ # Arguments:
#@ # w -		The name of the widget.
#@ 
#@ proc ::tk::ButtonUp w {
#@     variable ::tk::Priv
#@     if {$Priv(buttonWindow) eq $w} {
#@ 	set Priv(buttonWindow) ""
#@ 	$w configure -state normal
#@ 
#@ 	# Restore the button's relief if it was cached.
#@ 
#@ 	if {[info exists Priv($w,relief)]} {
#@ 	    if {[info exists Priv($w,prelief)] && 		    $Priv($w,prelief) eq [$w cget -relief]} {
#@ 		$w configure -relief $Priv($w,relief)
#@ 	    }
#@ 	    unset -nocomplain Priv($w,relief) Priv($w,prelief)
#@ 	}
#@ 
#@ 	# Clean up the after event from the auto-repeater
#@ 	after cancel $Priv(afterId)
#@ 
#@ 	if {$Priv(window) eq $w && [$w cget -state] ne "disabled"} {
#@ 	    # Only invoke the command if it wasn't already invoked by the
#@ 	    # auto-repeater functionality
#@ 	    if { $Priv(repeated) == 0 } {
#@ 		uplevel #0 [list $w invoke]
#@ 	    }
#@ 	}
#@     }
#@ }
#@ 
#@ }
#@ 
#@ ##################
#@ # Shared routines
#@ ##################
#@ 
#@ # ::tk::ButtonInvoke --
#@ # The procedure below is called when a button is invoked through
#@ # the keyboard.  It simulate a press of the button via the mouse.
#@ #
#@ # Arguments:
#@ # w -		The name of the widget.
#@ 
#@ proc ::tk::ButtonInvoke w {
#@     if {[$w cget -state] ne "disabled"} {
#@ 	set oldRelief [$w cget -relief]
#@ 	set oldState [$w cget -state]
#@ 	$w configure -state active -relief sunken
#@ 	update idletasks
#@ 	after 100
#@ 	$w configure -state $oldState -relief $oldRelief
#@ 	uplevel #0 [list $w invoke]
#@     }
#@ }
#@ 
#@ # ::tk::ButtonAutoInvoke --
#@ #
#@ #	Invoke an auto-repeating button, and set it up to continue to repeat.
#@ #
#@ # Arguments:
#@ #	w	button to invoke.
#@ #
#@ # Results:
#@ #	None.
#@ #
#@ # Side effects:
#@ #	May create an after event to call ::tk::ButtonAutoInvoke.
#@ 
#@ proc ::tk::ButtonAutoInvoke {w} {
#@     variable ::tk::Priv
#@     after cancel $Priv(afterId)
#@     set delay [$w cget -repeatinterval]
#@     if {$Priv(window) eq $w} {
#@ 	incr Priv(repeated)
#@ 	uplevel #0 [list $w invoke]
#@     }
#@     if {$delay > 0} {
#@ 	set Priv(afterId) [after $delay [list tk::ButtonAutoInvoke $w]]
#@     }
#@ }
#@ 
#@ # ::tk::CheckRadioInvoke --
#@ # The procedure below is invoked when the mouse button is pressed in
#@ # a checkbutton or radiobutton widget, or when the widget is invoked
#@ # through the keyboard.  It invokes the widget if it
#@ # isn't disabled.
#@ #
#@ # Arguments:
#@ # w -		The name of the widget.
#@ # cmd -		The subcommand to invoke (one of invoke, select, or deselect).
#@ 
#@ proc ::tk::CheckRadioInvoke {w {cmd invoke}} {
#@     if {[$w cget -state] ne "disabled"} {
#@ 	uplevel #0 [list $w $cmd]
#@     }
#@ }
#@ # -- End source /usr/cad/synopsys/synthesis/cur/auxx/tcllib/lib/tk8.4/button.tcl

#@ # entry.tcl --
#@ #
#@ # This file defines the default bindings for Tk entry widgets and provides
#@ # procedures that help in implementing those bindings.
#@ #
#@ # RCS: @(#) $Id: //sde/tcl/tk8.4r/rel1/library/entry.tcl#1 $
#@ #
#@ # Copyright (c) 1992-1994 The Regents of the University of California.
#@ # Copyright (c) 1994-1997 Sun Microsystems, Inc.
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ #
#@ 
#@ #-------------------------------------------------------------------------
#@ # Elements of tk::Priv that are used in this file:
#@ #
#@ # afterId -		If non-null, it means that auto-scanning is underway
#@ #			and it gives the "after" id for the next auto-scan
#@ #			command to be executed.
#@ # mouseMoved -		Non-zero means the mouse has moved a significant
#@ #			amount since the button went down (so, for example,
#@ #			start dragging out a selection).
#@ # pressX -		X-coordinate at which the mouse button was pressed.
#@ # selectMode -		The style of selection currently underway:
#@ #			char, word, or line.
#@ # x, y -		Last known mouse coordinates for scanning
#@ #			and auto-scanning.
#@ # data -		Used for Cut and Copy
#@ #-------------------------------------------------------------------------
#@ 
#@ #-------------------------------------------------------------------------
#@ # The code below creates the default class bindings for entries.
#@ #-------------------------------------------------------------------------
#@ bind Entry <<Cut>> {
#@     if {![catch {tk::EntryGetSelection %W} tk::Priv(data)]} {
#@ 	clipboard clear -displayof %W
#@ 	clipboard append -displayof %W $tk::Priv(data)
#@ 	%W delete sel.first sel.last
#@ 	unset tk::Priv(data)
#@     }
#@ }
#@ bind Entry <<Copy>> {
#@     if {![catch {tk::EntryGetSelection %W} tk::Priv(data)]} {
#@ 	clipboard clear -displayof %W
#@ 	clipboard append -displayof %W $tk::Priv(data)
#@ 	unset tk::Priv(data)
#@     }
#@ }
#@ bind Entry <<Paste>> {
#@     global tcl_platform
#@     catch {
#@ 	if {[string compare [tk windowingsystem] "x11"]} {
#@ 	    catch {
#@ 		%W delete sel.first sel.last
#@ 	    }
#@ 	}
#@ 	%W insert insert [::tk::GetSelection %W CLIPBOARD]
#@ 	tk::EntrySeeInsert %W
#@     }
#@ }
#@ bind Entry <<Clear>> {
#@     %W delete sel.first sel.last
#@ }
#@ bind Entry <<PasteSelection>> {
#@     if {$tk_strictMotif || ![info exists tk::Priv(mouseMoved)]
#@ 	|| !$tk::Priv(mouseMoved)} {
#@ 	tk::EntryPaste %W %x
#@     }
#@ }
#@ 
#@ # Standard Motif bindings:
#@ 
#@ bind Entry <1> {
#@     tk::EntryButton1 %W %x
#@     %W selection clear
#@ }
#@ bind Entry <B1-Motion> {
#@     set tk::Priv(x) %x
#@     tk::EntryMouseSelect %W %x
#@ }
#@ bind Entry <Double-1> {
#@     set tk::Priv(selectMode) word
#@     tk::EntryMouseSelect %W %x
#@     catch {%W icursor sel.last}
#@ }
#@ bind Entry <Triple-1> {
#@     set tk::Priv(selectMode) line
#@     tk::EntryMouseSelect %W %x
#@     catch {%W icursor sel.last}
#@ }
#@ bind Entry <Shift-1> {
#@     set tk::Priv(selectMode) char
#@     %W selection adjust @%x
#@ }
#@ bind Entry <Double-Shift-1>	{
#@     set tk::Priv(selectMode) word
#@     tk::EntryMouseSelect %W %x
#@ }
#@ bind Entry <Triple-Shift-1>	{
#@     set tk::Priv(selectMode) line
#@     tk::EntryMouseSelect %W %x
#@ }
#@ bind Entry <B1-Leave> {
#@     set tk::Priv(x) %x
#@     tk::EntryAutoScan %W
#@ }
#@ bind Entry <B1-Enter> {
#@     tk::CancelRepeat
#@ }
#@ bind Entry <ButtonRelease-1> {
#@     tk::CancelRepeat
#@ }
#@ bind Entry <Control-1> {
#@     %W icursor @%x
#@ }
#@ 
#@ bind Entry <Left> {
#@     tk::EntrySetCursor %W [expr {[%W index insert] - 1}]
#@ }
#@ bind Entry <Right> {
#@     tk::EntrySetCursor %W [expr {[%W index insert] + 1}]
#@ }
#@ bind Entry <Shift-Left> {
#@     tk::EntryKeySelect %W [expr {[%W index insert] - 1}]
#@     tk::EntrySeeInsert %W
#@ }
#@ bind Entry <Shift-Right> {
#@     tk::EntryKeySelect %W [expr {[%W index insert] + 1}]
#@     tk::EntrySeeInsert %W
#@ }
#@ bind Entry <Control-Left> {
#@     tk::EntrySetCursor %W [tk::EntryPreviousWord %W insert]
#@ }
#@ bind Entry <Control-Right> {
#@     tk::EntrySetCursor %W [tk::EntryNextWord %W insert]
#@ }
#@ bind Entry <Shift-Control-Left> {
#@     tk::EntryKeySelect %W [tk::EntryPreviousWord %W insert]
#@     tk::EntrySeeInsert %W
#@ }
#@ bind Entry <Shift-Control-Right> {
#@     tk::EntryKeySelect %W [tk::EntryNextWord %W insert]
#@     tk::EntrySeeInsert %W
#@ }
#@ bind Entry <Home> {
#@     tk::EntrySetCursor %W 0
#@ }
#@ bind Entry <Shift-Home> {
#@     tk::EntryKeySelect %W 0
#@     tk::EntrySeeInsert %W
#@ }
#@ bind Entry <End> {
#@     tk::EntrySetCursor %W end
#@ }
#@ bind Entry <Shift-End> {
#@     tk::EntryKeySelect %W end
#@     tk::EntrySeeInsert %W
#@ }
#@ 
#@ bind Entry <Delete> {
#@     if {[%W selection present]} {
#@ 	%W delete sel.first sel.last
#@     } else {
#@ 	%W delete insert
#@     }
#@ }
#@ bind Entry <BackSpace> {
#@     tk::EntryBackspace %W
#@ }
#@ 
#@ bind Entry <Control-space> {
#@     %W selection from insert
#@ }
#@ bind Entry <Select> {
#@     %W selection from insert
#@ }
#@ bind Entry <Control-Shift-space> {
#@     %W selection adjust insert
#@ }
#@ bind Entry <Shift-Select> {
#@     %W selection adjust insert
#@ }
#@ bind Entry <Control-slash> {
#@     %W selection range 0 end
#@ }
#@ bind Entry <Control-backslash> {
#@     %W selection clear
#@ }
#@ bind Entry <KeyPress> {
#@     tk::CancelRepeat
#@     tk::EntryInsert %W %A
#@ }
#@ 
#@ # Ignore all Alt, Meta, and Control keypresses unless explicitly bound.
#@ # Otherwise, if a widget binding for one of these is defined, the
#@ # <KeyPress> class binding will also fire and insert the character,
#@ # which is wrong.  Ditto for Escape, Return, and Tab.
#@ 
#@ bind Entry <Alt-KeyPress> {# nothing}
#@ bind Entry <Meta-KeyPress> {# nothing}
#@ bind Entry <Control-KeyPress> {# nothing}
#@ bind Entry <Escape> {# nothing}
#@ bind Entry <Return> {# nothing}
#@ bind Entry <KP_Enter> {# nothing}
#@ bind Entry <Tab> {# nothing}
#@ if {[string equal [tk windowingsystem] "classic"]
#@ 	|| [string equal [tk windowingsystem] "aqua"]} {
#@ 	bind Entry <Command-KeyPress> {# nothing}
#@ }
#@ 
#@ # On Windows, paste is done using Shift-Insert.  Shift-Insert already
#@ # generates the <<Paste>> event, so we don't need to do anything here.
#@ if {[string compare $tcl_platform(platform) "windows"]} {
#@     bind Entry <Insert> {
#@ 	catch {tk::EntryInsert %W [::tk::GetSelection %W PRIMARY]}
#@     }
#@ }
#@ 
#@ # Additional emacs-like bindings:
#@ 
#@ bind Entry <Control-a> {
#@     if {!$tk_strictMotif} {
#@ 	tk::EntrySetCursor %W 0
#@     }
#@ }
#@ bind Entry <Control-b> {
#@     if {!$tk_strictMotif} {
#@ 	tk::EntrySetCursor %W [expr {[%W index insert] - 1}]
#@     }
#@ }
#@ bind Entry <Control-d> {
#@     if {!$tk_strictMotif} {
#@ 	%W delete insert
#@     }
#@ }
#@ bind Entry <Control-e> {
#@     if {!$tk_strictMotif} {
#@ 	tk::EntrySetCursor %W end
#@     }
#@ }
#@ bind Entry <Control-f> {
#@     if {!$tk_strictMotif} {
#@ 	tk::EntrySetCursor %W [expr {[%W index insert] + 1}]
#@     }
#@ }
#@ bind Entry <Control-h> {
#@     if {!$tk_strictMotif} {
#@ 	tk::EntryBackspace %W
#@     }
#@ }
#@ bind Entry <Control-k> {
#@     if {!$tk_strictMotif} {
#@ 	%W delete insert end
#@     }
#@ }
#@ bind Entry <Control-t> {
#@     if {!$tk_strictMotif} {
#@ 	tk::EntryTranspose %W
#@     }
#@ }
#@ bind Entry <Meta-b> {
#@     if {!$tk_strictMotif} {
#@ 	tk::EntrySetCursor %W [tk::EntryPreviousWord %W insert]
#@     }
#@ }
#@ bind Entry <Meta-d> {
#@     if {!$tk_strictMotif} {
#@ 	%W delete insert [tk::EntryNextWord %W insert]
#@     }
#@ }
#@ bind Entry <Meta-f> {
#@     if {!$tk_strictMotif} {
#@ 	tk::EntrySetCursor %W [tk::EntryNextWord %W insert]
#@     }
#@ }
#@ bind Entry <Meta-BackSpace> {
#@     if {!$tk_strictMotif} {
#@ 	%W delete [tk::EntryPreviousWord %W insert] insert
#@     }
#@ }
#@ bind Entry <Meta-Delete> {
#@     if {!$tk_strictMotif} {
#@ 	%W delete [tk::EntryPreviousWord %W insert] insert
#@     }
#@ }
#@ 
#@ # A few additional bindings of my own.
#@ 
#@ bind Entry <2> {
#@     if {!$tk_strictMotif} {
#@ 	::tk::EntryScanMark %W %x
#@     }
#@ }
#@ bind Entry <B2-Motion> {
#@     if {!$tk_strictMotif} {
#@ 	::tk::EntryScanDrag %W %x
#@     }
#@ }
#@ 
#@ # ::tk::EntryClosestGap --
#@ # Given x and y coordinates, this procedure finds the closest boundary
#@ # between characters to the given coordinates and returns the index
#@ # of the character just after the boundary.
#@ #
#@ # Arguments:
#@ # w -		The entry window.
#@ # x -		X-coordinate within the window.
#@ 
#@ proc ::tk::EntryClosestGap {w x} {
#@     set pos [$w index @$x]
#@     set bbox [$w bbox $pos]
#@     if {($x - [lindex $bbox 0]) < ([lindex $bbox 2]/2)} {
#@ 	return $pos
#@     }
#@     incr pos
#@ }
#@ 
#@ # ::tk::EntryButton1 --
#@ # This procedure is invoked to handle button-1 presses in entry
#@ # widgets.  It moves the insertion cursor, sets the selection anchor,
#@ # and claims the input focus.
#@ #
#@ # Arguments:
#@ # w -		The entry window in which the button was pressed.
#@ # x -		The x-coordinate of the button press.
#@ 
#@ proc ::tk::EntryButton1 {w x} {
#@     variable ::tk::Priv
#@ 
#@     set Priv(selectMode) char
#@     set Priv(mouseMoved) 0
#@     set Priv(pressX) $x
#@     $w icursor [EntryClosestGap $w $x]
#@     $w selection from insert
#@     if {[string compare "disabled" [$w cget -state]]} {focus $w}
#@ }
#@ 
#@ # ::tk::EntryMouseSelect --
#@ # This procedure is invoked when dragging out a selection with
#@ # the mouse.  Depending on the selection mode (character, word,
#@ # line) it selects in different-sized units.  This procedure
#@ # ignores mouse motions initially until the mouse has moved from
#@ # one character to another or until there have been multiple clicks.
#@ #
#@ # Arguments:
#@ # w -		The entry window in which the button was pressed.
#@ # x -		The x-coordinate of the mouse.
#@ 
#@ proc ::tk::EntryMouseSelect {w x} {
#@     variable ::tk::Priv
#@ 
#@     set cur [EntryClosestGap $w $x]
#@     set anchor [$w index anchor]
#@     if {($cur != $anchor) || (abs($Priv(pressX) - $x) >= 3)} {
#@ 	set Priv(mouseMoved) 1
#@     }
#@     switch $Priv(selectMode) {
#@ 	char {
#@ 	    if {$Priv(mouseMoved)} {
#@ 		if {$cur < $anchor} {
#@ 		    $w selection range $cur $anchor
#@ 		} elseif {$cur > $anchor} {
#@ 		    $w selection range $anchor $cur
#@ 		} else {
#@ 		    $w selection clear
#@ 		}
#@ 	    }
#@ 	}
#@ 	word {
#@ 	    if {$cur < [$w index anchor]} {
#@ 		set before [tcl_wordBreakBefore [$w get] $cur]
#@ 		set after [tcl_wordBreakAfter [$w get] [expr {$anchor-1}]]
#@ 	    } else {
#@ 		set before [tcl_wordBreakBefore [$w get] $anchor]
#@ 		set after [tcl_wordBreakAfter [$w get] [expr {$cur - 1}]]
#@ 	    }
#@ 	    if {$before < 0} {
#@ 		set before 0
#@ 	    }
#@ 	    if {$after < 0} {
#@ 		set after end
#@ 	    }
#@ 	    $w selection range $before $after
#@ 	}
#@ 	line {
#@ 	    $w selection range 0 end
#@ 	}
#@     }
#@     if {$Priv(mouseMoved)} {
#@         $w icursor $cur
#@     }
#@     update idletasks
#@ }
#@ 
#@ # ::tk::EntryPaste --
#@ # This procedure sets the insertion cursor to the current mouse position,
#@ # pastes the selection there, and sets the focus to the window.
#@ #
#@ # Arguments:
#@ # w -		The entry window.
#@ # x -		X position of the mouse.
#@ 
#@ proc ::tk::EntryPaste {w x} {
#@     $w icursor [EntryClosestGap $w $x]
#@     catch {$w insert insert [::tk::GetSelection $w PRIMARY]}
#@     if {[string compare "disabled" [$w cget -state]]} {focus $w}
#@ }
#@ 
#@ # ::tk::EntryAutoScan --
#@ # This procedure is invoked when the mouse leaves an entry window
#@ # with button 1 down.  It scrolls the window left or right,
#@ # depending on where the mouse is, and reschedules itself as an
#@ # "after" command so that the window continues to scroll until the
#@ # mouse moves back into the window or the mouse button is released.
#@ #
#@ # Arguments:
#@ # w -		The entry window.
#@ 
#@ proc ::tk::EntryAutoScan {w} {
#@     variable ::tk::Priv
#@     set x $Priv(x)
#@     if {![winfo exists $w]} return
#@     if {$x >= [winfo width $w]} {
#@ 	$w xview scroll 2 units
#@ 	EntryMouseSelect $w $x
#@     } elseif {$x < 0} {
#@ 	$w xview scroll -2 units
#@ 	EntryMouseSelect $w $x
#@     }
#@     set Priv(afterId) [after 50 [list tk::EntryAutoScan $w]]
#@ }
#@ 
#@ # ::tk::EntryKeySelect --
#@ # This procedure is invoked when stroking out selections using the
#@ # keyboard.  It moves the cursor to a new position, then extends
#@ # the selection to that position.
#@ #
#@ # Arguments:
#@ # w -		The entry window.
#@ # new -		A new position for the insertion cursor (the cursor hasn't
#@ #		actually been moved to this position yet).
#@ 
#@ proc ::tk::EntryKeySelect {w new} {
#@     if {![$w selection present]} {
#@ 	$w selection from insert
#@ 	$w selection to $new
#@     } else {
#@ 	$w selection adjust $new
#@     }
#@     $w icursor $new
#@ }
#@ 
#@ # ::tk::EntryInsert --
#@ # Insert a string into an entry at the point of the insertion cursor.
#@ # If there is a selection in the entry, and it covers the point of the
#@ # insertion cursor, then delete the selection before inserting.
#@ #
#@ # Arguments:
#@ # w -		The entry window in which to insert the string
#@ # s -		The string to insert (usually just a single character)
#@ 
#@ proc ::tk::EntryInsert {w s} {
#@     if {[string equal $s ""]} {
#@ 	return
#@     }
#@     catch {
#@ 	set insert [$w index insert]
#@ 	if {([$w index sel.first] <= $insert)
#@ 		&& ([$w index sel.last] >= $insert)} {
#@ 	    $w delete sel.first sel.last
#@ 	}
#@     }
#@     $w insert insert $s
#@     EntrySeeInsert $w
#@ }
#@ 
#@ # ::tk::EntryBackspace --
#@ # Backspace over the character just before the insertion cursor.
#@ # If backspacing would move the cursor off the left edge of the
#@ # window, reposition the cursor at about the middle of the window.
#@ #
#@ # Arguments:
#@ # w -		The entry window in which to backspace.
#@ 
#@ proc ::tk::EntryBackspace w {
#@     if {[$w selection present]} {
#@ 	$w delete sel.first sel.last
#@     } else {
#@ 	set x [expr {[$w index insert] - 1}]
#@ 	if {$x >= 0} {$w delete $x}
#@ 	if {[$w index @0] >= [$w index insert]} {
#@ 	    set range [$w xview]
#@ 	    set left [lindex $range 0]
#@ 	    set right [lindex $range 1]
#@ 	    $w xview moveto [expr {$left - ($right - $left)/2.0}]
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::EntrySeeInsert --
#@ # Make sure that the insertion cursor is visible in the entry window.
#@ # If not, adjust the view so that it is.
#@ #
#@ # Arguments:
#@ # w -		The entry window.
#@ 
#@ proc ::tk::EntrySeeInsert w {
#@     set c [$w index insert]
#@     if {($c < [$w index @0]) || ($c > [$w index @[winfo width $w]])} {
#@ 	$w xview $c
#@     }
#@ }
#@ 
#@ # ::tk::EntrySetCursor -
#@ # Move the insertion cursor to a given position in an entry.  Also
#@ # clears the selection, if there is one in the entry, and makes sure
#@ # that the insertion cursor is visible.
#@ #
#@ # Arguments:
#@ # w -		The entry window.
#@ # pos -		The desired new position for the cursor in the window.
#@ 
#@ proc ::tk::EntrySetCursor {w pos} {
#@     $w icursor $pos
#@     $w selection clear
#@     EntrySeeInsert $w
#@ }
#@ 
#@ # ::tk::EntryTranspose -
#@ # This procedure implements the "transpose" function for entry widgets.
#@ # It tranposes the characters on either side of the insertion cursor,
#@ # unless the cursor is at the end of the line.  In this case it
#@ # transposes the two characters to the left of the cursor.  In either
#@ # case, the cursor ends up to the right of the transposed characters.
#@ #
#@ # Arguments:
#@ # w -		The entry window.
#@ 
#@ proc ::tk::EntryTranspose w {
#@     set i [$w index insert]
#@     if {$i < [$w index end]} {
#@ 	incr i
#@     }
#@     set first [expr {$i-2}]
#@     if {$first < 0} {
#@ 	return
#@     }
#@     set data [$w get]
#@     set new [string index $data [expr {$i-1}]][string index $data $first]
#@     $w delete $first $i
#@     $w insert insert $new
#@     EntrySeeInsert $w
#@ }
#@ 
#@ # ::tk::EntryNextWord --
#@ # Returns the index of the next word position after a given position in the
#@ # entry.  The next word is platform dependent and may be either the next
#@ # end-of-word position or the next start-of-word position after the next
#@ # end-of-word position.
#@ #
#@ # Arguments:
#@ # w -		The entry window in which the cursor is to move.
#@ # start -	Position at which to start search.
#@ 
#@ if {[string equal $tcl_platform(platform) "windows"]}  {
#@     proc ::tk::EntryNextWord {w start} {
#@ 	set pos [tcl_endOfWord [$w get] [$w index $start]]
#@ 	if {$pos >= 0} {
#@ 	    set pos [tcl_startOfNextWord [$w get] $pos]
#@ 	}
#@ 	if {$pos < 0} {
#@ 	    return end
#@ 	}
#@ 	return $pos
#@     }
#@ } else {
#@     proc ::tk::EntryNextWord {w start} {
#@ 	set pos [tcl_endOfWord [$w get] [$w index $start]]
#@ 	if {$pos < 0} {
#@ 	    return end
#@ 	}
#@ 	return $pos
#@     }
#@ }
#@ 
#@ # ::tk::EntryPreviousWord --
#@ #
#@ # Returns the index of the previous word position before a given
#@ # position in the entry.
#@ #
#@ # Arguments:
#@ # w -		The entry window in which the cursor is to move.
#@ # start -	Position at which to start search.
#@ 
#@ proc ::tk::EntryPreviousWord {w start} {
#@     set pos [tcl_startOfPreviousWord [$w get] [$w index $start]]
#@     if {$pos < 0} {
#@ 	return 0
#@     }
#@     return $pos
#@ }
#@ 
#@ # ::tk::EntryScanMark --
#@ #
#@ # Marks the start of a possible scan drag operation
#@ #
#@ # Arguments:
#@ # w -	The entry window from which the text to get
#@ # x -	x location on screen
#@ 
#@ proc ::tk::EntryScanMark {w x} {
#@     $w scan mark $x
#@     set ::tk::Priv(x) $x
#@     set ::tk::Priv(y) 0 ; # not used
#@     set ::tk::Priv(mouseMoved) 0
#@ }
#@ 
#@ # ::tk::EntryScanDrag --
#@ #
#@ # Marks the start of a possible scan drag operation
#@ #
#@ # Arguments:
#@ # w -	The entry window from which the text to get
#@ # x -	x location on screen
#@ 
#@ proc ::tk::EntryScanDrag {w x} {
#@     # Make sure these exist, as some weird situations can trigger the
#@     # motion binding without the initial press.  [Bug #220269]
#@     if {![info exists ::tk::Priv(x)]} { set ::tk::Priv(x) $x }
#@     # allow for a delta
#@     if {abs($x-$::tk::Priv(x)) > 2} {
#@ 	set ::tk::Priv(mouseMoved) 1
#@     }
#@     $w scan dragto $x
#@ }
#@ 
#@ # ::tk::EntryGetSelection --
#@ #
#@ # Returns the selected text of the entry with respect to the -show option.
#@ #
#@ # Arguments:
#@ # w -         The entry window from which the text to get
#@ 
#@ proc ::tk::EntryGetSelection {w} {
#@     set entryString [string range [$w get] [$w index sel.first] 	    [expr {[$w index sel.last] - 1}]]
#@     if {[string compare [$w cget -show] ""]} {
#@ 	return [string repeat [string index [$w cget -show] 0] 		[string length $entryString]]
#@     }
#@     return $entryString
#@ }
#@ # -- End source /usr/cad/synopsys/synthesis/cur/auxx/tcllib/lib/tk8.4/entry.tcl

#@ # listbox.tcl --
#@ #
#@ # This file defines the default bindings for Tk listbox widgets
#@ # and provides procedures that help in implementing those bindings.
#@ #
#@ # RCS: @(#) $Id: //sde/tcl/tk8.4r/rel1/library/listbox.tcl#1 $
#@ #
#@ # Copyright (c) 1994 The Regents of the University of California.
#@ # Copyright (c) 1994-1995 Sun Microsystems, Inc.
#@ # Copyright (c) 1998 by Scriptics Corporation.
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ 
#@ #--------------------------------------------------------------------------
#@ # tk::Priv elements used in this file:
#@ #
#@ # afterId -		Token returned by "after" for autoscanning.
#@ # listboxPrev -		The last element to be selected or deselected
#@ #			during a selection operation.
#@ # listboxSelection -	All of the items that were selected before the
#@ #			current selection operation (such as a mouse
#@ #			drag) started;  used to cancel an operation.
#@ #--------------------------------------------------------------------------
#@ 
#@ #-------------------------------------------------------------------------
#@ # The code below creates the default class bindings for listboxes.
#@ #-------------------------------------------------------------------------
#@ 
#@ # Note: the check for existence of %W below is because this binding
#@ # is sometimes invoked after a window has been deleted (e.g. because
#@ # there is a double-click binding on the widget that deletes it).  Users
#@ # can put "break"s in their bindings to avoid the error, but this check
#@ # makes that unnecessary.
#@ 
#@ bind Listbox <1> {
#@     if {[winfo exists %W]} {
#@ 	tk::ListboxBeginSelect %W [%W index @%x,%y]
#@     }
#@ }
#@ 
#@ # Ignore double clicks so that users can define their own behaviors.
#@ # Among other things, this prevents errors if the user deletes the
#@ # listbox on a double click.
#@ 
#@ bind Listbox <Double-1> {
#@     # Empty script
#@ }
#@ 
#@ bind Listbox <B1-Motion> {
#@     set tk::Priv(x) %x
#@     set tk::Priv(y) %y
#@     tk::ListboxMotion %W [%W index @%x,%y]
#@ }
#@ bind Listbox <ButtonRelease-1> {
#@     tk::CancelRepeat
#@     %W activate @%x,%y
#@ }
#@ bind Listbox <Shift-1> {
#@     tk::ListboxBeginExtend %W [%W index @%x,%y]
#@ }
#@ bind Listbox <Control-1> {
#@     tk::ListboxBeginToggle %W [%W index @%x,%y]
#@ }
#@ bind Listbox <B1-Leave> {
#@     set tk::Priv(x) %x
#@     set tk::Priv(y) %y
#@     tk::ListboxAutoScan %W
#@ }
#@ bind Listbox <B1-Enter> {
#@     tk::CancelRepeat
#@ }
#@ 
#@ bind Listbox <Up> {
#@     tk::ListboxUpDown %W -1
#@ }
#@ bind Listbox <Shift-Up> {
#@     tk::ListboxExtendUpDown %W -1
#@ }
#@ bind Listbox <Down> {
#@     tk::ListboxUpDown %W 1
#@ }
#@ bind Listbox <Shift-Down> {
#@     tk::ListboxExtendUpDown %W 1
#@ }
#@ bind Listbox <Left> {
#@     %W xview scroll -1 units
#@ }
#@ bind Listbox <Control-Left> {
#@     %W xview scroll -1 pages
#@ }
#@ bind Listbox <Right> {
#@     %W xview scroll 1 units
#@ }
#@ bind Listbox <Control-Right> {
#@     %W xview scroll 1 pages
#@ }
#@ bind Listbox <Prior> {
#@     %W yview scroll -1 pages
#@     %W activate @0,0
#@ }
#@ bind Listbox <Next> {
#@     %W yview scroll 1 pages
#@     %W activate @0,0
#@ }
#@ bind Listbox <Control-Prior> {
#@     %W xview scroll -1 pages
#@ }
#@ bind Listbox <Control-Next> {
#@     %W xview scroll 1 pages
#@ }
#@ bind Listbox <Home> {
#@     %W xview moveto 0
#@ }
#@ bind Listbox <End> {
#@     %W xview moveto 1
#@ }
#@ bind Listbox <Control-Home> {
#@     %W activate 0
#@     %W see 0
#@     %W selection clear 0 end
#@     %W selection set 0
#@     event generate %W <<ListboxSelect>>
#@ }
#@ bind Listbox <Shift-Control-Home> {
#@     tk::ListboxDataExtend %W 0
#@ }
#@ bind Listbox <Control-End> {
#@     %W activate end
#@     %W see end
#@     %W selection clear 0 end
#@     %W selection set end
#@     event generate %W <<ListboxSelect>>
#@ }
#@ bind Listbox <Shift-Control-End> {
#@     tk::ListboxDataExtend %W [%W index end]
#@ }
#@ bind Listbox <<Copy>> {
#@     if {[string equal [selection own -displayof %W] "%W"]} {
#@ 	clipboard clear -displayof %W
#@ 	clipboard append -displayof %W [selection get -displayof %W]
#@     }
#@ }
#@ bind Listbox <space> {
#@     tk::ListboxBeginSelect %W [%W index active]
#@ }
#@ bind Listbox <Select> {
#@     tk::ListboxBeginSelect %W [%W index active]
#@ }
#@ bind Listbox <Control-Shift-space> {
#@     tk::ListboxBeginExtend %W [%W index active]
#@ }
#@ bind Listbox <Shift-Select> {
#@     tk::ListboxBeginExtend %W [%W index active]
#@ }
#@ bind Listbox <Escape> {
#@     tk::ListboxCancel %W
#@ }
#@ bind Listbox <Control-slash> {
#@     tk::ListboxSelectAll %W
#@ }
#@ bind Listbox <Control-backslash> {
#@     if {[string compare [%W cget -selectmode] "browse"]} {
#@ 	%W selection clear 0 end
#@ 	event generate %W <<ListboxSelect>>
#@     }
#@ }
#@ 
#@ # Additional Tk bindings that aren't part of the Motif look and feel:
#@ 
#@ bind Listbox <2> {
#@     %W scan mark %x %y
#@ }
#@ bind Listbox <B2-Motion> {
#@     %W scan dragto %x %y
#@ }
#@ 
#@ # The MouseWheel will typically only fire on Windows.  However,
#@ # someone could use the "event generate" command to produce one
#@ # on other platforms.
#@ 
#@ bind Listbox <MouseWheel> {
#@     %W yview scroll [expr {- (%D / 120) * 4}] units
#@ }
#@ 
#@ if {[string equal "x11" [tk windowingsystem]]} {
#@     # Support for mousewheels on Linux/Unix commonly comes through mapping
#@     # the wheel to the extended buttons.  If you have a mousewheel, find
#@     # Linux configuration info at:
#@     #	http://www.inria.fr/koala/colas/mouse-wheel-scroll/
#@     bind Listbox <4> {
#@ 	if {!$tk_strictMotif} {
#@ 	    %W yview scroll -5 units
#@ 	}
#@     }
#@     bind Listbox <5> {
#@ 	if {!$tk_strictMotif} {
#@ 	    %W yview scroll 5 units
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::ListboxBeginSelect --
#@ #
#@ # This procedure is typically invoked on button-1 presses.  It begins
#@ # the process of making a selection in the listbox.  Its exact behavior
#@ # depends on the selection mode currently in effect for the listbox;
#@ # see the Motif documentation for details.
#@ #
#@ # Arguments:
#@ # w -		The listbox widget.
#@ # el -		The element for the selection operation (typically the
#@ #		one under the pointer).  Must be in numerical form.
#@ 
#@ proc ::tk::ListboxBeginSelect {w el} {
#@     variable ::tk::Priv
#@     if {[string equal [$w cget -selectmode] "multiple"]} {
#@ 	if {[$w selection includes $el]} {
#@ 	    $w selection clear $el
#@ 	} else {
#@ 	    $w selection set $el
#@ 	}
#@     } else {
#@ 	$w selection clear 0 end
#@ 	$w selection set $el
#@ 	$w selection anchor $el
#@ 	set Priv(listboxSelection) {}
#@ 	set Priv(listboxPrev) $el
#@     }
#@     event generate $w <<ListboxSelect>>
#@ }
#@ 
#@ # ::tk::ListboxMotion --
#@ #
#@ # This procedure is called to process mouse motion events while
#@ # button 1 is down.  It may move or extend the selection, depending
#@ # on the listbox's selection mode.
#@ #
#@ # Arguments:
#@ # w -		The listbox widget.
#@ # el -		The element under the pointer (must be a number).
#@ 
#@ proc ::tk::ListboxMotion {w el} {
#@     variable ::tk::Priv
#@     if {$el == $Priv(listboxPrev)} {
#@ 	return
#@     }
#@     set anchor [$w index anchor]
#@     switch [$w cget -selectmode] {
#@ 	browse {
#@ 	    $w selection clear 0 end
#@ 	    $w selection set $el
#@ 	    set Priv(listboxPrev) $el
#@ 	    event generate $w <<ListboxSelect>>
#@ 	}
#@ 	extended {
#@ 	    set i $Priv(listboxPrev)
#@ 	    if {[string equal {} $i]} {
#@ 		set i $el
#@ 		$w selection set $el
#@ 	    }
#@ 	    if {[$w selection includes anchor]} {
#@ 		$w selection clear $i $el
#@ 		$w selection set anchor $el
#@ 	    } else {
#@ 		$w selection clear $i $el
#@ 		$w selection clear anchor $el
#@ 	    }
#@ 	    if {![info exists Priv(listboxSelection)]} {
#@ 		set Priv(listboxSelection) [$w curselection]
#@ 	    }
#@ 	    while {($i < $el) && ($i < $anchor)} {
#@ 		if {[lsearch $Priv(listboxSelection) $i] >= 0} {
#@ 		    $w selection set $i
#@ 		}
#@ 		incr i
#@ 	    }
#@ 	    while {($i > $el) && ($i > $anchor)} {
#@ 		if {[lsearch $Priv(listboxSelection) $i] >= 0} {
#@ 		    $w selection set $i
#@ 		}
#@ 		incr i -1
#@ 	    }
#@ 	    set Priv(listboxPrev) $el
#@ 	    event generate $w <<ListboxSelect>>
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::ListboxBeginExtend --
#@ #
#@ # This procedure is typically invoked on shift-button-1 presses.  It
#@ # begins the process of extending a selection in the listbox.  Its
#@ # exact behavior depends on the selection mode currently in effect
#@ # for the listbox;  see the Motif documentation for details.
#@ #
#@ # Arguments:
#@ # w -		The listbox widget.
#@ # el -		The element for the selection operation (typically the
#@ #		one under the pointer).  Must be in numerical form.
#@ 
#@ proc ::tk::ListboxBeginExtend {w el} {
#@     if {[string equal [$w cget -selectmode] "extended"]} {
#@ 	if {[$w selection includes anchor]} {
#@ 	    ListboxMotion $w $el
#@ 	} else {
#@ 	    # No selection yet; simulate the begin-select operation.
#@ 	    ListboxBeginSelect $w $el
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::ListboxBeginToggle --
#@ #
#@ # This procedure is typically invoked on control-button-1 presses.  It
#@ # begins the process of toggling a selection in the listbox.  Its
#@ # exact behavior depends on the selection mode currently in effect
#@ # for the listbox;  see the Motif documentation for details.
#@ #
#@ # Arguments:
#@ # w -		The listbox widget.
#@ # el -		The element for the selection operation (typically the
#@ #		one under the pointer).  Must be in numerical form.
#@ 
#@ proc ::tk::ListboxBeginToggle {w el} {
#@     variable ::tk::Priv
#@     if {[string equal [$w cget -selectmode] "extended"]} {
#@ 	set Priv(listboxSelection) [$w curselection]
#@ 	set Priv(listboxPrev) $el
#@ 	$w selection anchor $el
#@ 	if {[$w selection includes $el]} {
#@ 	    $w selection clear $el
#@ 	} else {
#@ 	    $w selection set $el
#@ 	}
#@ 	event generate $w <<ListboxSelect>>
#@     }
#@ }
#@ 
#@ # ::tk::ListboxAutoScan --
#@ # This procedure is invoked when the mouse leaves an entry window
#@ # with button 1 down.  It scrolls the window up, down, left, or
#@ # right, depending on where the mouse left the window, and reschedules
#@ # itself as an "after" command so that the window continues to scroll until
#@ # the mouse moves back into the window or the mouse button is released.
#@ #
#@ # Arguments:
#@ # w -		The entry window.
#@ 
#@ proc ::tk::ListboxAutoScan {w} {
#@     variable ::tk::Priv
#@     if {![winfo exists $w]} return
#@     set x $Priv(x)
#@     set y $Priv(y)
#@     if {$y >= [winfo height $w]} {
#@ 	$w yview scroll 1 units
#@     } elseif {$y < 0} {
#@ 	$w yview scroll -1 units
#@     } elseif {$x >= [winfo width $w]} {
#@ 	$w xview scroll 2 units
#@     } elseif {$x < 0} {
#@ 	$w xview scroll -2 units
#@     } else {
#@ 	return
#@     }
#@     ListboxMotion $w [$w index @$x,$y]
#@     set Priv(afterId) [after 50 [list tk::ListboxAutoScan $w]]
#@ }
#@ 
#@ # ::tk::ListboxUpDown --
#@ #
#@ # Moves the location cursor (active element) up or down by one element,
#@ # and changes the selection if we're in browse or extended selection
#@ # mode.
#@ #
#@ # Arguments:
#@ # w -		The listbox widget.
#@ # amount -	+1 to move down one item, -1 to move back one item.
#@ 
#@ proc ::tk::ListboxUpDown {w amount} {
#@     variable ::tk::Priv
#@     $w activate [expr {[$w index active] + $amount}]
#@     $w see active
#@     switch [$w cget -selectmode] {
#@ 	browse {
#@ 	    $w selection clear 0 end
#@ 	    $w selection set active
#@ 	    event generate $w <<ListboxSelect>>
#@ 	}
#@ 	extended {
#@ 	    $w selection clear 0 end
#@ 	    $w selection set active
#@ 	    $w selection anchor active
#@ 	    set Priv(listboxPrev) [$w index active]
#@ 	    set Priv(listboxSelection) {}
#@ 	    event generate $w <<ListboxSelect>>
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::ListboxExtendUpDown --
#@ #
#@ # Does nothing unless we're in extended selection mode;  in this
#@ # case it moves the location cursor (active element) up or down by
#@ # one element, and extends the selection to that point.
#@ #
#@ # Arguments:
#@ # w -		The listbox widget.
#@ # amount -	+1 to move down one item, -1 to move back one item.
#@ 
#@ proc ::tk::ListboxExtendUpDown {w amount} {
#@     variable ::tk::Priv
#@     if {[string compare [$w cget -selectmode] "extended"]} {
#@ 	return
#@     }
#@     set active [$w index active]
#@     if {![info exists Priv(listboxSelection)]} {
#@ 	$w selection set $active
#@ 	set Priv(listboxSelection) [$w curselection]
#@     }
#@     $w activate [expr {$active + $amount}]
#@     $w see active
#@     ListboxMotion $w [$w index active]
#@ }
#@ 
#@ # ::tk::ListboxDataExtend
#@ #
#@ # This procedure is called for key-presses such as Shift-KEndData.
#@ # If the selection mode isn't multiple or extend then it does nothing.
#@ # Otherwise it moves the active element to el and, if we're in
#@ # extended mode, extends the selection to that point.
#@ #
#@ # Arguments:
#@ # w -		The listbox widget.
#@ # el -		An integer element number.
#@ 
#@ proc ::tk::ListboxDataExtend {w el} {
#@     set mode [$w cget -selectmode]
#@     if {[string equal $mode "extended"]} {
#@ 	$w activate $el
#@ 	$w see $el
#@         if {[$w selection includes anchor]} {
#@ 	    ListboxMotion $w $el
#@ 	}
#@     } elseif {[string equal $mode "multiple"]} {
#@ 	$w activate $el
#@ 	$w see $el
#@     }
#@ }
#@ 
#@ # ::tk::ListboxCancel
#@ #
#@ # This procedure is invoked to cancel an extended selection in
#@ # progress.  If there is an extended selection in progress, it
#@ # restores all of the items between the active one and the anchor
#@ # to their previous selection state.
#@ #
#@ # Arguments:
#@ # w -		The listbox widget.
#@ 
#@ proc ::tk::ListboxCancel w {
#@     variable ::tk::Priv
#@     if {[string compare [$w cget -selectmode] "extended"]} {
#@ 	return
#@     }
#@     set first [$w index anchor]
#@     set last $Priv(listboxPrev)
#@     if { [string equal $last ""] } {
#@ 	# Not actually doing any selection right now
#@ 	return
#@     }
#@     if {$first > $last} {
#@ 	set tmp $first
#@ 	set first $last
#@ 	set last $tmp
#@     }
#@     $w selection clear $first $last
#@     while {$first <= $last} {
#@ 	if {[lsearch $Priv(listboxSelection) $first] >= 0} {
#@ 	    $w selection set $first
#@ 	}
#@ 	incr first
#@     }
#@     event generate $w <<ListboxSelect>>
#@ }
#@ 
#@ # ::tk::ListboxSelectAll
#@ #
#@ # This procedure is invoked to handle the "select all" operation.
#@ # For single and browse mode, it just selects the active element.
#@ # Otherwise it selects everything in the widget.
#@ #
#@ # Arguments:
#@ # w -		The listbox widget.
#@ 
#@ proc ::tk::ListboxSelectAll w {
#@     set mode [$w cget -selectmode]
#@     if {[string equal $mode "single"] || [string equal $mode "browse"]} {
#@ 	$w selection clear 0 end
#@ 	$w selection set active
#@     } else {
#@ 	$w selection set 0 end
#@     }
#@     event generate $w <<ListboxSelect>>
#@ }
#@ # -- End source /usr/cad/synopsys/synthesis/cur/auxx/tcllib/lib/tk8.4/listbox.tcl

#@ # menu.tcl --
#@ #
#@ # This file defines the default bindings for Tk menus and menubuttons.
#@ # It also implements keyboard traversal of menus and implements a few
#@ # other utility procedures related to menus.
#@ #
#@ # RCS: @(#) $Id: //sde/tcl/tk8.4r/rel1/library/menu.tcl#1 $
#@ #
#@ # Copyright (c) 1992-1994 The Regents of the University of California.
#@ # Copyright (c) 1994-1997 Sun Microsystems, Inc.
#@ # Copyright (c) 1998-1999 by Scriptics Corporation.
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ #
#@ 
#@ #-------------------------------------------------------------------------
#@ # Elements of tk::Priv that are used in this file:
#@ #
#@ # cursor -		Saves the -cursor option for the posted menubutton.
#@ # focus -		Saves the focus during a menu selection operation.
#@ #			Focus gets restored here when the menu is unposted.
#@ # grabGlobal -		Used in conjunction with tk::Priv(oldGrab):  if
#@ #			tk::Priv(oldGrab) is non-empty, then tk::Priv(grabGlobal)
#@ #			contains either an empty string or "-global" to
#@ #			indicate whether the old grab was a local one or
#@ #			a global one.
#@ # inMenubutton -	The name of the menubutton widget containing
#@ #			the mouse, or an empty string if the mouse is
#@ #			not over any menubutton.
#@ # menuBar -		The name of the menubar that is the root
#@ #			of the cascade hierarchy which is currently
#@ #			posted. This is null when there is no menu currently
#@ #			being pulled down from a menu bar.
#@ # oldGrab -		Window that had the grab before a menu was posted.
#@ #			Used to restore the grab state after the menu
#@ #			is unposted.  Empty string means there was no
#@ #			grab previously set.
#@ # popup -		If a menu has been popped up via tk_popup, this
#@ #			gives the name of the menu.  Otherwise this
#@ #			value is empty.
#@ # postedMb -		Name of the menubutton whose menu is currently
#@ #			posted, or an empty string if nothing is posted
#@ #			A grab is set on this widget.
#@ # relief -		Used to save the original relief of the current
#@ #			menubutton.
#@ # window -		When the mouse is over a menu, this holds the
#@ #			name of the menu;  it's cleared when the mouse
#@ #			leaves the menu.
#@ # tearoff -		Whether the last menu posted was a tearoff or not.
#@ #			This is true always for unix, for tearoffs for Mac
#@ #			and Windows.
#@ # activeMenu -		This is the last active menu for use
#@ #			with the <<MenuSelect>> virtual event.
#@ # activeItem -		This is the last active menu item for
#@ #			use with the <<MenuSelect>> virtual event.
#@ #-------------------------------------------------------------------------
#@ 
#@ #-------------------------------------------------------------------------
#@ # Overall note:
#@ # This file is tricky because there are five different ways that menus
#@ # can be used:
#@ #
#@ # 1. As a pulldown from a menubutton. In this style, the variable 
#@ #    tk::Priv(postedMb) identifies the posted menubutton.
#@ # 2. As a torn-off menu copied from some other menu.  In this style
#@ #    tk::Priv(postedMb) is empty, and menu's type is "tearoff".
#@ # 3. As an option menu, triggered from an option menubutton.  In this
#@ #    style tk::Priv(postedMb) identifies the posted menubutton.
#@ # 4. As a popup menu.  In this style tk::Priv(postedMb) is empty and
#@ #    the top-level menu's type is "normal".
#@ # 5. As a pulldown from a menubar. The variable tk::Priv(menubar) has
#@ #    the owning menubar, and the menu itself is of type "normal".
#@ #
#@ # The various binding procedures use the  state described above to
#@ # distinguish the various cases and take different actions in each
#@ # case.
#@ #-------------------------------------------------------------------------
#@ 
#@ #-------------------------------------------------------------------------
#@ # The code below creates the default class bindings for menus
#@ # and menubuttons.
#@ #-------------------------------------------------------------------------
#@ 
#@ bind Menubutton <FocusIn> {}
#@ bind Menubutton <Enter> {
#@     tk::MbEnter %W
#@ }
#@ bind Menubutton <Leave> {
#@     tk::MbLeave %W
#@ }
#@ bind Menubutton <1> {
#@     if {$tk::Priv(inMenubutton) ne ""} {
#@ 	tk::MbPost $tk::Priv(inMenubutton) %X %Y
#@     }
#@ }
#@ bind Menubutton <Motion> {
#@     tk::MbMotion %W up %X %Y
#@ }
#@ bind Menubutton <B1-Motion> {
#@     tk::MbMotion %W down %X %Y
#@ }
#@ bind Menubutton <ButtonRelease-1> {
#@     tk::MbButtonUp %W
#@ }
#@ bind Menubutton <space> {
#@     tk::MbPost %W
#@     tk::MenuFirstEntry [%W cget -menu]
#@ }
#@ 
#@ # Must set focus when mouse enters a menu, in order to allow
#@ # mixed-mode processing using both the mouse and the keyboard.
#@ # Don't set the focus if the event comes from a grab release,
#@ # though:  such an event can happen after as part of unposting
#@ # a cascaded chain of menus, after the focus has already been
#@ # restored to wherever it was before menu selection started.
#@ 
#@ bind Menu <FocusIn> {}
#@ 
#@ bind Menu <Enter> {
#@     set tk::Priv(window) %W
#@     if {[%W cget -type] eq "tearoff"} {
#@ 	if {"%m" ne "NotifyUngrab"} {
#@ 	    if {[tk windowingsystem] eq "x11"} {
#@ 		tk_menuSetFocus %W
#@ 	    }
#@ 	}
#@     }
#@     tk::MenuMotion %W %x %y %s
#@ }
#@ 
#@ bind Menu <Leave> {
#@     tk::MenuLeave %W %X %Y %s
#@ }
#@ bind Menu <Motion> {
#@     tk::MenuMotion %W %x %y %s
#@ }
#@ bind Menu <ButtonPress> {
#@     tk::MenuButtonDown %W
#@ }
#@ bind Menu <ButtonRelease> {
#@    tk::MenuInvoke %W 1
#@ }
#@ bind Menu <space> {
#@     tk::MenuInvoke %W 0
#@ }
#@ bind Menu <Return> {
#@     tk::MenuInvoke %W 0
#@ }
#@ bind Menu <Escape> {
#@     tk::MenuEscape %W
#@ }
#@ bind Menu <Left> {
#@     tk::MenuLeftArrow %W
#@ }
#@ bind Menu <Right> {
#@     tk::MenuRightArrow %W
#@ }
#@ bind Menu <Up> {
#@     tk::MenuUpArrow %W
#@ }
#@ bind Menu <Down> {
#@     tk::MenuDownArrow %W
#@ }
#@ bind Menu <KeyPress> {
#@     tk::TraverseWithinMenu %W %A
#@ }
#@ 
#@ # The following bindings apply to all windows, and are used to
#@ # implement keyboard menu traversal.
#@ 
#@ if {[string equal [tk windowingsystem] "x11"]} {
#@     bind all <Alt-KeyPress> {
#@ 	tk::TraverseToMenu %W %A
#@     }
#@ 
#@     bind all <F10> {
#@ 	tk::FirstMenu %W
#@     }
#@ } else {
#@     bind Menubutton <Alt-KeyPress> {
#@ 	tk::TraverseToMenu %W %A
#@     }
#@ 
#@     bind Menubutton <F10> {
#@ 	tk::FirstMenu %W
#@     }
#@ }
#@ 
#@ # ::tk::MbEnter --
#@ # This procedure is invoked when the mouse enters a menubutton
#@ # widget.  It activates the widget unless it is disabled.  Note:
#@ # this procedure is only invoked when mouse button 1 is *not* down.
#@ # The procedure ::tk::MbB1Enter is invoked if the button is down.
#@ #
#@ # Arguments:
#@ # w -			The  name of the widget.
#@ 
#@ proc ::tk::MbEnter w {
#@     variable ::tk::Priv
#@ 
#@     if {[string compare $Priv(inMenubutton) ""]} {
#@ 	MbLeave $Priv(inMenubutton)
#@     }
#@     set Priv(inMenubutton) $w
#@     if {[string compare [$w cget -state] "disabled"]} {
#@ 	$w configure -state active
#@     }
#@ }
#@ 
#@ # ::tk::MbLeave --
#@ # This procedure is invoked when the mouse leaves a menubutton widget.
#@ # It de-activates the widget, if the widget still exists.
#@ #
#@ # Arguments:
#@ # w -			The  name of the widget.
#@ 
#@ proc ::tk::MbLeave w {
#@     variable ::tk::Priv
#@ 
#@     set Priv(inMenubutton) {}
#@     if {![winfo exists $w]} {
#@ 	return
#@     }
#@     if {[string equal [$w cget -state] "active"]} {
#@ 	$w configure -state normal
#@     }
#@ }
#@ 
#@ # ::tk::MbPost --
#@ # Given a menubutton, this procedure does all the work of posting
#@ # its associated menu and unposting any other menu that is currently
#@ # posted.
#@ #
#@ # Arguments:
#@ # w -			The name of the menubutton widget whose menu
#@ #			is to be posted.
#@ # x, y -		Root coordinates of cursor, used for positioning
#@ #			option menus.  If not specified, then the center
#@ #			of the menubutton is used for an option menu.
#@ 
#@ proc ::tk::MbPost {w {x {}} {y {}}} {
#@     global errorInfo
#@     variable ::tk::Priv
#@     global tcl_platform
#@ 
#@     if {[$w cget -state] eq "disabled" || $w eq $Priv(postedMb)} {
#@ 	return
#@     }
#@     set menu [$w cget -menu]
#@     if {[string equal $menu ""]} {
#@ 	return
#@     }
#@     set tearoff [expr {[tk windowingsystem] eq "x11" 	    || [$menu cget -type] eq "tearoff"}]
#@     if {[string first $w $menu] != 0} {
#@ 	error "can't post $menu:  it isn't a descendant of $w (this is a new requirement in Tk versions 3.0 and later)"
#@     }
#@     set cur $Priv(postedMb)
#@     if {[string compare $cur ""]} {
#@ 	MenuUnpost {}
#@     }
#@     set Priv(cursor) [$w cget -cursor]
#@     set Priv(relief) [$w cget -relief]
#@     $w configure -cursor arrow
#@     $w configure -relief raised
#@ 
#@     set Priv(postedMb) $w
#@     set Priv(focus) [focus]
#@     $menu activate none
#@     GenerateMenuSelect $menu
#@ 
#@     # If this looks like an option menubutton then post the menu so
#@     # that the current entry is on top of the mouse.  Otherwise post
#@     # the menu just below the menubutton, as for a pull-down.
#@ 
#@     update idletasks
#@     if {[catch {
#@ 	switch [$w cget -direction] {
#@     	    above {
#@     	    	set x [winfo rootx $w]
#@     	    	set y [expr {[winfo rooty $w] - [winfo reqheight $menu]}]
#@ 		PostOverPoint $menu $x $y
#@     	    }
#@     	    below {
#@     	    	set x [winfo rootx $w]
#@     	    	set y [expr {[winfo rooty $w] + [winfo height $w]}]
#@ 		PostOverPoint $menu $x $y
#@     	    }
#@     	    left {
#@     	    	set x [expr {[winfo rootx $w] - [winfo reqwidth $menu]}]
#@     	    	set y [expr {(2 * [winfo rooty $w] + [winfo height $w]) / 2}]
#@     	    	set entry [MenuFindName $menu [$w cget -text]]
#@     	    	if {[$w cget -indicatoron]} {
#@ 		    if {$entry == [$menu index last]} {
#@ 		    	incr y [expr {-([$menu yposition $entry] 			    	+ [winfo reqheight $menu])/2}]
#@ 		    } else {
#@ 		    	incr y [expr {-([$menu yposition $entry] 			        + [$menu yposition [expr {$entry+1}]])/2}]
#@ 		    }
#@     	    	}
#@ 		PostOverPoint $menu $x $y
#@ 		if {$entry ne "" 			&& [$menu entrycget $entry -state] ne "disabled"} {
#@     	    	    $menu activate $entry
#@ 		    GenerateMenuSelect $menu
#@     	    	}
#@     	    }
#@     	    right {
#@     	    	set x [expr {[winfo rootx $w] + [winfo width $w]}]
#@     	    	set y [expr {(2 * [winfo rooty $w] + [winfo height $w]) / 2}]
#@     	    	set entry [MenuFindName $menu [$w cget -text]]
#@     	    	if {[$w cget -indicatoron]} {
#@ 		    if {$entry == [$menu index last]} {
#@ 		    	incr y [expr {-([$menu yposition $entry] 			    	+ [winfo reqheight $menu])/2}]
#@ 		    } else {
#@ 		    	incr y [expr {-([$menu yposition $entry] 			        + [$menu yposition [expr {$entry+1}]])/2}]
#@ 		    }
#@     	    	}
#@ 		PostOverPoint $menu $x $y
#@ 		if {$entry ne "" 			&& [$menu entrycget $entry -state] ne "disabled"} {
#@     	    	    $menu activate $entry
#@ 		    GenerateMenuSelect $menu
#@     	    	}
#@     	    }
#@     	    default {
#@     	    	if {[$w cget -indicatoron]} {
#@ 		    if {[string equal $y {}]} {
#@ 			set x [expr {[winfo rootx $w] + [winfo width $w]/2}]
#@ 			set y [expr {[winfo rooty $w] + [winfo height $w]/2}]
#@ 	    	    }
#@ 	            PostOverPoint $menu $x $y [MenuFindName $menu [$w cget -text]]
#@ 		} else {
#@ 		    PostOverPoint $menu [winfo rootx $w] [expr {[winfo rooty $w]+[winfo height $w]}]
#@     	    	}  
#@     	    }
#@ 	}
#@     } msg]} {
#@ 	# Error posting menu (e.g. bogus -postcommand). Unpost it and
#@ 	# reflect the error.
#@ 	
#@ 	set savedInfo $errorInfo
#@ 	MenuUnpost {}
#@ 	error $msg $savedInfo
#@ 
#@     }
#@ 
#@     set Priv(tearoff) $tearoff
#@     if {$tearoff != 0} {
#@     	focus $menu
#@ 	if {[winfo viewable $w]} {
#@ 	    SaveGrabInfo $w
#@ 	    grab -global $w
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::MenuUnpost --
#@ # This procedure unposts a given menu, plus all of its ancestors up
#@ # to (and including) a menubutton, if any.  It also restores various
#@ # values to what they were before the menu was posted, and releases
#@ # a grab if there's a menubutton involved.  Special notes:
#@ # 1. It's important to unpost all menus before releasing the grab, so
#@ #    that any Enter-Leave events (e.g. from menu back to main
#@ #    application) have mode NotifyGrab.
#@ # 2. Be sure to enclose various groups of commands in "catch" so that
#@ #    the procedure will complete even if the menubutton or the menu
#@ #    or the grab window has been deleted.
#@ #
#@ # Arguments:
#@ # menu -		Name of a menu to unpost.  Ignored if there
#@ #			is a posted menubutton.
#@ 
#@ proc ::tk::MenuUnpost menu {
#@     global tcl_platform
#@     variable ::tk::Priv
#@     set mb $Priv(postedMb)
#@ 
#@     # Restore focus right away (otherwise X will take focus away when
#@     # the menu is unmapped and under some window managers (e.g. olvwm)
#@     # we'll lose the focus completely).
#@ 
#@     catch {focus $Priv(focus)}
#@     set Priv(focus) ""
#@ 
#@     # Unpost menu(s) and restore some stuff that's dependent on
#@     # what was posted.
#@ 
#@     catch {
#@ 	if {[string compare $mb ""]} {
#@ 	    set menu [$mb cget -menu]
#@ 	    $menu unpost
#@ 	    set Priv(postedMb) {}
#@ 	    $mb configure -cursor $Priv(cursor)
#@ 	    $mb configure -relief $Priv(relief)
#@ 	} elseif {[string compare $Priv(popup) ""]} {
#@ 	    $Priv(popup) unpost
#@ 	    set Priv(popup) {}
#@ 	} elseif {[string compare [$menu cget -type] "menubar"] 		&& [string compare [$menu cget -type] "tearoff"]} {
#@ 	    # We're in a cascaded sub-menu from a torn-off menu or popup.
#@ 	    # Unpost all the menus up to the toplevel one (but not
#@ 	    # including the top-level torn-off one) and deactivate the
#@ 	    # top-level torn off menu if there is one.
#@ 
#@ 	    while {1} {
#@ 		set parent [winfo parent $menu]
#@ 		if {[string compare [winfo class $parent] "Menu"] 			|| ![winfo ismapped $parent]} {
#@ 		    break
#@ 		}
#@ 		$parent activate none
#@ 		$parent postcascade none
#@ 		GenerateMenuSelect $parent
#@ 		set type [$parent cget -type]
#@ 		if {[string equal $type "menubar"] || 			[string equal $type "tearoff"]} {
#@ 		    break
#@ 		}
#@ 		set menu $parent
#@ 	    }
#@ 	    if {[string compare [$menu cget -type] "menubar"]} {
#@ 		$menu unpost
#@ 	    }
#@ 	}
#@     }
#@ 
#@     if {($Priv(tearoff) != 0) || $Priv(menuBar) ne ""} {
#@     	# Release grab, if any, and restore the previous grab, if there
#@     	# was one.
#@ 	if {[string compare $menu ""]} {
#@ 	    set grab [grab current $menu]
#@ 	    if {[string compare $grab ""]} {
#@ 		grab release $grab
#@ 	    }
#@ 	}
#@ 	RestoreOldGrab
#@ 	if {$Priv(menuBar) ne ""} {
#@ 	    $Priv(menuBar) configure -cursor $Priv(cursor)
#@ 	    set Priv(menuBar) {}
#@ 	}
#@ 	if {[tk windowingsystem] ne "x11"} {
#@ 	    set Priv(tearoff) 0
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::MbMotion --
#@ # This procedure handles mouse motion events inside menubuttons, and
#@ # also outside menubuttons when a menubutton has a grab (e.g. when a
#@ # menu selection operation is in progress).
#@ #
#@ # Arguments:
#@ # w -			The name of the menubutton widget.
#@ # upDown - 		"down" means button 1 is pressed, "up" means
#@ #			it isn't.
#@ # rootx, rooty -	Coordinates of mouse, in (virtual?) root window.
#@ 
#@ proc ::tk::MbMotion {w upDown rootx rooty} {
#@     variable ::tk::Priv
#@ 
#@     if {[string equal $Priv(inMenubutton) $w]} {
#@ 	return
#@     }
#@     set new [winfo containing $rootx $rooty]
#@     if {[string compare $new $Priv(inMenubutton)] 	    && ([string equal $new ""] 	    || [string equal [winfo toplevel $new] [winfo toplevel $w]])} {
#@ 	if {[string compare $Priv(inMenubutton) ""]} {
#@ 	    MbLeave $Priv(inMenubutton)
#@ 	}
#@ 	if {[string compare $new ""] 		&& [string equal [winfo class $new] "Menubutton"] 		&& ([$new cget -indicatoron] == 0) 		&& ([$w cget -indicatoron] == 0)} {
#@ 	    if {[string equal $upDown "down"]} {
#@ 		MbPost $new $rootx $rooty
#@ 	    } else {
#@ 		MbEnter $new
#@ 	    }
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::MbButtonUp --
#@ # This procedure is invoked to handle button 1 releases for menubuttons.
#@ # If the release happens inside the menubutton then leave its menu
#@ # posted with element 0 activated.  Otherwise, unpost the menu.
#@ #
#@ # Arguments:
#@ # w -			The name of the menubutton widget.
#@ 
#@ proc ::tk::MbButtonUp w {
#@     variable ::tk::Priv
#@     global tcl_platform
#@ 
#@     set menu [$w cget -menu]
#@     set tearoff [expr {[tk windowingsystem] eq "x11" || 	    ($menu ne "" && [$menu cget -type] eq "tearoff")}]
#@     if {($tearoff != 0) && $Priv(postedMb) eq $w 	    && $Priv(inMenubutton) eq $w} {
#@ 	MenuFirstEntry [$Priv(postedMb) cget -menu]
#@     } else {
#@ 	MenuUnpost {}
#@     }
#@ }
#@ 
#@ # ::tk::MenuMotion --
#@ # This procedure is called to handle mouse motion events for menus.
#@ # It does two things.  First, it resets the active element in the
#@ # menu, if the mouse is over the menu.  Second, if a mouse button
#@ # is down, it posts and unposts cascade entries to match the mouse
#@ # position.
#@ #
#@ # Arguments:
#@ # menu -		The menu window.
#@ # x -			The x position of the mouse.
#@ # y -			The y position of the mouse.
#@ # state -		Modifier state (tells whether buttons are down).
#@ 
#@ proc ::tk::MenuMotion {menu x y state} {
#@     variable ::tk::Priv
#@     if {[string equal $menu $Priv(window)]} {
#@ 	if {[string equal [$menu cget -type] "menubar"]} {
#@ 	    if {[info exists Priv(focus)] && 		    [string compare $menu $Priv(focus)]} {
#@ 		$menu activate @$x,$y
#@ 		GenerateMenuSelect $menu
#@ 	    }
#@ 	} else {
#@ 	    $menu activate @$x,$y
#@ 	    GenerateMenuSelect $menu
#@ 	}
#@     }
#@     if {($state & 0x1f00) != 0} {
#@ 	$menu postcascade active
#@     }
#@ }
#@ 
#@ # ::tk::MenuButtonDown --
#@ # Handles button presses in menus.  There are a couple of tricky things
#@ # here:
#@ # 1. Change the posted cascade entry (if any) to match the mouse position.
#@ # 2. If there is a posted menubutton, must grab to the menubutton;  this
#@ #    overrrides the implicit grab on button press, so that the menu
#@ #    button can track mouse motions over other menubuttons and change
#@ #    the posted menu.
#@ # 3. If there's no posted menubutton (e.g. because we're a torn-off menu
#@ #    or one of its descendants) must grab to the top-level menu so that
#@ #    we can track mouse motions across the entire menu hierarchy.
#@ #
#@ # Arguments:
#@ # menu -		The menu window.
#@ 
#@ proc ::tk::MenuButtonDown menu {
#@     variable ::tk::Priv
#@     global tcl_platform
#@ 
#@     if {![winfo viewable $menu]} {
#@         return
#@     }
#@     $menu postcascade active
#@     if {[string compare $Priv(postedMb) ""] && 	    [winfo viewable $Priv(postedMb)]} {
#@ 	grab -global $Priv(postedMb)
#@     } else {
#@ 	while {[string equal [$menu cget -type] "normal"] 		&& [string equal [winfo class [winfo parent $menu]] "Menu"] 		&& [winfo ismapped [winfo parent $menu]]} {
#@ 	    set menu [winfo parent $menu]
#@ 	}
#@ 
#@ 	if {[string equal $Priv(menuBar) {}]} {
#@ 	    set Priv(menuBar) $menu
#@ 	    set Priv(cursor) [$menu cget -cursor]
#@ 	    $menu configure -cursor arrow
#@         }
#@ 
#@ 	# Don't update grab information if the grab window isn't changing.
#@ 	# Otherwise, we'll get an error when we unpost the menus and
#@ 	# restore the grab, since the old grab window will not be viewable
#@ 	# anymore.
#@ 
#@ 	if {[string compare $menu [grab current $menu]]} {
#@ 	    SaveGrabInfo $menu
#@ 	}
#@ 
#@ 	# Must re-grab even if the grab window hasn't changed, in order
#@ 	# to release the implicit grab from the button press.
#@ 
#@ 	if {[string equal [tk windowingsystem] "x11"]} {
#@ 	    grab -global $menu
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::MenuLeave --
#@ # This procedure is invoked to handle Leave events for a menu.  It
#@ # deactivates everything unless the active element is a cascade element
#@ # and the mouse is now over the submenu.
#@ #
#@ # Arguments:
#@ # menu -		The menu window.
#@ # rootx, rooty -	Root coordinates of mouse.
#@ # state -		Modifier state.
#@ 
#@ proc ::tk::MenuLeave {menu rootx rooty state} {
#@     variable ::tk::Priv
#@     set Priv(window) {}
#@     if {[string equal [$menu index active] "none"]} {
#@ 	return
#@     }
#@     if {[string equal [$menu type active] "cascade"]
#@           && [string equal [winfo containing $rootx $rooty]                   [$menu entrycget active -menu]]} {
#@ 	return
#@     }
#@     $menu activate none
#@     GenerateMenuSelect $menu
#@ }
#@ 
#@ # ::tk::MenuInvoke --
#@ # This procedure is invoked when button 1 is released over a menu.
#@ # It invokes the appropriate menu action and unposts the menu if
#@ # it came from a menubutton.
#@ #
#@ # Arguments:
#@ # w -			Name of the menu widget.
#@ # buttonRelease -	1 means this procedure is called because of
#@ #			a button release;  0 means because of keystroke.
#@ 
#@ proc ::tk::MenuInvoke {w buttonRelease} {
#@     variable ::tk::Priv
#@ 
#@     if {$buttonRelease && [string equal $Priv(window) {}]} {
#@ 	# Mouse was pressed over a menu without a menu button, then
#@ 	# dragged off the menu (possibly with a cascade posted) and
#@ 	# released.  Unpost everything and quit.
#@ 
#@ 	$w postcascade none
#@ 	$w activate none
#@ 	event generate $w <<MenuSelect>>
#@ 	MenuUnpost $w
#@ 	return
#@     }
#@     if {[string equal [$w type active] "cascade"]} {
#@ 	$w postcascade active
#@ 	set menu [$w entrycget active -menu]
#@ 	MenuFirstEntry $menu
#@     } elseif {[string equal [$w type active] "tearoff"]} {
#@ 	::tk::TearOffMenu $w
#@ 	MenuUnpost $w
#@     } elseif {[string equal [$w cget -type] "menubar"]} {
#@ 	$w postcascade none
#@ 	set active [$w index active]
#@ 	set isCascade [string equal [$w type $active] "cascade"]
#@ 
#@ 	# Only de-activate the active item if it's a cascade; this prevents
#@ 	# the annoying "activation flicker" you otherwise get with 
#@ 	# checkbuttons/commands/etc. on menubars
#@ 
#@ 	if { $isCascade } {
#@ 	    $w activate none
#@ 	    event generate $w <<MenuSelect>>
#@ 	}
#@ 
#@ 	MenuUnpost $w
#@ 
#@ 	# If the active item is not a cascade, invoke it.  This enables
#@ 	# the use of checkbuttons/commands/etc. on menubars (which is legal,
#@ 	# but not recommended)
#@ 
#@ 	if { !$isCascade } {
#@ 	    uplevel #0 [list $w invoke $active]
#@ 	}
#@     } else {
#@ 	MenuUnpost $w
#@ 	uplevel #0 [list $w invoke active]
#@     }
#@ }
#@ 
#@ # ::tk::MenuEscape --
#@ # This procedure is invoked for the Cancel (or Escape) key.  It unposts
#@ # the given menu and, if it is the top-level menu for a menu button,
#@ # unposts the menu button as well.
#@ #
#@ # Arguments:
#@ # menu -		Name of the menu window.
#@ 
#@ proc ::tk::MenuEscape menu {
#@     set parent [winfo parent $menu]
#@     if {[string compare [winfo class $parent] "Menu"]} {
#@ 	MenuUnpost $menu
#@     } elseif {[string equal [$parent cget -type] "menubar"]} {
#@ 	MenuUnpost $menu
#@ 	RestoreOldGrab
#@     } else {
#@ 	MenuNextMenu $menu left
#@     }
#@ }
#@ 
#@ # The following routines handle arrow keys. Arrow keys behave
#@ # differently depending on whether the menu is a menu bar or not.
#@ 
#@ proc ::tk::MenuUpArrow {menu} {
#@     if {[string equal [$menu cget -type] "menubar"]} {
#@ 	MenuNextMenu $menu left
#@     } else {
#@ 	MenuNextEntry $menu -1
#@     }
#@ }
#@ 
#@ proc ::tk::MenuDownArrow {menu} {
#@     if {[string equal [$menu cget -type] "menubar"]} {
#@ 	MenuNextMenu $menu right
#@     } else {
#@ 	MenuNextEntry $menu 1
#@     }
#@ }
#@ 
#@ proc ::tk::MenuLeftArrow {menu} {
#@     if {[string equal [$menu cget -type] "menubar"]} {
#@ 	MenuNextEntry $menu -1
#@     } else {
#@ 	MenuNextMenu $menu left
#@     }
#@ }
#@ 
#@ proc ::tk::MenuRightArrow {menu} {
#@     if {[string equal [$menu cget -type] "menubar"]} {
#@ 	MenuNextEntry $menu 1
#@     } else {
#@ 	MenuNextMenu $menu right
#@     }
#@ }
#@ 
#@ # ::tk::MenuNextMenu --
#@ # This procedure is invoked to handle "left" and "right" traversal
#@ # motions in menus.  It traverses to the next menu in a menu bar,
#@ # or into or out of a cascaded menu.
#@ #
#@ # Arguments:
#@ # menu -		The menu that received the keyboard
#@ #			event.
#@ # direction -		Direction in which to move: "left" or "right"
#@ 
#@ proc ::tk::MenuNextMenu {menu direction} {
#@     variable ::tk::Priv
#@ 
#@     # First handle traversals into and out of cascaded menus.
#@ 
#@     if {[string equal $direction "right"]} {
#@ 	set count 1
#@ 	set parent [winfo parent $menu]
#@ 	set class [winfo class $parent]
#@ 	if {[string equal [$menu type active] "cascade"]} {
#@ 	    $menu postcascade active
#@ 	    set m2 [$menu entrycget active -menu]
#@ 	    if {[string compare $m2 ""]} {
#@ 		MenuFirstEntry $m2
#@ 	    }
#@ 	    return
#@ 	} else {
#@ 	    set parent [winfo parent $menu]
#@ 	    while {[string compare $parent "."]} {
#@ 		if {[string equal [winfo class $parent] "Menu"] 			&& [string equal [$parent cget -type] "menubar"]} {
#@ 		    tk_menuSetFocus $parent
#@ 		    MenuNextEntry $parent 1
#@ 		    return
#@ 		}
#@ 		set parent [winfo parent $parent]
#@ 	    }
#@ 	}
#@     } else {
#@ 	set count -1
#@ 	set m2 [winfo parent $menu]
#@ 	if {[string equal [winfo class $m2] "Menu"]} {
#@ 	    $menu activate none
#@ 	    GenerateMenuSelect $menu
#@ 	    tk_menuSetFocus $m2
#@ 
#@ 	    $m2 postcascade none
#@ 
#@ 	    if {[string compare [$m2 cget -type] "menubar"]} {
#@ 		return
#@ 	    }
#@ 	}
#@     }
#@ 
#@     # Can't traverse into or out of a cascaded menu.  Go to the next
#@     # or previous menubutton, if that makes sense.
#@ 
#@     set m2 [winfo parent $menu]
#@     if {[string equal [winfo class $m2] "Menu"]} {
#@ 	if {[string equal [$m2 cget -type] "menubar"]} {
#@ 	    tk_menuSetFocus $m2
#@ 	    MenuNextEntry $m2 -1
#@ 	    return
#@ 	}
#@     }
#@ 
#@     set w $Priv(postedMb)
#@     if {[string equal $w ""]} {
#@ 	return
#@     }
#@     set buttons [winfo children [winfo parent $w]]
#@     set length [llength $buttons]
#@     set i [expr {[lsearch -exact $buttons $w] + $count}]
#@     while {1} {
#@ 	while {$i < 0} {
#@ 	    incr i $length
#@ 	}
#@ 	while {$i >= $length} {
#@ 	    incr i -$length
#@ 	}
#@ 	set mb [lindex $buttons $i]
#@ 	if {[string equal [winfo class $mb] "Menubutton"] 		&& [string compare [$mb cget -state] "disabled"] 		&& [string compare [$mb cget -menu] ""] 		&& [string compare [[$mb cget -menu] index last] "none"]} {
#@ 	    break
#@ 	}
#@ 	if {[string equal $mb $w]} {
#@ 	    return
#@ 	}
#@ 	incr i $count
#@     }
#@     MbPost $mb
#@     MenuFirstEntry [$mb cget -menu]
#@ }
#@ 
#@ # ::tk::MenuNextEntry --
#@ # Activate the next higher or lower entry in the posted menu,
#@ # wrapping around at the ends.  Disabled entries are skipped.
#@ #
#@ # Arguments:
#@ # menu -			Menu window that received the keystroke.
#@ # count -			1 means go to the next lower entry,
#@ #				-1 means go to the next higher entry.
#@ 
#@ proc ::tk::MenuNextEntry {menu count} {
#@ 
#@     if {[string equal [$menu index last] "none"]} {
#@ 	return
#@     }
#@     set length [expr {[$menu index last]+1}]
#@     set quitAfter $length
#@     set active [$menu index active]
#@     if {[string equal $active "none"]} {
#@ 	set i 0
#@     } else {
#@ 	set i [expr {$active + $count}]
#@     }
#@     while {1} {
#@ 	if {$quitAfter <= 0} {
#@ 	    # We've tried every entry in the menu.  Either there are
#@ 	    # none, or they're all disabled.  Just give up.
#@ 
#@ 	    return
#@ 	}
#@ 	while {$i < 0} {
#@ 	    incr i $length
#@ 	}
#@ 	while {$i >= $length} {
#@ 	    incr i -$length
#@ 	}
#@ 	if {[catch {$menu entrycget $i -state} state] == 0} {
#@ 	    if {$state ne "disabled" && 		    ($i!=0 || [$menu cget -type] ne "tearoff" 		    || [$menu type 0] ne "tearoff")} {
#@ 		break
#@ 	    }
#@ 	}
#@ 	if {$i == $active} {
#@ 	    return
#@ 	}
#@ 	incr i $count
#@ 	incr quitAfter -1
#@     }
#@     $menu activate $i
#@     GenerateMenuSelect $menu
#@ 
#@     if {[string equal [$menu type $i] "cascade"] 	    && [string equal [$menu cget -type] "menubar"]} {
#@ 	set cascade [$menu entrycget $i -menu]
#@ 	if {[string compare $cascade ""]} {
#@ 	    # Here we auto-post a cascade.  This is necessary when
#@ 	    # we traverse left/right in the menubar, but undesirable when
#@ 	    # we traverse up/down in a menu.
#@ 	    $menu postcascade $i
#@ 	    MenuFirstEntry $cascade
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::MenuFind --
#@ # This procedure searches the entire window hierarchy under w for
#@ # a menubutton that isn't disabled and whose underlined character
#@ # is "char" or an entry in a menubar that isn't disabled and whose
#@ # underlined character is "char".
#@ # It returns the name of that window, if found, or an
#@ # empty string if no matching window was found.  If "char" is an
#@ # empty string then the procedure returns the name of the first
#@ # menubutton found that isn't disabled.
#@ #
#@ # Arguments:
#@ # w -				Name of window where key was typed.
#@ # char -			Underlined character to search for;
#@ #				may be either upper or lower case, and
#@ #				will match either upper or lower case.
#@ 
#@ proc ::tk::MenuFind {w char} {
#@     set char [string tolower $char]
#@     set windowlist [winfo child $w]
#@ 
#@     foreach child $windowlist {
#@ 	# Don't descend into other toplevels.
#@         if {[string compare [winfo toplevel $w] [winfo toplevel $child]]} {
#@ 	    continue
#@ 	}
#@ 	if {[string equal [winfo class $child] "Menu"] && 		[string equal [$child cget -type] "menubar"]} {
#@ 	    if {[string equal $char ""]} {
#@ 		return $child
#@ 	    }
#@ 	    set last [$child index last]
#@ 	    for {set i [$child cget -tearoff]} {$i <= $last} {incr i} {
#@ 		if {[string equal [$child type $i] "separator"]} {
#@ 		    continue
#@ 		}
#@ 		set char2 [string index [$child entrycget $i -label] 			[$child entrycget $i -underline]]
#@ 		if {[string equal $char [string tolower $char2]] 			|| [string equal $char ""]} {
#@ 		    if {[string compare [$child entrycget $i -state] "disabled"]} {
#@ 			return $child
#@ 		    }
#@ 		}
#@ 	    }
#@ 	}
#@     }
#@ 
#@     foreach child $windowlist {
#@ 	# Don't descend into other toplevels.
#@         if {[string compare [winfo toplevel $w] [winfo toplevel $child]]} {
#@ 	    continue
#@ 	}
#@ 	switch [winfo class $child] {
#@ 	    Menubutton {
#@ 		set char2 [string index [$child cget -text] 			[$child cget -underline]]
#@ 		if {[string equal $char [string tolower $char2]] 			|| [string equal $char ""]} {
#@ 		    if {[string compare [$child cget -state] "disabled"]} {
#@ 			return $child
#@ 		    }
#@ 		}
#@ 	    }
#@ 
#@ 	    default {
#@ 		set match [MenuFind $child $char]
#@ 		if {[string compare $match ""]} {
#@ 		    return $match
#@ 		}
#@ 	    }
#@ 	}
#@     }
#@     return {}
#@ }
#@ 
#@ # ::tk::TraverseToMenu --
#@ # This procedure implements keyboard traversal of menus.  Given an
#@ # ASCII character "char", it looks for a menubutton with that character
#@ # underlined.  If one is found, it posts the menubutton's menu
#@ #
#@ # Arguments:
#@ # w -				Window in which the key was typed (selects
#@ #				a toplevel window).
#@ # char -			Character that selects a menu.  The case
#@ #				is ignored.  If an empty string, nothing
#@ #				happens.
#@ 
#@ proc ::tk::TraverseToMenu {w char} {
#@     variable ::tk::Priv
#@     if {[string equal $char ""]} {
#@ 	return
#@     }
#@     while {[string equal [winfo class $w] "Menu"]} {
#@ 	if {[string compare [$w cget -type] "menubar"] 		&& [string equal $Priv(postedMb) ""]} {
#@ 	    return
#@ 	}
#@ 	if {[string equal [$w cget -type] "menubar"]} {
#@ 	    break
#@ 	}
#@ 	set w [winfo parent $w]
#@     }
#@     set w [MenuFind [winfo toplevel $w] $char]
#@     if {[string compare $w ""]} {
#@ 	if {[string equal [winfo class $w] "Menu"]} {
#@ 	    tk_menuSetFocus $w
#@ 	    set Priv(window) $w
#@ 	    SaveGrabInfo $w
#@ 	    grab -global $w
#@ 	    TraverseWithinMenu $w $char
#@ 	} else {
#@ 	    MbPost $w
#@ 	    MenuFirstEntry [$w cget -menu]
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::FirstMenu --
#@ # This procedure traverses to the first menubutton in the toplevel
#@ # for a given window, and posts that menubutton's menu.
#@ #
#@ # Arguments:
#@ # w -				Name of a window.  Selects which toplevel
#@ #				to search for menubuttons.
#@ 
#@ proc ::tk::FirstMenu w {
#@     variable ::tk::Priv
#@     set w [MenuFind [winfo toplevel $w] ""]
#@     if {[string compare $w ""]} {
#@ 	if {[string equal [winfo class $w] "Menu"]} {
#@ 	    tk_menuSetFocus $w
#@ 	    set Priv(window) $w
#@ 	    SaveGrabInfo $w
#@ 	    grab -global $w
#@ 	    MenuFirstEntry $w
#@ 	} else {
#@ 	    MbPost $w
#@ 	    MenuFirstEntry [$w cget -menu]
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::TraverseWithinMenu
#@ # This procedure implements keyboard traversal within a menu.  It
#@ # searches for an entry in the menu that has "char" underlined.  If
#@ # such an entry is found, it is invoked and the menu is unposted.
#@ #
#@ # Arguments:
#@ # w -				The name of the menu widget.
#@ # char -			The character to look for;  case is
#@ #				ignored.  If the string is empty then
#@ #				nothing happens.
#@ 
#@ proc ::tk::TraverseWithinMenu {w char} {
#@     if {[string equal $char ""]} {
#@ 	return
#@     }
#@     set char [string tolower $char]
#@     set last [$w index last]
#@     if {[string equal $last "none"]} {
#@ 	return
#@     }
#@     for {set i 0} {$i <= $last} {incr i} {
#@ 	if {[catch {set char2 [string index 		[$w entrycget $i -label] [$w entrycget $i -underline]]}]} {
#@ 	    continue
#@ 	}
#@ 	if {[string equal $char [string tolower $char2]]} {
#@ 	    if {[string equal [$w type $i] "cascade"]} {
#@ 		$w activate $i
#@ 		$w postcascade active
#@ 		event generate $w <<MenuSelect>>
#@ 		set m2 [$w entrycget $i -menu]
#@ 		if {[string compare $m2 ""]} {
#@ 		    MenuFirstEntry $m2
#@ 		}
#@ 	    } else {
#@ 		MenuUnpost $w
#@ 		uplevel #0 [list $w invoke $i]
#@ 	    }
#@ 	    return
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::MenuFirstEntry --
#@ # Given a menu, this procedure finds the first entry that isn't
#@ # disabled or a tear-off or separator, and activates that entry.
#@ # However, if there is already an active entry in the menu (e.g.,
#@ # because of a previous call to tk::PostOverPoint) then the active
#@ # entry isn't changed.  This procedure also sets the input focus
#@ # to the menu.
#@ #
#@ # Arguments:
#@ # menu -		Name of the menu window (possibly empty).
#@ 
#@ proc ::tk::MenuFirstEntry menu {
#@     if {[string equal $menu ""]} {
#@ 	return
#@     }
#@     tk_menuSetFocus $menu
#@     if {[string compare [$menu index active] "none"]} {
#@ 	return
#@     }
#@     set last [$menu index last]
#@     if {[string equal $last "none"]} {
#@ 	return
#@     }
#@     for {set i 0} {$i <= $last} {incr i} {
#@ 	if {([catch {set state [$menu entrycget $i -state]}] == 0) 		&& [string compare $state "disabled"] 		&& [string compare [$menu type $i] "tearoff"]} {
#@ 	    $menu activate $i
#@ 	    GenerateMenuSelect $menu
#@ 	    # Only post the cascade if the current menu is a menubar;
#@ 	    # otherwise, if the first entry of the cascade is a cascade,
#@ 	    # we can get an annoying cascading effect resulting in a bunch of
#@ 	    # menus getting posted (bug 676)
#@ 	    if {[string equal [$menu type $i] "cascade"] && 		[string equal [$menu cget -type] "menubar"]} {
#@ 		set cascade [$menu entrycget $i -menu]
#@ 		if {[string compare $cascade ""]} {
#@ 		    $menu postcascade $i
#@ 		    MenuFirstEntry $cascade
#@ 		}
#@ 	    }
#@ 	    return
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::MenuFindName --
#@ # Given a menu and a text string, return the index of the menu entry
#@ # that displays the string as its label.  If there is no such entry,
#@ # return an empty string.  This procedure is tricky because some names
#@ # like "active" have a special meaning in menu commands, so we can't
#@ # always use the "index" widget command.
#@ #
#@ # Arguments:
#@ # menu -		Name of the menu widget.
#@ # s -			String to look for.
#@ 
#@ proc ::tk::MenuFindName {menu s} {
#@     set i ""
#@     if {![regexp {^active$|^last$|^none$|^[0-9]|^@} $s]} {
#@ 	catch {set i [$menu index $s]}
#@ 	return $i
#@     }
#@     set last [$menu index last]
#@     if {[string equal $last "none"]} {
#@ 	return
#@     }
#@     for {set i 0} {$i <= $last} {incr i} {
#@ 	if {![catch {$menu entrycget $i -label} label]} {
#@ 	    if {[string equal $label $s]} {
#@ 		return $i
#@ 	    }
#@ 	}
#@     }
#@     return ""
#@ }
#@ 
#@ # ::tk::PostOverPoint --
#@ # This procedure posts a given menu such that a given entry in the
#@ # menu is centered over a given point in the root window.  It also
#@ # activates the given entry.
#@ #
#@ # Arguments:
#@ # menu -		Menu to post.
#@ # x, y -		Root coordinates of point.
#@ # entry -		Index of entry within menu to center over (x,y).
#@ #			If omitted or specified as {}, then the menu's
#@ #			upper-left corner goes at (x,y).
#@ 
#@ proc ::tk::PostOverPoint {menu x y {entry {}}}  {
#@     global tcl_platform
#@     
#@     if {[string compare $entry {}]} {
#@ 	if {$entry == [$menu index last]} {
#@ 	    incr y [expr {-([$menu yposition $entry] 		    + [winfo reqheight $menu])/2}]
#@ 	} else {
#@ 	    incr y [expr {-([$menu yposition $entry] 		    + [$menu yposition [expr {$entry+1}]])/2}]
#@ 	}
#@ 	incr x [expr {-[winfo reqwidth $menu]/2}]
#@     }
#@     if {$tcl_platform(platform) == "windows"} {
#@ 	# We need to fix some problems with menu posting on Windows.
#@ 	set yoffset [expr {[winfo screenheight $menu] 		- $y - [winfo reqheight $menu]}]
#@ 	if {$yoffset < 0} {
#@ 	    # The bottom of the menu is offscreen, so adjust upwards
#@ 	    incr y $yoffset
#@ 	    if {$y < 0} { set y 0 }
#@ 	}
#@ 	# If we're off the top of the screen (either because we were
#@ 	# originally or because we just adjusted too far upwards),
#@ 	# then make the menu popup on the top edge.
#@ 	if {$y < 0} {
#@ 	    set y 0
#@ 	}
#@     }
#@     $menu post $x $y
#@     if {$entry ne "" && [$menu entrycget $entry -state] ne "disabled"} {
#@ 	$menu activate $entry
#@ 	GenerateMenuSelect $menu
#@     }
#@ }
#@ 
#@ # ::tk::SaveGrabInfo --
#@ # Sets the variables tk::Priv(oldGrab) and tk::Priv(grabStatus) to record
#@ # the state of any existing grab on the w's display.
#@ #
#@ # Arguments:
#@ # w -			Name of a window;  used to select the display
#@ #			whose grab information is to be recorded.
#@ 
#@ proc tk::SaveGrabInfo w {
#@     variable ::tk::Priv
#@     set Priv(oldGrab) [grab current $w]
#@     if {$Priv(oldGrab) ne ""} {
#@ 	set Priv(grabStatus) [grab status $Priv(oldGrab)]
#@     }
#@ }
#@ 
#@ # ::tk::RestoreOldGrab --
#@ # Restores the grab to what it was before TkSaveGrabInfo was called.
#@ #
#@ 
#@ proc ::tk::RestoreOldGrab {} {
#@     variable ::tk::Priv
#@ 
#@     if {$Priv(oldGrab) ne ""} {
#@     	# Be careful restoring the old grab, since it's window may not
#@ 	# be visible anymore.
#@ 
#@ 	catch {
#@           if {[string equal $Priv(grabStatus) "global"]} {
#@ 		grab set -global $Priv(oldGrab)
#@ 	    } else {
#@ 		grab set $Priv(oldGrab)
#@ 	    }
#@ 	}
#@ 	set Priv(oldGrab) ""
#@     }
#@ }
#@ 
#@ proc ::tk_menuSetFocus {menu} {
#@     variable ::tk::Priv
#@     if {![info exists Priv(focus)] || [string equal $Priv(focus) {}]} {
#@ 	set Priv(focus) [focus]
#@     }
#@     focus $menu
#@ }
#@ 
#@ proc ::tk::GenerateMenuSelect {menu} {
#@     variable ::tk::Priv
#@ 
#@     if {[string equal $Priv(activeMenu) $menu]           && [string equal $Priv(activeItem) [$menu index active]]} {
#@ 	return
#@     }
#@ 
#@     set Priv(activeMenu) $menu
#@     set Priv(activeItem) [$menu index active]
#@     event generate $menu <<MenuSelect>>
#@ }
#@ 
#@ # ::tk_popup --
#@ # This procedure pops up a menu and sets things up for traversing
#@ # the menu and its submenus.
#@ #
#@ # Arguments:
#@ # menu -		Name of the menu to be popped up.
#@ # x, y -		Root coordinates at which to pop up the
#@ #			menu.
#@ # entry -		Index of a menu entry to center over (x,y).
#@ #			If omitted or specified as {}, then menu's
#@ #			upper-left corner goes at (x,y).
#@ 
#@ proc ::tk_popup {menu x y {entry {}}} {
#@     variable ::tk::Priv
#@     global tcl_platform
#@     if {$Priv(popup) ne "" || $Priv(postedMb) ne ""} {
#@ 	tk::MenuUnpost {}
#@     }
#@     tk::PostOverPoint $menu $x $y $entry
#@     if {[tk windowingsystem] eq "x11" && [winfo viewable $menu]} {
#@         tk::SaveGrabInfo $menu
#@ 	grab -global $menu
#@ 	set Priv(popup) $menu
#@ 	tk_menuSetFocus $menu
#@     }
#@ }
#@ # -- End source /usr/cad/synopsys/synthesis/cur/auxx/tcllib/lib/tk8.4/menu.tcl

#@ # panedwindow.tcl --
#@ #
#@ # This file defines the default bindings for Tk panedwindow widgets and
#@ # provides procedures that help in implementing those bindings.
#@ #
#@ # RCS: @(#) $Id: //sde/tcl/tk8.4r/rel1/library/panedwindow.tcl#1 $
#@ #
#@ 
#@ bind Panedwindow <Button-1> { ::tk::panedwindow::MarkSash %W %x %y 1 }
#@ bind Panedwindow <Button-2> { ::tk::panedwindow::MarkSash %W %x %y 0 }
#@ 
#@ bind Panedwindow <B1-Motion> { ::tk::panedwindow::DragSash %W %x %y 1 }
#@ bind Panedwindow <B2-Motion> { ::tk::panedwindow::DragSash %W %x %y 0 }
#@ 
#@ bind Panedwindow <ButtonRelease-1> {::tk::panedwindow::ReleaseSash %W 1}
#@ bind Panedwindow <ButtonRelease-2> {::tk::panedwindow::ReleaseSash %W 0}
#@ 
#@ bind Panedwindow <Motion> { ::tk::panedwindow::Motion %W %x %y }
#@ 
#@ bind Panedwindow <Leave> { ::tk::panedwindow::Leave %W }
#@ 
#@ # Initialize namespace
#@ namespace eval ::tk::panedwindow {}
#@ 
#@ # ::tk::panedwindow::MarkSash --
#@ #
#@ #   Handle marking the correct sash for possible dragging
#@ #
#@ # Arguments:
#@ #   w		the widget
#@ #   x		widget local x coord
#@ #   y		widget local y coord
#@ #   proxy	whether this should be a proxy sash
#@ # Results:
#@ #   None
#@ #
#@ proc ::tk::panedwindow::MarkSash {w x y proxy} {
#@     set what [$w identify $x $y]
#@     if { [llength $what] == 2 } {
#@ 	foreach {index which} $what break
#@ 	if { !$::tk_strictMotif || [string equal $which "handle"] } {
#@ 	    if {!$proxy} { $w sash mark $index $x $y }
#@ 	    set ::tk::Priv(sash) $index
#@ 	    foreach {sx sy} [$w sash coord $index] break
#@ 	    set ::tk::Priv(dx) [expr {$sx-$x}]
#@ 	    set ::tk::Priv(dy) [expr {$sy-$y}]
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::panedwindow::DragSash --
#@ #
#@ #   Handle dragging of the correct sash
#@ #
#@ # Arguments:
#@ #   w		the widget
#@ #   x		widget local x coord
#@ #   y		widget local y coord
#@ #   proxy	whether this should be a proxy sash
#@ # Results:
#@ #   Moves sash
#@ #
#@ proc ::tk::panedwindow::DragSash {w x y proxy} {
#@     if { [info exists ::tk::Priv(sash)] } {
#@ 	if {$proxy} {
#@ 	    $w proxy place 		    [expr {$x+$::tk::Priv(dx)}] [expr {$y+$::tk::Priv(dy)}]
#@ 	} else {
#@ 	    $w sash place $::tk::Priv(sash) 		    [expr {$x+$::tk::Priv(dx)}] [expr {$y+$::tk::Priv(dy)}]
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::panedwindow::ReleaseSash --
#@ #
#@ #   Handle releasing of the sash
#@ #
#@ # Arguments:
#@ #   w		the widget
#@ #   proxy	whether this should be a proxy sash
#@ # Results:
#@ #   Returns ...
#@ #
#@ proc ::tk::panedwindow::ReleaseSash {w proxy} {
#@     if { [info exists ::tk::Priv(sash)] } {
#@ 	if {$proxy} {
#@ 	    foreach {x y} [$w proxy coord] break
#@ 	    $w sash place $::tk::Priv(sash) $x $y
#@ 	    $w proxy forget
#@ 	}
#@ 	unset ::tk::Priv(sash) ::tk::Priv(dx) ::tk::Priv(dy)
#@     }
#@ }
#@ 
#@ # ::tk::panedwindow::Motion --
#@ #
#@ #   Handle motion on the widget.  This is used to change the cursor
#@ #   when the user moves over the sash area.
#@ #
#@ # Arguments:
#@ #   w		the widget
#@ #   x		widget local x coord
#@ #   y		widget local y coord
#@ # Results:
#@ #   May change the cursor.  Sets up a timer to verify that we are still
#@ #   over the widget.
#@ #
#@ proc ::tk::panedwindow::Motion {w x y} {
#@     variable ::tk::Priv
#@     set id [$w identify $x $y]
#@     if {([llength $id] == 2) && 	    (!$::tk_strictMotif || [string equal [lindex $id 1] "handle"])} {
#@ 	if { ![info exists Priv($w,panecursor)] } {
#@ 	    set Priv($w,panecursor) [$w cget -cursor]
#@ 	    if { [string equal [$w cget -sashcursor] ""] } {
#@ 		if { [string equal [$w cget -orient] "horizontal"] } {
#@ 		    $w configure -cursor sb_h_double_arrow
#@ 		} else {
#@ 		    $w configure -cursor sb_v_double_arrow
#@ 		}
#@ 	    } else {
#@ 		$w configure -cursor [$w cget -sashcursor]
#@ 	    }
#@ 	    if {[info exists Priv($w,pwAfterId)]} {
#@ 		after cancel $Priv($w,pwAfterId)
#@ 	    }
#@ 	    set Priv($w,pwAfterId) [after 150 		    [list ::tk::panedwindow::Cursor $w]]
#@ 	}
#@ 	return
#@     }
#@     if { [info exists Priv($w,panecursor)] } {
#@ 	$w configure -cursor $Priv($w,panecursor)
#@ 	unset Priv($w,panecursor)
#@     }
#@ }
#@ 
#@ # ::tk::panedwindow::Cursor --
#@ #
#@ #   Handles returning the normal cursor when we are no longer over the
#@ #   sash area.  This needs to be done this way, because the panedwindow
#@ #   won't see Leave events when the mouse moves from the sash to a
#@ #   paned child, although the child does receive an Enter event.
#@ #
#@ # Arguments:
#@ #   w		the widget
#@ # Results:
#@ #   May restore the default cursor, or schedule a timer to do it.
#@ #
#@ proc ::tk::panedwindow::Cursor {w} {
#@     variable ::tk::Priv
#@     if {[info exists Priv($w,panecursor)]} {
#@ 	if {[winfo containing [winfo pointerx $w] [winfo pointery $w]] eq $w} {
#@ 	    set Priv($w,pwAfterId) [after 150 		    [list ::tk::panedwindow::Cursor $w]]
#@ 	} else {
#@ 	    $w configure -cursor $Priv($w,panecursor)
#@ 	    unset Priv($w,panecursor)
#@ 	    if {[info exists Priv($w,pwAfterId)]} {
#@ 		after cancel $Priv($w,pwAfterId)
#@ 		unset Priv($w,pwAfterId)
#@ 	    }
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::panedwindow::Leave --
#@ #
#@ #   Return to default cursor when leaving the pw widget.
#@ #
#@ # Arguments:
#@ #   w		the widget
#@ # Results:
#@ #   Restores the default cursor
#@ #
#@ proc ::tk::panedwindow::Leave {w} {
#@     if {[info exists ::tk::Priv($w,panecursor)]} {
#@         $w configure -cursor $::tk::Priv($w,panecursor)
#@         unset ::tk::Priv($w,panecursor)
#@     }
#@ }
#@ # -- End source /usr/cad/synopsys/synthesis/cur/auxx/tcllib/lib/tk8.4/panedwindow.tcl

#@ # scale.tcl --
#@ #
#@ # This file defines the default bindings for Tk scale widgets and provides
#@ # procedures that help in implementing the bindings.
#@ #
#@ # RCS: @(#) $Id: //sde/tcl/tk8.4r/rel1/library/scale.tcl#1 $
#@ #
#@ # Copyright (c) 1994 The Regents of the University of California.
#@ # Copyright (c) 1994-1995 Sun Microsystems, Inc.
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ #
#@ 
#@ #-------------------------------------------------------------------------
#@ # The code below creates the default class bindings for entries.
#@ #-------------------------------------------------------------------------
#@ 
#@ # Standard Motif bindings:
#@ 
#@ bind Scale <Enter> {
#@     if {$tk_strictMotif} {
#@ 	set tk::Priv(activeBg) [%W cget -activebackground]
#@ 	%W config -activebackground [%W cget -background]
#@     }
#@     tk::ScaleActivate %W %x %y
#@ }
#@ bind Scale <Motion> {
#@     tk::ScaleActivate %W %x %y
#@ }
#@ bind Scale <Leave> {
#@     if {$tk_strictMotif} {
#@ 	%W config -activebackground $tk::Priv(activeBg)
#@     }
#@     if {[string equal [%W cget -state] "active"]} {
#@ 	%W configure -state normal
#@     }
#@ }
#@ bind Scale <1> {
#@     tk::ScaleButtonDown %W %x %y
#@ }
#@ bind Scale <B1-Motion> {
#@     tk::ScaleDrag %W %x %y
#@ }
#@ bind Scale <B1-Leave> { }
#@ bind Scale <B1-Enter> { }
#@ bind Scale <ButtonRelease-1> {
#@     tk::CancelRepeat
#@     tk::ScaleEndDrag %W
#@     tk::ScaleActivate %W %x %y
#@ }
#@ bind Scale <2> {
#@     tk::ScaleButton2Down %W %x %y
#@ }
#@ bind Scale <B2-Motion> {
#@     tk::ScaleDrag %W %x %y
#@ }
#@ bind Scale <B2-Leave> { }
#@ bind Scale <B2-Enter> { }
#@ bind Scale <ButtonRelease-2> {
#@     tk::CancelRepeat
#@     tk::ScaleEndDrag %W
#@     tk::ScaleActivate %W %x %y
#@ }
#@ if {[string equal $tcl_platform(platform) "windows"]} {
#@     # On Windows do the same with button 3, as that is the right mouse button
#@     bind Scale <3>		[bind Scale <2>]
#@     bind Scale <B3-Motion>	[bind Scale <B2-Motion>]
#@     bind Scale <B3-Leave>	[bind Scale <B2-Leave>]
#@     bind Scale <B3-Enter>	[bind Scale <B2-Enter>]
#@     bind Scale <ButtonRelease-3> [bind Scale <ButtonRelease-2>]
#@ }
#@ bind Scale <Control-1> {
#@     tk::ScaleControlPress %W %x %y
#@ }
#@ bind Scale <Up> {
#@     tk::ScaleIncrement %W up little noRepeat
#@ }
#@ bind Scale <Down> {
#@     tk::ScaleIncrement %W down little noRepeat
#@ }
#@ bind Scale <Left> {
#@     tk::ScaleIncrement %W up little noRepeat
#@ }
#@ bind Scale <Right> {
#@     tk::ScaleIncrement %W down little noRepeat
#@ }
#@ bind Scale <Control-Up> {
#@     tk::ScaleIncrement %W up big noRepeat
#@ }
#@ bind Scale <Control-Down> {
#@     tk::ScaleIncrement %W down big noRepeat
#@ }
#@ bind Scale <Control-Left> {
#@     tk::ScaleIncrement %W up big noRepeat
#@ }
#@ bind Scale <Control-Right> {
#@     tk::ScaleIncrement %W down big noRepeat
#@ }
#@ bind Scale <Home> {
#@     %W set [%W cget -from]
#@ }
#@ bind Scale <End> {
#@     %W set [%W cget -to]
#@ }
#@ 
#@ # ::tk::ScaleActivate --
#@ # This procedure is invoked to check a given x-y position in the
#@ # scale and activate the slider if the x-y position falls within
#@ # the slider.
#@ #
#@ # Arguments:
#@ # w -		The scale widget.
#@ # x, y -	Mouse coordinates.
#@ 
#@ proc ::tk::ScaleActivate {w x y} {
#@     if {[string equal [$w cget -state] "disabled"]} {
#@ 	return
#@     }
#@     if {[string equal [$w identify $x $y] "slider"]} {
#@ 	set state active
#@     } else {
#@ 	set state normal
#@     }
#@     if {[string compare [$w cget -state] $state]} {
#@ 	$w configure -state $state
#@     }
#@ }
#@ 
#@ # ::tk::ScaleButtonDown --
#@ # This procedure is invoked when a button is pressed in a scale.  It
#@ # takes different actions depending on where the button was pressed.
#@ #
#@ # Arguments:
#@ # w -		The scale widget.
#@ # x, y -	Mouse coordinates of button press.
#@ 
#@ proc ::tk::ScaleButtonDown {w x y} {
#@     variable ::tk::Priv
#@     set Priv(dragging) 0
#@     set el [$w identify $x $y]
#@ 
#@     # save the relief
#@     set Priv($w,relief) [$w cget -sliderrelief]
#@ 
#@     if {[string equal $el "trough1"]} {
#@ 	ScaleIncrement $w up little initial
#@     } elseif {[string equal $el "trough2"]} {
#@ 	ScaleIncrement $w down little initial
#@     } elseif {[string equal $el "slider"]} {
#@ 	set Priv(dragging) 1
#@ 	set Priv(initValue) [$w get]
#@ 	set coords [$w coords]
#@ 	set Priv(deltaX) [expr {$x - [lindex $coords 0]}]
#@ 	set Priv(deltaY) [expr {$y - [lindex $coords 1]}]
#@         switch -exact -- $Priv($w,relief) {
#@             "raised" { $w configure -sliderrelief sunken }
#@             "ridge"  { $w configure -sliderrelief groove }
#@         }
#@     }
#@ }
#@ 
#@ # ::tk::ScaleDrag --
#@ # This procedure is called when the mouse is dragged with
#@ # mouse button 1 down.  If the drag started inside the slider
#@ # (i.e. the scale is active) then the scale's value is adjusted
#@ # to reflect the mouse's position.
#@ #
#@ # Arguments:
#@ # w -		The scale widget.
#@ # x, y -	Mouse coordinates.
#@ 
#@ proc ::tk::ScaleDrag {w x y} {
#@     variable ::tk::Priv
#@     if {!$Priv(dragging)} {
#@ 	return
#@     }
#@     $w set [$w get [expr {$x-$Priv(deltaX)}] [expr {$y-$Priv(deltaY)}]]
#@ }
#@ 
#@ # ::tk::ScaleEndDrag --
#@ # This procedure is called to end an interactive drag of the
#@ # slider.  It just marks the drag as over.
#@ #
#@ # Arguments:
#@ # w -		The scale widget.
#@ 
#@ proc ::tk::ScaleEndDrag {w} {
#@     variable ::tk::Priv
#@     set Priv(dragging) 0
#@     if {[info exists Priv($w,relief)]} {
#@         $w configure -sliderrelief $Priv($w,relief)
#@         unset Priv($w,relief)
#@     }
#@ }
#@ 
#@ # ::tk::ScaleIncrement --
#@ # This procedure is invoked to increment the value of a scale and
#@ # to set up auto-repeating of the action if that is desired.  The
#@ # way the value is incremented depends on the "dir" and "big"
#@ # arguments.
#@ #
#@ # Arguments:
#@ # w -		The scale widget.
#@ # dir -		"up" means move value towards -from, "down" means
#@ #		move towards -to.
#@ # big -		Size of increments: "big" or "little".
#@ # repeat -	Whether and how to auto-repeat the action:  "noRepeat"
#@ #		means don't auto-repeat, "initial" means this is the
#@ #		first action in an auto-repeat sequence, and "again"
#@ #		means this is the second repetition or later.
#@ 
#@ proc ::tk::ScaleIncrement {w dir big repeat} {
#@     variable ::tk::Priv
#@     if {![winfo exists $w]} return
#@     if {[string equal $big "big"]} {
#@ 	set inc [$w cget -bigincrement]
#@ 	if {$inc == 0} {
#@ 	    set inc [expr {abs([$w cget -to] - [$w cget -from])/10.0}]
#@ 	}
#@ 	if {$inc < [$w cget -resolution]} {
#@ 	    set inc [$w cget -resolution]
#@ 	}
#@     } else {
#@ 	set inc [$w cget -resolution]
#@     }
#@     if {([$w cget -from] > [$w cget -to]) ^ [string equal $dir "up"]} {
#@ 	set inc [expr {-$inc}]
#@     }
#@     $w set [expr {[$w get] + $inc}]
#@ 
#@     if {[string equal $repeat "again"]} {
#@ 	set Priv(afterId) [after [$w cget -repeatinterval] 		[list tk::ScaleIncrement $w $dir $big again]]
#@     } elseif {[string equal $repeat "initial"]} {
#@ 	set delay [$w cget -repeatdelay]
#@ 	if {$delay > 0} {
#@ 	    set Priv(afterId) [after $delay 		    [list tk::ScaleIncrement $w $dir $big again]]
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::ScaleControlPress --
#@ # This procedure handles button presses that are made with the Control
#@ # key down.  Depending on the mouse position, it adjusts the scale
#@ # value to one end of the range or the other.
#@ #
#@ # Arguments:
#@ # w -		The scale widget.
#@ # x, y -	Mouse coordinates where the button was pressed.
#@ 
#@ proc ::tk::ScaleControlPress {w x y} {
#@     set el [$w identify $x $y]
#@     if {[string equal $el "trough1"]} {
#@ 	$w set [$w cget -from]
#@     } elseif {[string equal $el "trough2"]} {
#@ 	$w set [$w cget -to]
#@     }
#@ }
#@ 
#@ # ::tk::ScaleButton2Down
#@ # This procedure is invoked when button 2 is pressed over a scale.
#@ # It sets the value to correspond to the mouse position and starts
#@ # a slider drag.
#@ #
#@ # Arguments:
#@ # w -		The scrollbar widget.
#@ # x, y -	Mouse coordinates within the widget.
#@ 
#@ proc ::tk::ScaleButton2Down {w x y} {
#@     variable ::tk::Priv
#@ 
#@     if {[string equal [$w cget -state] "disabled"]} {
#@       return
#@     }
#@     $w configure -state active
#@     $w set [$w get $x $y]
#@     set Priv(dragging) 1
#@     set Priv(initValue) [$w get]
#@     set Priv($w,relief) [$w cget -sliderrelief]
#@     set coords "$x $y"
#@     set Priv(deltaX) 0
#@     set Priv(deltaY) 0
#@ }
#@ # -- End source /usr/cad/synopsys/synthesis/cur/auxx/tcllib/lib/tk8.4/scale.tcl

#@ # scrlbar.tcl --
#@ #
#@ # This file defines the default bindings for Tk scrollbar widgets.
#@ # It also provides procedures that help in implementing the bindings.
#@ #
#@ # RCS: @(#) $Id: //sde/tcl/tk8.4r/rel1/library/scrlbar.tcl#1 $
#@ #
#@ # Copyright (c) 1994 The Regents of the University of California.
#@ # Copyright (c) 1994-1996 Sun Microsystems, Inc.
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ #
#@ 
#@ #-------------------------------------------------------------------------
#@ # The code below creates the default class bindings for scrollbars.
#@ #-------------------------------------------------------------------------
#@ 
#@ # Standard Motif bindings:
#@ if {[string equal [tk windowingsystem] "x11"]} {
#@ 
#@ bind Scrollbar <Enter> {
#@     if {$tk_strictMotif} {
#@ 	set tk::Priv(activeBg) [%W cget -activebackground]
#@ 	%W config -activebackground [%W cget -background]
#@     }
#@     %W activate [%W identify %x %y]
#@ }
#@ bind Scrollbar <Motion> {
#@     %W activate [%W identify %x %y]
#@ }
#@ 
#@ # The "info exists" command in the following binding handles the
#@ # situation where a Leave event occurs for a scrollbar without the Enter
#@ # event.  This seems to happen on some systems (such as Solaris 2.4) for
#@ # unknown reasons.
#@ 
#@ bind Scrollbar <Leave> {
#@     if {$tk_strictMotif && [info exists tk::Priv(activeBg)]} {
#@ 	%W config -activebackground $tk::Priv(activeBg)
#@     }
#@     %W activate {}
#@ }
#@ bind Scrollbar <1> {
#@     tk::ScrollButtonDown %W %x %y
#@ }
#@ bind Scrollbar <B1-Motion> {
#@     tk::ScrollDrag %W %x %y
#@ }
#@ bind Scrollbar <B1-B2-Motion> {
#@     tk::ScrollDrag %W %x %y
#@ }
#@ bind Scrollbar <ButtonRelease-1> {
#@     tk::ScrollButtonUp %W %x %y
#@ }
#@ bind Scrollbar <B1-Leave> {
#@     # Prevents <Leave> binding from being invoked.
#@ }
#@ bind Scrollbar <B1-Enter> {
#@     # Prevents <Enter> binding from being invoked.
#@ }
#@ bind Scrollbar <2> {
#@     tk::ScrollButton2Down %W %x %y
#@ }
#@ bind Scrollbar <B1-2> {
#@     # Do nothing, since button 1 is already down.
#@ }
#@ bind Scrollbar <B2-1> {
#@     # Do nothing, since button 2 is already down.
#@ }
#@ bind Scrollbar <B2-Motion> {
#@     tk::ScrollDrag %W %x %y
#@ }
#@ bind Scrollbar <ButtonRelease-2> {
#@     tk::ScrollButtonUp %W %x %y
#@ }
#@ bind Scrollbar <B1-ButtonRelease-2> {
#@     # Do nothing:  B1 release will handle it.
#@ }
#@ bind Scrollbar <B2-ButtonRelease-1> {
#@     # Do nothing:  B2 release will handle it.
#@ }
#@ bind Scrollbar <B2-Leave> {
#@     # Prevents <Leave> binding from being invoked.
#@ }
#@ bind Scrollbar <B2-Enter> {
#@     # Prevents <Enter> binding from being invoked.
#@ }
#@ bind Scrollbar <Control-1> {
#@     tk::ScrollTopBottom %W %x %y
#@ }
#@ bind Scrollbar <Control-2> {
#@     tk::ScrollTopBottom %W %x %y
#@ }
#@ 
#@ bind Scrollbar <Up> {
#@     tk::ScrollByUnits %W v -1
#@ }
#@ bind Scrollbar <Down> {
#@     tk::ScrollByUnits %W v 1
#@ }
#@ bind Scrollbar <Control-Up> {
#@     tk::ScrollByPages %W v -1
#@ }
#@ bind Scrollbar <Control-Down> {
#@     tk::ScrollByPages %W v 1
#@ }
#@ bind Scrollbar <Left> {
#@     tk::ScrollByUnits %W h -1
#@ }
#@ bind Scrollbar <Right> {
#@     tk::ScrollByUnits %W h 1
#@ }
#@ bind Scrollbar <Control-Left> {
#@     tk::ScrollByPages %W h -1
#@ }
#@ bind Scrollbar <Control-Right> {
#@     tk::ScrollByPages %W h 1
#@ }
#@ bind Scrollbar <Prior> {
#@     tk::ScrollByPages %W hv -1
#@ }
#@ bind Scrollbar <Next> {
#@     tk::ScrollByPages %W hv 1
#@ }
#@ bind Scrollbar <Home> {
#@     tk::ScrollToPos %W 0
#@ }
#@ bind Scrollbar <End> {
#@     tk::ScrollToPos %W 1
#@ }
#@ }
#@ # tk::ScrollButtonDown --
#@ # This procedure is invoked when a button is pressed in a scrollbar.
#@ # It changes the way the scrollbar is displayed and takes actions
#@ # depending on where the mouse is.
#@ #
#@ # Arguments:
#@ # w -		The scrollbar widget.
#@ # x, y -	Mouse coordinates.
#@ 
#@ proc tk::ScrollButtonDown {w x y} {
#@     variable ::tk::Priv
#@     set Priv(relief) [$w cget -activerelief]
#@     $w configure -activerelief sunken
#@     set element [$w identify $x $y]
#@     if {[string equal $element "slider"]} {
#@ 	ScrollStartDrag $w $x $y
#@     } else {
#@ 	ScrollSelect $w $element initial
#@     }
#@ }
#@ 
#@ # ::tk::ScrollButtonUp --
#@ # This procedure is invoked when a button is released in a scrollbar.
#@ # It cancels scans and auto-repeats that were in progress, and restores
#@ # the way the active element is displayed.
#@ #
#@ # Arguments:
#@ # w -		The scrollbar widget.
#@ # x, y -	Mouse coordinates.
#@ 
#@ proc ::tk::ScrollButtonUp {w x y} {
#@     variable ::tk::Priv
#@     tk::CancelRepeat
#@     if {[info exists Priv(relief)]} {
#@ 	# Avoid error due to spurious release events
#@ 	$w configure -activerelief $Priv(relief)
#@ 	ScrollEndDrag $w $x $y
#@ 	$w activate [$w identify $x $y]
#@     }
#@ }
#@ 
#@ # ::tk::ScrollSelect --
#@ # This procedure is invoked when a button is pressed over the scrollbar.
#@ # It invokes one of several scrolling actions depending on where in
#@ # the scrollbar the button was pressed.
#@ #
#@ # Arguments:
#@ # w -		The scrollbar widget.
#@ # element -	The element of the scrollbar that was selected, such
#@ #		as "arrow1" or "trough2".  Shouldn't be "slider".
#@ # repeat -	Whether and how to auto-repeat the action:  "noRepeat"
#@ #		means don't auto-repeat, "initial" means this is the
#@ #		first action in an auto-repeat sequence, and "again"
#@ #		means this is the second repetition or later.
#@ 
#@ proc ::tk::ScrollSelect {w element repeat} {
#@     variable ::tk::Priv
#@     if {![winfo exists $w]} return
#@     switch -- $element {
#@ 	"arrow1"	{ScrollByUnits $w hv -1}
#@ 	"trough1"	{ScrollByPages $w hv -1}
#@ 	"trough2"	{ScrollByPages $w hv 1}
#@ 	"arrow2"	{ScrollByUnits $w hv 1}
#@ 	default		{return}
#@     }
#@     if {[string equal $repeat "again"]} {
#@ 	set Priv(afterId) [after [$w cget -repeatinterval] 		[list tk::ScrollSelect $w $element again]]
#@     } elseif {[string equal $repeat "initial"]} {
#@ 	set delay [$w cget -repeatdelay]
#@ 	if {$delay > 0} {
#@ 	    set Priv(afterId) [after $delay 		    [list tk::ScrollSelect $w $element again]]
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::ScrollStartDrag --
#@ # This procedure is called to initiate a drag of the slider.  It just
#@ # remembers the starting position of the mouse and slider.
#@ #
#@ # Arguments:
#@ # w -		The scrollbar widget.
#@ # x, y -	The mouse position at the start of the drag operation.
#@ 
#@ proc ::tk::ScrollStartDrag {w x y} {
#@     variable ::tk::Priv
#@ 
#@     if {[string equal [$w cget -command] ""]} {
#@ 	return
#@     }
#@     set Priv(pressX) $x
#@     set Priv(pressY) $y
#@     set Priv(initValues) [$w get]
#@     set iv0 [lindex $Priv(initValues) 0]
#@     if {[llength $Priv(initValues)] == 2} {
#@ 	set Priv(initPos) $iv0
#@     } elseif {$iv0 == 0} {
#@ 	set Priv(initPos) 0.0
#@     } else {
#@ 	set Priv(initPos) [expr {(double([lindex $Priv(initValues) 2])) 		/ [lindex $Priv(initValues) 0]}]
#@     }
#@ }
#@ 
#@ # ::tk::ScrollDrag --
#@ # This procedure is called for each mouse motion even when the slider
#@ # is being dragged.  It notifies the associated widget if we're not
#@ # jump scrolling, and it just updates the scrollbar if we are jump
#@ # scrolling.
#@ #
#@ # Arguments:
#@ # w -		The scrollbar widget.
#@ # x, y -	The current mouse position.
#@ 
#@ proc ::tk::ScrollDrag {w x y} {
#@     variable ::tk::Priv
#@ 
#@     if {[string equal $Priv(initPos) ""]} {
#@ 	return
#@     }
#@     set delta [$w delta [expr {$x - $Priv(pressX)}] [expr {$y - $Priv(pressY)}]]
#@     if {[$w cget -jump]} {
#@ 	if {[llength $Priv(initValues)] == 2} {
#@ 	    $w set [expr {[lindex $Priv(initValues) 0] + $delta}] 		    [expr {[lindex $Priv(initValues) 1] + $delta}]
#@ 	} else {
#@ 	    set delta [expr {round($delta * [lindex $Priv(initValues) 0])}]
#@ 	    eval [list $w] set [lreplace $Priv(initValues) 2 3 		    [expr {[lindex $Priv(initValues) 2] + $delta}] 		    [expr {[lindex $Priv(initValues) 3] + $delta}]]
#@ 	}
#@     } else {
#@ 	ScrollToPos $w [expr {$Priv(initPos) + $delta}]
#@     }
#@ }
#@ 
#@ # ::tk::ScrollEndDrag --
#@ # This procedure is called to end an interactive drag of the slider.
#@ # It scrolls the window if we're in jump mode, otherwise it does nothing.
#@ #
#@ # Arguments:
#@ # w -		The scrollbar widget.
#@ # x, y -	The mouse position at the end of the drag operation.
#@ 
#@ proc ::tk::ScrollEndDrag {w x y} {
#@     variable ::tk::Priv
#@ 
#@     if {[string equal $Priv(initPos) ""]} {
#@ 	return
#@     }
#@     if {[$w cget -jump]} {
#@ 	set delta [$w delta [expr {$x - $Priv(pressX)}] 		[expr {$y - $Priv(pressY)}]]
#@ 	ScrollToPos $w [expr {$Priv(initPos) + $delta}]
#@     }
#@     set Priv(initPos) ""
#@ }
#@ 
#@ # ::tk::ScrollByUnits --
#@ # This procedure tells the scrollbar's associated widget to scroll up
#@ # or down by a given number of units.  It notifies the associated widget
#@ # in different ways for old and new command syntaxes.
#@ #
#@ # Arguments:
#@ # w -		The scrollbar widget.
#@ # orient -	Which kinds of scrollbars this applies to:  "h" for
#@ #		horizontal, "v" for vertical, "hv" for both.
#@ # amount -	How many units to scroll:  typically 1 or -1.
#@ 
#@ proc ::tk::ScrollByUnits {w orient amount} {
#@     set cmd [$w cget -command]
#@     if {[string equal $cmd ""] || ([string first 	    [string index [$w cget -orient] 0] $orient] < 0)} {
#@ 	return
#@     }
#@     set info [$w get]
#@     if {[llength $info] == 2} {
#@ 	uplevel #0 $cmd scroll $amount units
#@     } else {
#@ 	uplevel #0 $cmd [expr {[lindex $info 2] + $amount}]
#@     }
#@ }
#@ 
#@ # ::tk::ScrollByPages --
#@ # This procedure tells the scrollbar's associated widget to scroll up
#@ # or down by a given number of screenfuls.  It notifies the associated
#@ # widget in different ways for old and new command syntaxes.
#@ #
#@ # Arguments:
#@ # w -		The scrollbar widget.
#@ # orient -	Which kinds of scrollbars this applies to:  "h" for
#@ #		horizontal, "v" for vertical, "hv" for both.
#@ # amount -	How many screens to scroll:  typically 1 or -1.
#@ 
#@ proc ::tk::ScrollByPages {w orient amount} {
#@     set cmd [$w cget -command]
#@     if {[string equal $cmd ""] || ([string first 	    [string index [$w cget -orient] 0] $orient] < 0)} {
#@ 	return
#@     }
#@     set info [$w get]
#@     if {[llength $info] == 2} {
#@ 	uplevel #0 $cmd scroll $amount pages
#@     } else {
#@ 	uplevel #0 $cmd [expr {[lindex $info 2] + $amount*([lindex $info 1] - 1)}]
#@     }
#@ }
#@ 
#@ # ::tk::ScrollToPos --
#@ # This procedure tells the scrollbar's associated widget to scroll to
#@ # a particular location, given by a fraction between 0 and 1.  It notifies
#@ # the associated widget in different ways for old and new command syntaxes.
#@ #
#@ # Arguments:
#@ # w -		The scrollbar widget.
#@ # pos -		A fraction between 0 and 1 indicating a desired position
#@ #		in the document.
#@ 
#@ proc ::tk::ScrollToPos {w pos} {
#@     set cmd [$w cget -command]
#@     if {[string equal $cmd ""]} {
#@ 	return
#@     }
#@     set info [$w get]
#@     if {[llength $info] == 2} {
#@ 	uplevel #0 $cmd moveto $pos
#@     } else {
#@ 	uplevel #0 $cmd [expr {round([lindex $info 0]*$pos)}]
#@     }
#@ }
#@ 
#@ # ::tk::ScrollTopBottom
#@ # Scroll to the top or bottom of the document, depending on the mouse
#@ # position.
#@ #
#@ # Arguments:
#@ # w -		The scrollbar widget.
#@ # x, y -	Mouse coordinates within the widget.
#@ 
#@ proc ::tk::ScrollTopBottom {w x y} {
#@     variable ::tk::Priv
#@     set element [$w identify $x $y]
#@     if {[string match *1 $element]} {
#@ 	ScrollToPos $w 0
#@     } elseif {[string match *2 $element]} {
#@ 	ScrollToPos $w 1
#@     }
#@ 
#@     # Set Priv(relief), since it's needed by tk::ScrollButtonUp.
#@ 
#@     set Priv(relief) [$w cget -activerelief]
#@ }
#@ 
#@ # ::tk::ScrollButton2Down
#@ # This procedure is invoked when button 2 is pressed over a scrollbar.
#@ # If the button is over the trough or slider, it sets the scrollbar to
#@ # the mouse position and starts a slider drag.  Otherwise it just
#@ # behaves the same as button 1.
#@ #
#@ # Arguments:
#@ # w -		The scrollbar widget.
#@ # x, y -	Mouse coordinates within the widget.
#@ 
#@ proc ::tk::ScrollButton2Down {w x y} {
#@     variable ::tk::Priv
#@     set element [$w identify $x $y]
#@     if {[string match {arrow[12]} $element]} {
#@ 	ScrollButtonDown $w $x $y
#@ 	return
#@     }
#@     ScrollToPos $w [$w fraction $x $y]
#@     set Priv(relief) [$w cget -activerelief]
#@ 
#@     # Need the "update idletasks" below so that the widget calls us
#@     # back to reset the actual scrollbar position before we start the
#@     # slider drag.
#@ 
#@     update idletasks
#@     $w configure -activerelief sunken
#@     $w activate slider
#@     ScrollStartDrag $w $x $y
#@ }
#@ # -- End source /usr/cad/synopsys/synthesis/cur/auxx/tcllib/lib/tk8.4/scrlbar.tcl

#@ # spinbox.tcl --
#@ #
#@ # This file defines the default bindings for Tk spinbox widgets and provides
#@ # procedures that help in implementing those bindings.  The spinbox builds
#@ # off the entry widget, so it can reuse Entry bindings and procedures.
#@ #
#@ # RCS: @(#) $Id: //sde/tcl/tk8.4r/rel1/library/spinbox.tcl#1 $
#@ #
#@ # Copyright (c) 1992-1994 The Regents of the University of California.
#@ # Copyright (c) 1994-1997 Sun Microsystems, Inc.
#@ # Copyright (c) 1999-2000 Jeffrey Hobbs
#@ # Copyright (c) 2000 Ajuba Solutions
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ #
#@ 
#@ #-------------------------------------------------------------------------
#@ # Elements of tk::Priv that are used in this file:
#@ #
#@ # afterId -		If non-null, it means that auto-scanning is underway
#@ #			and it gives the "after" id for the next auto-scan
#@ #			command to be executed.
#@ # mouseMoved -		Non-zero means the mouse has moved a significant
#@ #			amount since the button went down (so, for example,
#@ #			start dragging out a selection).
#@ # pressX -		X-coordinate at which the mouse button was pressed.
#@ # selectMode -		The style of selection currently underway:
#@ #			char, word, or line.
#@ # x, y -		Last known mouse coordinates for scanning
#@ #			and auto-scanning.
#@ # data -		Used for Cut and Copy
#@ #-------------------------------------------------------------------------
#@ 
#@ # Initialize namespace
#@ namespace eval ::tk::spinbox {}
#@ 
#@ #-------------------------------------------------------------------------
#@ # The code below creates the default class bindings for entries.
#@ #-------------------------------------------------------------------------
#@ bind Spinbox <<Cut>> {
#@     if {![catch {::tk::spinbox::GetSelection %W} tk::Priv(data)]} {
#@ 	clipboard clear -displayof %W
#@ 	clipboard append -displayof %W $tk::Priv(data)
#@ 	%W delete sel.first sel.last
#@ 	unset tk::Priv(data)
#@     }
#@ }
#@ bind Spinbox <<Copy>> {
#@     if {![catch {::tk::spinbox::GetSelection %W} tk::Priv(data)]} {
#@ 	clipboard clear -displayof %W
#@ 	clipboard append -displayof %W $tk::Priv(data)
#@ 	unset tk::Priv(data)
#@     }
#@ }
#@ bind Spinbox <<Paste>> {
#@     global tcl_platform
#@     catch {
#@ 	if {[tk windowingsystem] ne "x11"} {
#@ 	    catch {
#@ 		%W delete sel.first sel.last
#@ 	    }
#@ 	}
#@ 	%W insert insert [::tk::GetSelection %W CLIPBOARD]
#@ 	::tk::EntrySeeInsert %W
#@     }
#@ }
#@ bind Spinbox <<Clear>> {
#@     %W delete sel.first sel.last
#@ }
#@ bind Spinbox <<PasteSelection>> {
#@     if {$tk_strictMotif || ![info exists tk::Priv(mouseMoved)]
#@ 	|| !$tk::Priv(mouseMoved)} {
#@ 	::tk::spinbox::Paste %W %x
#@     }
#@ }
#@ 
#@ # Standard Motif bindings:
#@ 
#@ bind Spinbox <1> {
#@     ::tk::spinbox::ButtonDown %W %x %y
#@ }
#@ bind Spinbox <B1-Motion> {
#@     ::tk::spinbox::Motion %W %x %y
#@ }
#@ bind Spinbox <Double-1> {
#@     set tk::Priv(selectMode) word
#@     ::tk::spinbox::MouseSelect %W %x sel.first
#@ }
#@ bind Spinbox <Triple-1> {
#@     set tk::Priv(selectMode) line
#@     ::tk::spinbox::MouseSelect %W %x 0
#@ }
#@ bind Spinbox <Shift-1> {
#@     set tk::Priv(selectMode) char
#@     %W selection adjust @%x
#@ }
#@ bind Spinbox <Double-Shift-1> {
#@     set tk::Priv(selectMode) word
#@     ::tk::spinbox::MouseSelect %W %x
#@ }
#@ bind Spinbox <Triple-Shift-1> {
#@     set tk::Priv(selectMode) line
#@     ::tk::spinbox::MouseSelect %W %x
#@ }
#@ bind Spinbox <B1-Leave> {
#@     set tk::Priv(x) %x
#@     ::tk::spinbox::AutoScan %W
#@ }
#@ bind Spinbox <B1-Enter> {
#@     tk::CancelRepeat
#@ }
#@ bind Spinbox <ButtonRelease-1> {
#@     ::tk::spinbox::ButtonUp %W %x %y
#@ }
#@ bind Spinbox <Control-1> {
#@     %W icursor @%x
#@ }
#@ 
#@ bind Spinbox <Up> {
#@     %W invoke buttonup
#@ }
#@ bind Spinbox <Down> {
#@     %W invoke buttondown
#@ }
#@ 
#@ bind Spinbox <Left> {
#@     ::tk::EntrySetCursor %W [expr {[%W index insert] - 1}]
#@ }
#@ bind Spinbox <Right> {
#@     ::tk::EntrySetCursor %W [expr {[%W index insert] + 1}]
#@ }
#@ bind Spinbox <Shift-Left> {
#@     ::tk::EntryKeySelect %W [expr {[%W index insert] - 1}]
#@     ::tk::EntrySeeInsert %W
#@ }
#@ bind Spinbox <Shift-Right> {
#@     ::tk::EntryKeySelect %W [expr {[%W index insert] + 1}]
#@     ::tk::EntrySeeInsert %W
#@ }
#@ bind Spinbox <Control-Left> {
#@     ::tk::EntrySetCursor %W [::tk::EntryPreviousWord %W insert]
#@ }
#@ bind Spinbox <Control-Right> {
#@     ::tk::EntrySetCursor %W [::tk::EntryNextWord %W insert]
#@ }
#@ bind Spinbox <Shift-Control-Left> {
#@     ::tk::EntryKeySelect %W [::tk::EntryPreviousWord %W insert]
#@     ::tk::EntrySeeInsert %W
#@ }
#@ bind Spinbox <Shift-Control-Right> {
#@     ::tk::EntryKeySelect %W [::tk::EntryNextWord %W insert]
#@     ::tk::EntrySeeInsert %W
#@ }
#@ bind Spinbox <Home> {
#@     ::tk::EntrySetCursor %W 0
#@ }
#@ bind Spinbox <Shift-Home> {
#@     ::tk::EntryKeySelect %W 0
#@     ::tk::EntrySeeInsert %W
#@ }
#@ bind Spinbox <End> {
#@     ::tk::EntrySetCursor %W end
#@ }
#@ bind Spinbox <Shift-End> {
#@     ::tk::EntryKeySelect %W end
#@     ::tk::EntrySeeInsert %W
#@ }
#@ 
#@ bind Spinbox <Delete> {
#@     if {[%W selection present]} {
#@ 	%W delete sel.first sel.last
#@     } else {
#@ 	%W delete insert
#@     }
#@ }
#@ bind Spinbox <BackSpace> {
#@     ::tk::EntryBackspace %W
#@ }
#@ 
#@ bind Spinbox <Control-space> {
#@     %W selection from insert
#@ }
#@ bind Spinbox <Select> {
#@     %W selection from insert
#@ }
#@ bind Spinbox <Control-Shift-space> {
#@     %W selection adjust insert
#@ }
#@ bind Spinbox <Shift-Select> {
#@     %W selection adjust insert
#@ }
#@ bind Spinbox <Control-slash> {
#@     %W selection range 0 end
#@ }
#@ bind Spinbox <Control-backslash> {
#@     %W selection clear
#@ }
#@ bind Spinbox <KeyPress> {
#@     ::tk::EntryInsert %W %A
#@ }
#@ 
#@ # Ignore all Alt, Meta, and Control keypresses unless explicitly bound.
#@ # Otherwise, if a widget binding for one of these is defined, the
#@ # <KeyPress> class binding will also fire and insert the character,
#@ # which is wrong.  Ditto for Escape, Return, and Tab.
#@ 
#@ bind Spinbox <Alt-KeyPress> {# nothing}
#@ bind Spinbox <Meta-KeyPress> {# nothing}
#@ bind Spinbox <Control-KeyPress> {# nothing}
#@ bind Spinbox <Escape> {# nothing}
#@ bind Spinbox <Return> {# nothing}
#@ bind Spinbox <KP_Enter> {# nothing}
#@ bind Spinbox <Tab> {# nothing}
#@ if {[string equal [tk windowingsystem] "classic"]
#@ 	|| [string equal [tk windowingsystem] "aqua"]} {
#@ 	bind Spinbox <Command-KeyPress> {# nothing}
#@ }
#@ 
#@ # On Windows, paste is done using Shift-Insert.  Shift-Insert already
#@ # generates the <<Paste>> event, so we don't need to do anything here.
#@ if {[string compare $tcl_platform(platform) "windows"]} {
#@     bind Spinbox <Insert> {
#@ 	catch {::tk::EntryInsert %W [::tk::GetSelection %W PRIMARY]}
#@     }
#@ }
#@ 
#@ # Additional emacs-like bindings:
#@ 
#@ bind Spinbox <Control-a> {
#@     if {!$tk_strictMotif} {
#@ 	::tk::EntrySetCursor %W 0
#@     }
#@ }
#@ bind Spinbox <Control-b> {
#@     if {!$tk_strictMotif} {
#@ 	::tk::EntrySetCursor %W [expr {[%W index insert] - 1}]
#@     }
#@ }
#@ bind Spinbox <Control-d> {
#@     if {!$tk_strictMotif} {
#@ 	%W delete insert
#@     }
#@ }
#@ bind Spinbox <Control-e> {
#@     if {!$tk_strictMotif} {
#@ 	::tk::EntrySetCursor %W end
#@     }
#@ }
#@ bind Spinbox <Control-f> {
#@     if {!$tk_strictMotif} {
#@ 	::tk::EntrySetCursor %W [expr {[%W index insert] + 1}]
#@     }
#@ }
#@ bind Spinbox <Control-h> {
#@     if {!$tk_strictMotif} {
#@ 	::tk::EntryBackspace %W
#@     }
#@ }
#@ bind Spinbox <Control-k> {
#@     if {!$tk_strictMotif} {
#@ 	%W delete insert end
#@     }
#@ }
#@ bind Spinbox <Control-t> {
#@     if {!$tk_strictMotif} {
#@ 	::tk::EntryTranspose %W
#@     }
#@ }
#@ bind Spinbox <Meta-b> {
#@     if {!$tk_strictMotif} {
#@ 	::tk::EntrySetCursor %W [::tk::EntryPreviousWord %W insert]
#@     }
#@ }
#@ bind Spinbox <Meta-d> {
#@     if {!$tk_strictMotif} {
#@ 	%W delete insert [::tk::EntryNextWord %W insert]
#@     }
#@ }
#@ bind Spinbox <Meta-f> {
#@     if {!$tk_strictMotif} {
#@ 	::tk::EntrySetCursor %W [::tk::EntryNextWord %W insert]
#@     }
#@ }
#@ bind Spinbox <Meta-BackSpace> {
#@     if {!$tk_strictMotif} {
#@ 	%W delete [::tk::EntryPreviousWord %W insert] insert
#@     }
#@ }
#@ bind Spinbox <Meta-Delete> {
#@     if {!$tk_strictMotif} {
#@ 	%W delete [::tk::EntryPreviousWord %W insert] insert
#@     }
#@ }
#@ 
#@ # A few additional bindings of my own.
#@ 
#@ bind Spinbox <2> {
#@     if {!$tk_strictMotif} {
#@ 	::tk::EntryScanMark %W %x
#@     }
#@ }
#@ bind Spinbox <B2-Motion> {
#@     if {!$tk_strictMotif} {
#@ 	::tk::EntryScanDrag %W %x
#@     }
#@ }
#@ 
#@ # ::tk::spinbox::Invoke --
#@ # Invoke an element of the spinbox
#@ #
#@ # Arguments:
#@ # w -		The spinbox window.
#@ # elem -	Element to invoke
#@ 
#@ proc ::tk::spinbox::Invoke {w elem} {
#@     variable ::tk::Priv
#@ 
#@     if {![info exists Priv(outsideElement)]} {
#@ 	$w invoke $elem
#@ 	incr Priv(repeated)
#@     }
#@     set delay [$w cget -repeatinterval]
#@     if {$delay > 0} {
#@ 	set Priv(afterId) [after $delay 		[list ::tk::spinbox::Invoke $w $elem]]
#@     }
#@ }
#@ 
#@ # ::tk::spinbox::ClosestGap --
#@ # Given x and y coordinates, this procedure finds the closest boundary
#@ # between characters to the given coordinates and returns the index
#@ # of the character just after the boundary.
#@ #
#@ # Arguments:
#@ # w -		The spinbox window.
#@ # x -		X-coordinate within the window.
#@ 
#@ proc ::tk::spinbox::ClosestGap {w x} {
#@     set pos [$w index @$x]
#@     set bbox [$w bbox $pos]
#@     if {($x - [lindex $bbox 0]) < ([lindex $bbox 2]/2)} {
#@ 	return $pos
#@     }
#@     incr pos
#@ }
#@ 
#@ # ::tk::spinbox::ButtonDown --
#@ # This procedure is invoked to handle button-1 presses in spinbox
#@ # widgets.  It moves the insertion cursor, sets the selection anchor,
#@ # and claims the input focus.
#@ #
#@ # Arguments:
#@ # w -		The spinbox window in which the button was pressed.
#@ # x -		The x-coordinate of the button press.
#@ 
#@ proc ::tk::spinbox::ButtonDown {w x y} {
#@     variable ::tk::Priv
#@ 
#@     # Get the element that was clicked in.  If we are not directly over
#@     # the spinbox, default to entry.  This is necessary for spinbox grabs.
#@     #
#@     set Priv(element) [$w identify $x $y]
#@     if {$Priv(element) eq ""} {
#@ 	set Priv(element) "entry"
#@     }
#@ 
#@     switch -exact $Priv(element) {
#@ 	"buttonup" - "buttondown" {
#@ 	    if {"disabled" ne [$w cget -state]} {
#@ 		$w selection element $Priv(element)
#@ 		set Priv(repeated) 0
#@ 		set Priv(relief) [$w cget -$Priv(element)relief]
#@ 		catch {after cancel $Priv(afterId)}
#@ 		set delay [$w cget -repeatdelay]
#@ 		if {$delay > 0} {
#@ 		    set Priv(afterId) [after $delay 			    [list ::tk::spinbox::Invoke $w $Priv(element)]]
#@ 		}
#@ 		if {[info exists Priv(outsideElement)]} {
#@ 		    unset Priv(outsideElement)
#@ 		}
#@ 	    }
#@ 	}
#@ 	"entry" {
#@ 	    set Priv(selectMode) char
#@ 	    set Priv(mouseMoved) 0
#@ 	    set Priv(pressX) $x
#@ 	    $w icursor [::tk::spinbox::ClosestGap $w $x]
#@ 	    $w selection from insert
#@ 	    if {"disabled" ne [$w cget -state]} {focus $w}
#@ 	    $w selection clear
#@ 	}
#@ 	default {
#@ 	    return -code error "unknown spinbox element \"$Priv(element)\""
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::spinbox::ButtonUp --
#@ # This procedure is invoked to handle button-1 releases in spinbox
#@ # widgets.
#@ #
#@ # Arguments:
#@ # w -		The spinbox window in which the button was pressed.
#@ # x -		The x-coordinate of the button press.
#@ 
#@ proc ::tk::spinbox::ButtonUp {w x y} {
#@     variable ::tk::Priv
#@ 
#@     ::tk::CancelRepeat
#@ 
#@     # Priv(relief) may not exist if the ButtonUp is not paired with
#@     # a preceding ButtonDown
#@     if {[info exists Priv(element)] && [info exists Priv(relief)] && 	    [string match "button*" $Priv(element)]} {
#@ 	if {[info exists Priv(repeated)] && !$Priv(repeated)} {
#@ 	    $w invoke $Priv(element)
#@ 	}
#@ 	$w configure -$Priv(element)relief $Priv(relief)
#@ 	$w selection element none
#@     }
#@ }
#@ 
#@ # ::tk::spinbox::MouseSelect --
#@ # This procedure is invoked when dragging out a selection with
#@ # the mouse.  Depending on the selection mode (character, word,
#@ # line) it selects in different-sized units.  This procedure
#@ # ignores mouse motions initially until the mouse has moved from
#@ # one character to another or until there have been multiple clicks.
#@ #
#@ # Arguments:
#@ # w -		The spinbox window in which the button was pressed.
#@ # x -		The x-coordinate of the mouse.
#@ # cursor -	optional place to set cursor.
#@ 
#@ proc ::tk::spinbox::MouseSelect {w x {cursor {}}} {
#@     variable ::tk::Priv
#@ 
#@     if {$Priv(element) ne "entry"} {
#@ 	# The ButtonUp command triggered by ButtonRelease-1 handles
#@ 	# invoking one of the spinbuttons.
#@ 	return
#@     }
#@     set cur [::tk::spinbox::ClosestGap $w $x]
#@     set anchor [$w index anchor]
#@     if {($cur ne $anchor) || (abs($Priv(pressX) - $x) >= 3)} {
#@ 	set Priv(mouseMoved) 1
#@     }
#@     switch $Priv(selectMode) {
#@ 	char {
#@ 	    if {$Priv(mouseMoved)} {
#@ 		if {$cur < $anchor} {
#@ 		    $w selection range $cur $anchor
#@ 		} elseif {$cur > $anchor} {
#@ 		    $w selection range $anchor $cur
#@ 		} else {
#@ 		    $w selection clear
#@ 		}
#@ 	    }
#@ 	}
#@ 	word {
#@ 	    if {$cur < [$w index anchor]} {
#@ 		set before [tcl_wordBreakBefore [$w get] $cur]
#@ 		set after [tcl_wordBreakAfter [$w get] [expr {$anchor-1}]]
#@ 	    } else {
#@ 		set before [tcl_wordBreakBefore [$w get] $anchor]
#@ 		set after [tcl_wordBreakAfter [$w get] [expr {$cur - 1}]]
#@ 	    }
#@ 	    if {$before < 0} {
#@ 		set before 0
#@ 	    }
#@ 	    if {$after < 0} {
#@ 		set after end
#@ 	    }
#@ 	    $w selection range $before $after
#@ 	}
#@ 	line {
#@ 	    $w selection range 0 end
#@ 	}
#@     }
#@     if {$cursor ne {} && $cursor ne "ignore"} {
#@ 	catch {$w icursor $cursor}
#@     }
#@     update idletasks
#@ }
#@ 
#@ # ::tk::spinbox::Paste --
#@ # This procedure sets the insertion cursor to the current mouse position,
#@ # pastes the selection there, and sets the focus to the window.
#@ #
#@ # Arguments:
#@ # w -		The spinbox window.
#@ # x -		X position of the mouse.
#@ 
#@ proc ::tk::spinbox::Paste {w x} {
#@     $w icursor [::tk::spinbox::ClosestGap $w $x]
#@     catch {$w insert insert [::tk::GetSelection $w PRIMARY]}
#@     if {[string equal "disabled" [$w cget -state]]} {focus $w}
#@ }
#@ 
#@ # ::tk::spinbox::Motion --
#@ # This procedure is invoked when the mouse moves in a spinbox window
#@ # with button 1 down.
#@ #
#@ # Arguments:
#@ # w -		The spinbox window.
#@ 
#@ proc ::tk::spinbox::Motion {w x y} {
#@     variable ::tk::Priv
#@ 
#@     if {![info exists Priv(element)]} {
#@ 	set Priv(element) [$w identify $x $y]
#@     }
#@ 
#@     set Priv(x) $x
#@     if {"entry" eq $Priv(element)} {
#@ 	::tk::spinbox::MouseSelect $w $x ignore
#@     } elseif {[$w identify $x $y] ne $Priv(element)} {
#@ 	if {![info exists Priv(outsideElement)]} {
#@ 	    # We've wandered out of the spin button
#@ 	    # setting outside element will cause ::tk::spinbox::Invoke to
#@ 	    # loop without doing anything
#@ 	    set Priv(outsideElement) ""
#@ 	    $w selection element none
#@ 	}
#@     } elseif {[info exists Priv(outsideElement)]} {
#@ 	unset Priv(outsideElement)
#@ 	$w selection element $Priv(element)
#@     }
#@ }
#@ 
#@ # ::tk::spinbox::AutoScan --
#@ # This procedure is invoked when the mouse leaves an spinbox window
#@ # with button 1 down.  It scrolls the window left or right,
#@ # depending on where the mouse is, and reschedules itself as an
#@ # "after" command so that the window continues to scroll until the
#@ # mouse moves back into the window or the mouse button is released.
#@ #
#@ # Arguments:
#@ # w -		The spinbox window.
#@ 
#@ proc ::tk::spinbox::AutoScan {w} {
#@     variable ::tk::Priv
#@ 
#@     set x $Priv(x)
#@     if {$x >= [winfo width $w]} {
#@ 	$w xview scroll 2 units
#@ 	::tk::spinbox::MouseSelect $w $x ignore
#@     } elseif {$x < 0} {
#@ 	$w xview scroll -2 units
#@ 	::tk::spinbox::MouseSelect $w $x ignore
#@     }
#@     set Priv(afterId) [after 50 [list ::tk::spinbox::AutoScan $w]]
#@ }
#@ 
#@ # ::tk::spinbox::GetSelection --
#@ #
#@ # Returns the selected text of the spinbox.  Differs from entry in that
#@ # a spinbox has no -show option to obscure contents.
#@ #
#@ # Arguments:
#@ # w -         The spinbox window from which the text to get
#@ 
#@ proc ::tk::spinbox::GetSelection {w} {
#@     return [string range [$w get] [$w index sel.first] 	    [expr {[$w index sel.last] - 1}]]
#@ }
#@ # -- End source /usr/cad/synopsys/synthesis/cur/auxx/tcllib/lib/tk8.4/spinbox.tcl

#@ # text.tcl --
#@ #
#@ # This file defines the default bindings for Tk text widgets and provides
#@ # procedures that help in implementing the bindings.
#@ #
#@ # RCS: @(#) $Id: //sde/tcl/tk8.4r/rel1/library/text.tcl#1 $
#@ #
#@ # Copyright (c) 1992-1994 The Regents of the University of California.
#@ # Copyright (c) 1994-1997 Sun Microsystems, Inc.
#@ # Copyright (c) 1998 by Scriptics Corporation.
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ #
#@ 
#@ #-------------------------------------------------------------------------
#@ # Elements of ::tk::Priv that are used in this file:
#@ #
#@ # afterId -		If non-null, it means that auto-scanning is underway
#@ #			and it gives the "after" id for the next auto-scan
#@ #			command to be executed.
#@ # char -		Character position on the line;  kept in order
#@ #			to allow moving up or down past short lines while
#@ #			still remembering the desired position.
#@ # mouseMoved -		Non-zero means the mouse has moved a significant
#@ #			amount since the button went down (so, for example,
#@ #			start dragging out a selection).
#@ # prevPos -		Used when moving up or down lines via the keyboard.
#@ #			Keeps track of the previous insert position, so
#@ #			we can distinguish a series of ups and downs, all
#@ #			in a row, from a new up or down.
#@ # selectMode -		The style of selection currently underway:
#@ #			char, word, or line.
#@ # x, y -		Last known mouse coordinates for scanning
#@ #			and auto-scanning.
#@ #-------------------------------------------------------------------------
#@ 
#@ #-------------------------------------------------------------------------
#@ # The code below creates the default class bindings for text widgets.
#@ #-------------------------------------------------------------------------
#@ 
#@ # Standard Motif bindings:
#@ 
#@ bind Text <1> {
#@     tk::TextButton1 %W %x %y
#@     %W tag remove sel 0.0 end
#@ }
#@ bind Text <B1-Motion> {
#@     set tk::Priv(x) %x
#@     set tk::Priv(y) %y
#@     tk::TextSelectTo %W %x %y
#@ }
#@ bind Text <Double-1> {
#@     set tk::Priv(selectMode) word
#@     tk::TextSelectTo %W %x %y
#@     catch {%W mark set insert sel.last}
#@ }
#@ bind Text <Triple-1> {
#@     set tk::Priv(selectMode) line
#@     tk::TextSelectTo %W %x %y
#@     catch {%W mark set insert sel.last}
#@ }
#@ bind Text <Shift-1> {
#@     tk::TextResetAnchor %W @%x,%y
#@     set tk::Priv(selectMode) char
#@     tk::TextSelectTo %W %x %y
#@ }
#@ bind Text <Double-Shift-1>	{
#@     set tk::Priv(selectMode) word
#@     tk::TextSelectTo %W %x %y 1
#@ }
#@ bind Text <Triple-Shift-1>	{
#@     set tk::Priv(selectMode) line
#@     tk::TextSelectTo %W %x %y
#@ }
#@ bind Text <B1-Leave> {
#@     set tk::Priv(x) %x
#@     set tk::Priv(y) %y
#@     tk::TextAutoScan %W
#@ }
#@ bind Text <B1-Enter> {
#@     tk::CancelRepeat
#@ }
#@ bind Text <ButtonRelease-1> {
#@     tk::CancelRepeat
#@ }
#@ bind Text <Control-1> {
#@     %W mark set insert @%x,%y
#@ }
#@ bind Text <Left> {
#@     tk::TextSetCursor %W insert-1c
#@ }
#@ bind Text <Right> {
#@     tk::TextSetCursor %W insert+1c
#@ }
#@ bind Text <Up> {
#@     tk::TextSetCursor %W [tk::TextUpDownLine %W -1]
#@ }
#@ bind Text <Down> {
#@     tk::TextSetCursor %W [tk::TextUpDownLine %W 1]
#@ }
#@ bind Text <Shift-Left> {
#@     tk::TextKeySelect %W [%W index {insert - 1c}]
#@ }
#@ bind Text <Shift-Right> {
#@     tk::TextKeySelect %W [%W index {insert + 1c}]
#@ }
#@ bind Text <Shift-Up> {
#@     tk::TextKeySelect %W [tk::TextUpDownLine %W -1]
#@ }
#@ bind Text <Shift-Down> {
#@     tk::TextKeySelect %W [tk::TextUpDownLine %W 1]
#@ }
#@ bind Text <Control-Left> {
#@     tk::TextSetCursor %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
#@ }
#@ bind Text <Control-Right> {
#@     tk::TextSetCursor %W [tk::TextNextWord %W insert]
#@ }
#@ bind Text <Control-Up> {
#@     tk::TextSetCursor %W [tk::TextPrevPara %W insert]
#@ }
#@ bind Text <Control-Down> {
#@     tk::TextSetCursor %W [tk::TextNextPara %W insert]
#@ }
#@ bind Text <Shift-Control-Left> {
#@     tk::TextKeySelect %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
#@ }
#@ bind Text <Shift-Control-Right> {
#@     tk::TextKeySelect %W [tk::TextNextWord %W insert]
#@ }
#@ bind Text <Shift-Control-Up> {
#@     tk::TextKeySelect %W [tk::TextPrevPara %W insert]
#@ }
#@ bind Text <Shift-Control-Down> {
#@     tk::TextKeySelect %W [tk::TextNextPara %W insert]
#@ }
#@ bind Text <Prior> {
#@     tk::TextSetCursor %W [tk::TextScrollPages %W -1]
#@ }
#@ bind Text <Shift-Prior> {
#@     tk::TextKeySelect %W [tk::TextScrollPages %W -1]
#@ }
#@ bind Text <Next> {
#@     tk::TextSetCursor %W [tk::TextScrollPages %W 1]
#@ }
#@ bind Text <Shift-Next> {
#@     tk::TextKeySelect %W [tk::TextScrollPages %W 1]
#@ }
#@ bind Text <Control-Prior> {
#@     %W xview scroll -1 page
#@ }
#@ bind Text <Control-Next> {
#@     %W xview scroll 1 page
#@ }
#@ 
#@ bind Text <Home> {
#@     tk::TextSetCursor %W {insert linestart}
#@ }
#@ bind Text <Shift-Home> {
#@     tk::TextKeySelect %W {insert linestart}
#@ }
#@ bind Text <End> {
#@     tk::TextSetCursor %W {insert lineend}
#@ }
#@ bind Text <Shift-End> {
#@     tk::TextKeySelect %W {insert lineend}
#@ }
#@ bind Text <Control-Home> {
#@     tk::TextSetCursor %W 1.0
#@ }
#@ bind Text <Control-Shift-Home> {
#@     tk::TextKeySelect %W 1.0
#@ }
#@ bind Text <Control-End> {
#@     tk::TextSetCursor %W {end - 1 char}
#@ }
#@ bind Text <Control-Shift-End> {
#@     tk::TextKeySelect %W {end - 1 char}
#@ }
#@ 
#@ bind Text <Tab> {
#@     if { [string equal [%W cget -state] "normal"] } {
#@ 	tk::TextInsert %W \t
#@ 	focus %W
#@ 	break
#@     }
#@ }
#@ bind Text <Shift-Tab> {
#@     # Needed only to keep <Tab> binding from triggering;  doesn't
#@     # have to actually do anything.
#@     break
#@ }
#@ bind Text <Control-Tab> {
#@     focus [tk_focusNext %W]
#@ }
#@ bind Text <Control-Shift-Tab> {
#@     focus [tk_focusPrev %W]
#@ }
#@ bind Text <Control-i> {
#@     tk::TextInsert %W \t
#@ }
#@ bind Text <Return> {
#@     tk::TextInsert %W \n
#@     if {[%W cget -autoseparators]} {%W edit separator}
#@ }
#@ bind Text <Delete> {
#@     if {[string compare [%W tag nextrange sel 1.0 end] ""]} {
#@ 	%W delete sel.first sel.last
#@     } else {
#@ 	%W delete insert
#@ 	%W see insert
#@     }
#@ }
#@ bind Text <BackSpace> {
#@     if {[string compare [%W tag nextrange sel 1.0 end] ""]} {
#@ 	%W delete sel.first sel.last
#@     } elseif {[%W compare insert != 1.0]} {
#@ 	%W delete insert-1c
#@ 	%W see insert
#@     }
#@ }
#@ 
#@ bind Text <Control-space> {
#@     %W mark set anchor insert
#@ }
#@ bind Text <Select> {
#@     %W mark set anchor insert
#@ }
#@ bind Text <Control-Shift-space> {
#@     set tk::Priv(selectMode) char
#@     tk::TextKeyExtend %W insert
#@ }
#@ bind Text <Shift-Select> {
#@     set tk::Priv(selectMode) char
#@     tk::TextKeyExtend %W insert
#@ }
#@ bind Text <Control-slash> {
#@     %W tag add sel 1.0 end
#@ }
#@ bind Text <Control-backslash> {
#@     %W tag remove sel 1.0 end
#@ }
#@ bind Text <<Cut>> {
#@     tk_textCut %W
#@ }
#@ bind Text <<Copy>> {
#@     tk_textCopy %W
#@ }
#@ bind Text <<Paste>> {
#@     tk_textPaste %W
#@ }
#@ bind Text <<Clear>> {
#@     catch {%W delete sel.first sel.last}
#@ }
#@ bind Text <<PasteSelection>> {
#@     if {$tk_strictMotif || ![info exists tk::Priv(mouseMoved)]
#@ 	|| !$tk::Priv(mouseMoved)} {
#@ 	tk::TextPasteSelection %W %x %y
#@     }
#@ }
#@ bind Text <Insert> {
#@     catch {tk::TextInsert %W [::tk::GetSelection %W PRIMARY]}
#@ }
#@ bind Text <KeyPress> {
#@     tk::TextInsert %W %A
#@ }
#@ 
#@ # Ignore all Alt, Meta, and Control keypresses unless explicitly bound.
#@ # Otherwise, if a widget binding for one of these is defined, the
#@ # <KeyPress> class binding will also fire and insert the character,
#@ # which is wrong.  Ditto for <Escape>.
#@ 
#@ bind Text <Alt-KeyPress> {# nothing }
#@ bind Text <Meta-KeyPress> {# nothing}
#@ bind Text <Control-KeyPress> {# nothing}
#@ bind Text <Escape> {# nothing}
#@ bind Text <KP_Enter> {# nothing}
#@ if {[string equal [tk windowingsystem] "classic"]
#@ 	|| [string equal [tk windowingsystem] "aqua"]} {
#@     bind Text <Command-KeyPress> {# nothing}
#@ }
#@ 
#@ # Additional emacs-like bindings:
#@ 
#@ bind Text <Control-a> {
#@     if {!$tk_strictMotif} {
#@ 	tk::TextSetCursor %W {insert linestart}
#@     }
#@ }
#@ bind Text <Control-b> {
#@     if {!$tk_strictMotif} {
#@ 	tk::TextSetCursor %W insert-1c
#@     }
#@ }
#@ bind Text <Control-d> {
#@     if {!$tk_strictMotif} {
#@ 	%W delete insert
#@     }
#@ }
#@ bind Text <Control-e> {
#@     if {!$tk_strictMotif} {
#@ 	tk::TextSetCursor %W {insert lineend}
#@     }
#@ }
#@ bind Text <Control-f> {
#@     if {!$tk_strictMotif} {
#@ 	tk::TextSetCursor %W insert+1c
#@     }
#@ }
#@ bind Text <Control-k> {
#@     if {!$tk_strictMotif} {
#@ 	if {[%W compare insert == {insert lineend}]} {
#@ 	    %W delete insert
#@ 	} else {
#@ 	    %W delete insert {insert lineend}
#@ 	}
#@     }
#@ }
#@ bind Text <Control-n> {
#@     if {!$tk_strictMotif} {
#@ 	tk::TextSetCursor %W [tk::TextUpDownLine %W 1]
#@     }
#@ }
#@ bind Text <Control-o> {
#@     if {!$tk_strictMotif} {
#@ 	%W insert insert \n
#@ 	%W mark set insert insert-1c
#@     }
#@ }
#@ bind Text <Control-p> {
#@     if {!$tk_strictMotif} {
#@ 	tk::TextSetCursor %W [tk::TextUpDownLine %W -1]
#@     }
#@ }
#@ bind Text <Control-t> {
#@     if {!$tk_strictMotif} {
#@ 	tk::TextTranspose %W
#@     }
#@ }
#@ 
#@ bind Text <<Undo>> {
#@     catch { %W edit undo }
#@ }
#@ 
#@ bind Text <<Redo>> {
#@     catch { %W edit redo }
#@ }
#@ 
#@ if {[string compare $tcl_platform(platform) "windows"]} {
#@ bind Text <Control-v> {
#@     if {!$tk_strictMotif} {
#@ 	tk::TextScrollPages %W 1
#@     }
#@ }
#@ }
#@ 
#@ bind Text <Meta-b> {
#@     if {!$tk_strictMotif} {
#@ 	tk::TextSetCursor %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
#@     }
#@ }
#@ bind Text <Meta-d> {
#@     if {!$tk_strictMotif} {
#@ 	%W delete insert [tk::TextNextWord %W insert]
#@     }
#@ }
#@ bind Text <Meta-f> {
#@     if {!$tk_strictMotif} {
#@ 	tk::TextSetCursor %W [tk::TextNextWord %W insert]
#@     }
#@ }
#@ bind Text <Meta-less> {
#@     if {!$tk_strictMotif} {
#@ 	tk::TextSetCursor %W 1.0
#@     }
#@ }
#@ bind Text <Meta-greater> {
#@     if {!$tk_strictMotif} {
#@ 	tk::TextSetCursor %W end-1c
#@     }
#@ }
#@ bind Text <Meta-BackSpace> {
#@     if {!$tk_strictMotif} {
#@ 	%W delete [tk::TextPrevPos %W insert tcl_startOfPreviousWord] insert
#@     }
#@ }
#@ bind Text <Meta-Delete> {
#@     if {!$tk_strictMotif} {
#@ 	%W delete [tk::TextPrevPos %W insert tcl_startOfPreviousWord] insert
#@     }
#@ }
#@ 
#@ # Macintosh only bindings:
#@ 
#@ # if text black & highlight black -> text white, other text the same
#@ if {[string equal [tk windowingsystem] "classic"]
#@ 	|| [string equal [tk windowingsystem] "aqua"]} {
#@ bind Text <FocusIn> {
#@     %W tag configure sel -borderwidth 0
#@     %W configure -selectbackground systemHighlight -selectforeground systemHighlightText
#@ }
#@ bind Text <FocusOut> {
#@     %W tag configure sel -borderwidth 1
#@     %W configure -selectbackground white -selectforeground black
#@ }
#@ bind Text <Option-Left> {
#@     tk::TextSetCursor %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
#@ }
#@ bind Text <Option-Right> {
#@     tk::TextSetCursor %W [tk::TextNextWord %W insert]
#@ }
#@ bind Text <Option-Up> {
#@     tk::TextSetCursor %W [tk::TextPrevPara %W insert]
#@ }
#@ bind Text <Option-Down> {
#@     tk::TextSetCursor %W [tk::TextNextPara %W insert]
#@ }
#@ bind Text <Shift-Option-Left> {
#@     tk::TextKeySelect %W [tk::TextPrevPos %W insert tcl_startOfPreviousWord]
#@ }
#@ bind Text <Shift-Option-Right> {
#@     tk::TextKeySelect %W [tk::TextNextWord %W insert]
#@ }
#@ bind Text <Shift-Option-Up> {
#@     tk::TextKeySelect %W [tk::TextPrevPara %W insert]
#@ }
#@ bind Text <Shift-Option-Down> {
#@     tk::TextKeySelect %W [tk::TextNextPara %W insert]
#@ }
#@ 
#@ # End of Mac only bindings
#@ }
#@ 
#@ # A few additional bindings of my own.
#@ 
#@ bind Text <Control-h> {
#@     if {!$tk_strictMotif} {
#@ 	if {[%W compare insert != 1.0]} {
#@ 	    %W delete insert-1c
#@ 	    %W see insert
#@ 	}
#@     }
#@ }
#@ bind Text <2> {
#@     if {!$tk_strictMotif} {
#@ 	tk::TextScanMark %W %x %y
#@     }
#@ }
#@ bind Text <B2-Motion> {
#@     if {!$tk_strictMotif} {
#@ 	tk::TextScanDrag %W %x %y
#@     }
#@ }
#@ set ::tk::Priv(prevPos) {}
#@ 
#@ # The MouseWheel will typically only fire on Windows.  However,
#@ # someone could use the "event generate" command to produce one
#@ # on other platforms.
#@ 
#@ bind Text <MouseWheel> {
#@     %W yview scroll [expr {- (%D / 120) * 4}] units
#@ }
#@ 
#@ if {[string equal "x11" [tk windowingsystem]]} {
#@     # Support for mousewheels on Linux/Unix commonly comes through mapping
#@     # the wheel to the extended buttons.  If you have a mousewheel, find
#@     # Linux configuration info at:
#@     #	http://www.inria.fr/koala/colas/mouse-wheel-scroll/
#@     bind Text <4> {
#@ 	if {!$tk_strictMotif} {
#@ 	    %W yview scroll -5 units
#@ 	}
#@     }
#@     bind Text <5> {
#@ 	if {!$tk_strictMotif} {
#@ 	    %W yview scroll 5 units
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::TextClosestGap --
#@ # Given x and y coordinates, this procedure finds the closest boundary
#@ # between characters to the given coordinates and returns the index
#@ # of the character just after the boundary.
#@ #
#@ # Arguments:
#@ # w -		The text window.
#@ # x -		X-coordinate within the window.
#@ # y -		Y-coordinate within the window.
#@ 
#@ proc ::tk::TextClosestGap {w x y} {
#@     set pos [$w index @$x,$y]
#@     set bbox [$w bbox $pos]
#@     if {[string equal $bbox ""]} {
#@ 	return $pos
#@     }
#@     if {($x - [lindex $bbox 0]) < ([lindex $bbox 2]/2)} {
#@ 	return $pos
#@     }
#@     $w index "$pos + 1 char"
#@ }
#@ 
#@ # ::tk::TextButton1 --
#@ # This procedure is invoked to handle button-1 presses in text
#@ # widgets.  It moves the insertion cursor, sets the selection anchor,
#@ # and claims the input focus.
#@ #
#@ # Arguments:
#@ # w -		The text window in which the button was pressed.
#@ # x -		The x-coordinate of the button press.
#@ # y -		The x-coordinate of the button press.
#@ 
#@ proc ::tk::TextButton1 {w x y} {
#@     variable ::tk::Priv
#@ 
#@     set Priv(selectMode) char
#@     set Priv(mouseMoved) 0
#@     set Priv(pressX) $x
#@     $w mark set insert [TextClosestGap $w $x $y]
#@     $w mark set anchor insert
#@     # Allow focus in any case on Windows, because that will let the
#@     # selection be displayed even for state disabled text widgets.
#@     if {[string equal $::tcl_platform(platform) "windows"] 	    || [string equal [$w cget -state] "normal"]} {focus $w}
#@     if {[$w cget -autoseparators]} {$w edit separator}
#@ }
#@ 
#@ # ::tk::TextSelectTo --
#@ # This procedure is invoked to extend the selection, typically when
#@ # dragging it with the mouse.  Depending on the selection mode (character,
#@ # word, line) it selects in different-sized units.  This procedure
#@ # ignores mouse motions initially until the mouse has moved from
#@ # one character to another or until there have been multiple clicks.
#@ #
#@ # Arguments:
#@ # w -		The text window in which the button was pressed.
#@ # x -		Mouse x position.
#@ # y - 		Mouse y position.
#@ 
#@ proc ::tk::TextSelectTo {w x y {extend 0}} {
#@     global tcl_platform
#@     variable ::tk::Priv
#@ 
#@     set cur [TextClosestGap $w $x $y]
#@     if {[catch {$w index anchor}]} {
#@ 	$w mark set anchor $cur
#@     }
#@     set anchor [$w index anchor]
#@     if {[$w compare $cur != $anchor] || (abs($Priv(pressX) - $x) >= 3)} {
#@ 	set Priv(mouseMoved) 1
#@     }
#@     switch $Priv(selectMode) {
#@ 	char {
#@ 	    if {[$w compare $cur < anchor]} {
#@ 		set first $cur
#@ 		set last anchor
#@ 	    } else {
#@ 		set first anchor
#@ 		set last $cur
#@ 	    }
#@ 	}
#@ 	word {
#@ 	    if {[$w compare $cur < anchor]} {
#@ 		set first [TextPrevPos $w "$cur + 1c" tcl_wordBreakBefore]
#@ 		if { !$extend } {
#@ 		    set last [TextNextPos $w "anchor" tcl_wordBreakAfter]
#@ 		} else {
#@ 		    set last anchor
#@ 		}
#@ 	    } else {
#@ 		set last [TextNextPos $w "$cur - 1c" tcl_wordBreakAfter]
#@ 		if { !$extend } {
#@ 		    set first [TextPrevPos $w anchor tcl_wordBreakBefore]
#@ 		} else {
#@ 		    set first anchor
#@ 		}
#@ 	    }
#@ 	}
#@ 	line {
#@ 	    if {[$w compare $cur < anchor]} {
#@ 		set first [$w index "$cur linestart"]
#@ 		set last [$w index "anchor - 1c lineend + 1c"]
#@ 	    } else {
#@ 		set first [$w index "anchor linestart"]
#@ 		set last [$w index "$cur lineend + 1c"]
#@ 	    }
#@ 	}
#@     }
#@     if {$Priv(mouseMoved) || [string compare $Priv(selectMode) "char"]} {
#@ 	$w tag remove sel 0.0 end
#@ 	$w mark set insert $cur
#@ 	$w tag add sel $first $last
#@ 	$w tag remove sel $last end
#@ 	update idletasks
#@     }
#@ }
#@ 
#@ # ::tk::TextKeyExtend --
#@ # This procedure handles extending the selection from the keyboard,
#@ # where the point to extend to is really the boundary between two
#@ # characters rather than a particular character.
#@ #
#@ # Arguments:
#@ # w -		The text window.
#@ # index -	The point to which the selection is to be extended.
#@ 
#@ proc ::tk::TextKeyExtend {w index} {
#@ 
#@     set cur [$w index $index]
#@     if {[catch {$w index anchor}]} {
#@ 	$w mark set anchor $cur
#@     }
#@     set anchor [$w index anchor]
#@     if {[$w compare $cur < anchor]} {
#@ 	set first $cur
#@ 	set last anchor
#@     } else {
#@ 	set first anchor
#@ 	set last $cur
#@     }
#@     $w tag remove sel 0.0 $first
#@     $w tag add sel $first $last
#@     $w tag remove sel $last end
#@ }
#@ 
#@ # ::tk::TextPasteSelection --
#@ # This procedure sets the insertion cursor to the mouse position,
#@ # inserts the selection, and sets the focus to the window.
#@ #
#@ # Arguments:
#@ # w -		The text window.
#@ # x, y - 	Position of the mouse.
#@ 
#@ proc ::tk::TextPasteSelection {w x y} {
#@     $w mark set insert [TextClosestGap $w $x $y]
#@     if {![catch {::tk::GetSelection $w PRIMARY} sel]} {
#@ 	set oldSeparator [$w cget -autoseparators]
#@ 	if {$oldSeparator} {
#@ 	    $w configure -autoseparators 0
#@ 	    $w edit separator
#@ 	}
#@ 	$w insert insert $sel
#@ 	if {$oldSeparator} {
#@ 	    $w edit separator
#@ 	    $w configure -autoseparators 1
#@ 	}
#@     }
#@     if {[string equal [$w cget -state] "normal"]} {focus $w}
#@ }
#@ 
#@ # ::tk::TextAutoScan --
#@ # This procedure is invoked when the mouse leaves a text window
#@ # with button 1 down.  It scrolls the window up, down, left, or right,
#@ # depending on where the mouse is (this information was saved in
#@ # ::tk::Priv(x) and ::tk::Priv(y)), and reschedules itself as an "after"
#@ # command so that the window continues to scroll until the mouse
#@ # moves back into the window or the mouse button is released.
#@ #
#@ # Arguments:
#@ # w -		The text window.
#@ 
#@ proc ::tk::TextAutoScan {w} {
#@     variable ::tk::Priv
#@     if {![winfo exists $w]} return
#@     if {$Priv(y) >= [winfo height $w]} {
#@ 	$w yview scroll 2 units
#@     } elseif {$Priv(y) < 0} {
#@ 	$w yview scroll -2 units
#@     } elseif {$Priv(x) >= [winfo width $w]} {
#@ 	$w xview scroll 2 units
#@     } elseif {$Priv(x) < 0} {
#@ 	$w xview scroll -2 units
#@     } else {
#@ 	return
#@     }
#@     TextSelectTo $w $Priv(x) $Priv(y)
#@     set Priv(afterId) [after 50 [list tk::TextAutoScan $w]]
#@ }
#@ 
#@ # ::tk::TextSetCursor
#@ # Move the insertion cursor to a given position in a text.  Also
#@ # clears the selection, if there is one in the text, and makes sure
#@ # that the insertion cursor is visible.  Also, don't let the insertion
#@ # cursor appear on the dummy last line of the text.
#@ #
#@ # Arguments:
#@ # w -		The text window.
#@ # pos -		The desired new position for the cursor in the window.
#@ 
#@ proc ::tk::TextSetCursor {w pos} {
#@ 
#@     if {[$w compare $pos == end]} {
#@ 	set pos {end - 1 chars}
#@     }
#@     $w mark set insert $pos
#@     $w tag remove sel 1.0 end
#@     $w see insert
#@     if {[$w cget -autoseparators]} {$w edit separator}
#@ }
#@ 
#@ # ::tk::TextKeySelect
#@ # This procedure is invoked when stroking out selections using the
#@ # keyboard.  It moves the cursor to a new position, then extends
#@ # the selection to that position.
#@ #
#@ # Arguments:
#@ # w -		The text window.
#@ # new -		A new position for the insertion cursor (the cursor hasn't
#@ #		actually been moved to this position yet).
#@ 
#@ proc ::tk::TextKeySelect {w new} {
#@ 
#@     if {[string equal [$w tag nextrange sel 1.0 end] ""]} {
#@ 	if {[$w compare $new < insert]} {
#@ 	    $w tag add sel $new insert
#@ 	} else {
#@ 	    $w tag add sel insert $new
#@ 	}
#@ 	$w mark set anchor insert
#@     } else {
#@ 	if {[$w compare $new < anchor]} {
#@ 	    set first $new
#@ 	    set last anchor
#@ 	} else {
#@ 	    set first anchor
#@ 	    set last $new
#@ 	}
#@ 	$w tag remove sel 1.0 $first
#@ 	$w tag add sel $first $last
#@ 	$w tag remove sel $last end
#@     }
#@     $w mark set insert $new
#@     $w see insert
#@     update idletasks
#@ }
#@ 
#@ # ::tk::TextResetAnchor --
#@ # Set the selection anchor to whichever end is farthest from the
#@ # index argument.  One special trick: if the selection has two or
#@ # fewer characters, just leave the anchor where it is.  In this
#@ # case it doesn't matter which point gets chosen for the anchor,
#@ # and for the things like Shift-Left and Shift-Right this produces
#@ # better behavior when the cursor moves back and forth across the
#@ # anchor.
#@ #
#@ # Arguments:
#@ # w -		The text widget.
#@ # index -	Position at which mouse button was pressed, which determines
#@ #		which end of selection should be used as anchor point.
#@ 
#@ proc ::tk::TextResetAnchor {w index} {
#@ 
#@     if {[string equal [$w tag ranges sel] ""]} {
#@ 	# Don't move the anchor if there is no selection now; this makes
#@ 	# the widget behave "correctly" when the user clicks once, then
#@ 	# shift-clicks somewhere -- ie, the area between the two clicks will be
#@ 	# selected. [Bug: 5929].
#@ 	return
#@     }
#@     set a [$w index $index]
#@     set b [$w index sel.first]
#@     set c [$w index sel.last]
#@     if {[$w compare $a < $b]} {
#@ 	$w mark set anchor sel.last
#@ 	return
#@     }
#@     if {[$w compare $a > $c]} {
#@ 	$w mark set anchor sel.first
#@ 	return
#@     }
#@     scan $a "%d.%d" lineA chA
#@     scan $b "%d.%d" lineB chB
#@     scan $c "%d.%d" lineC chC
#@     if {$lineB < $lineC+2} {
#@ 	set total [string length [$w get $b $c]]
#@ 	if {$total <= 2} {
#@ 	    return
#@ 	}
#@ 	if {[string length [$w get $b $a]] < ($total/2)} {
#@ 	    $w mark set anchor sel.last
#@ 	} else {
#@ 	    $w mark set anchor sel.first
#@ 	}
#@ 	return
#@     }
#@     if {($lineA-$lineB) < ($lineC-$lineA)} {
#@ 	$w mark set anchor sel.last
#@     } else {
#@ 	$w mark set anchor sel.first
#@     }
#@ }
#@ 
#@ # ::tk::TextInsert --
#@ # Insert a string into a text at the point of the insertion cursor.
#@ # If there is a selection in the text, and it covers the point of the
#@ # insertion cursor, then delete the selection before inserting.
#@ #
#@ # Arguments:
#@ # w -		The text window in which to insert the string
#@ # s -		The string to insert (usually just a single character)
#@ 
#@ proc ::tk::TextInsert {w s} {
#@     if {[string equal $s ""] || [string equal [$w cget -state] "disabled"]} {
#@ 	return
#@     }
#@     set compound 0
#@     catch {
#@ 	if {[$w compare sel.first <= insert] 		&& [$w compare sel.last >= insert]} {
#@             set oldSeparator [$w cget -autoseparators]
#@             if { $oldSeparator } {
#@                 $w configure -autoseparators 0
#@                 $w edit separator
#@                 set compound 1
#@             }
#@ 	    $w delete sel.first sel.last
#@ 	}
#@     }
#@     $w insert insert $s
#@     $w see insert
#@     if { $compound && $oldSeparator } {
#@         $w edit separator
#@         $w configure -autoseparators 1
#@     }
#@ }
#@ 
#@ # ::tk::TextUpDownLine --
#@ # Returns the index of the character one line above or below the
#@ # insertion cursor.  There are two tricky things here.  First,
#@ # we want to maintain the original column across repeated operations,
#@ # even though some lines that will get passed through don't have
#@ # enough characters to cover the original column.  Second, don't
#@ # try to scroll past the beginning or end of the text.
#@ #
#@ # Arguments:
#@ # w -		The text window in which the cursor is to move.
#@ # n -		The number of lines to move: -1 for up one line,
#@ #		+1 for down one line.
#@ 
#@ proc ::tk::TextUpDownLine {w n} {
#@     variable ::tk::Priv
#@ 
#@     set i [$w index insert]
#@     scan $i "%d.%d" line char
#@     if {[string compare $Priv(prevPos) $i]} {
#@ 	set Priv(char) $char
#@     }
#@     set new [$w index [expr {$line + $n}].$Priv(char)]
#@     if {[$w compare $new == end] || [$w compare $new == "insert linestart"]} {
#@ 	set new $i
#@     }
#@     set Priv(prevPos) $new
#@     return $new
#@ }
#@ 
#@ # ::tk::TextPrevPara --
#@ # Returns the index of the beginning of the paragraph just before a given
#@ # position in the text (the beginning of a paragraph is the first non-blank
#@ # character after a blank line).
#@ #
#@ # Arguments:
#@ # w -		The text window in which the cursor is to move.
#@ # pos -		Position at which to start search.
#@ 
#@ proc ::tk::TextPrevPara {w pos} {
#@     set pos [$w index "$pos linestart"]
#@     while {1} {
#@ 	if {([string equal [$w get "$pos - 1 line"] "\n"] 		&& [string compare [$w get $pos] "\n"]) 		|| [string equal $pos "1.0"]} {
#@ 	    if {[regexp -indices {^[ 	]+(.)} [$w get $pos "$pos lineend"] 		    dummy index]} {
#@ 		set pos [$w index "$pos + [lindex $index 0] chars"]
#@ 	    }
#@ 	    if {[$w compare $pos != insert] || [string equal $pos 1.0]} {
#@ 		return $pos
#@ 	    }
#@ 	}
#@ 	set pos [$w index "$pos - 1 line"]
#@     }
#@ }
#@ 
#@ # ::tk::TextNextPara --
#@ # Returns the index of the beginning of the paragraph just after a given
#@ # position in the text (the beginning of a paragraph is the first non-blank
#@ # character after a blank line).
#@ #
#@ # Arguments:
#@ # w -		The text window in which the cursor is to move.
#@ # start -	Position at which to start search.
#@ 
#@ proc ::tk::TextNextPara {w start} {
#@     set pos [$w index "$start linestart + 1 line"]
#@     while {[string compare [$w get $pos] "\n"]} {
#@ 	if {[$w compare $pos == end]} {
#@ 	    return [$w index "end - 1c"]
#@ 	}
#@ 	set pos [$w index "$pos + 1 line"]
#@     }
#@     while {[string equal [$w get $pos] "\n"]} {
#@ 	set pos [$w index "$pos + 1 line"]
#@ 	if {[$w compare $pos == end]} {
#@ 	    return [$w index "end - 1c"]
#@ 	}
#@     }
#@     if {[regexp -indices {^[ 	]+(.)} [$w get $pos "$pos lineend"] 	    dummy index]} {
#@ 	return [$w index "$pos + [lindex $index 0] chars"]
#@     }
#@     return $pos
#@ }
#@ 
#@ # ::tk::TextScrollPages --
#@ # This is a utility procedure used in bindings for moving up and down
#@ # pages and possibly extending the selection along the way.  It scrolls
#@ # the view in the widget by the number of pages, and it returns the
#@ # index of the character that is at the same position in the new view
#@ # as the insertion cursor used to be in the old view.
#@ #
#@ # Arguments:
#@ # w -		The text window in which the cursor is to move.
#@ # count -	Number of pages forward to scroll;  may be negative
#@ #		to scroll backwards.
#@ 
#@ proc ::tk::TextScrollPages {w count} {
#@     set bbox [$w bbox insert]
#@     $w yview scroll $count pages
#@     if {[string equal $bbox ""]} {
#@ 	return [$w index @[expr {[winfo height $w]/2}],0]
#@     }
#@     return [$w index @[lindex $bbox 0],[lindex $bbox 1]]
#@ }
#@ 
#@ # ::tk::TextTranspose --
#@ # This procedure implements the "transpose" function for text widgets.
#@ # It tranposes the characters on either side of the insertion cursor,
#@ # unless the cursor is at the end of the line.  In this case it
#@ # transposes the two characters to the left of the cursor.  In either
#@ # case, the cursor ends up to the right of the transposed characters.
#@ #
#@ # Arguments:
#@ # w -		Text window in which to transpose.
#@ 
#@ proc ::tk::TextTranspose w {
#@     set pos insert
#@     if {[$w compare $pos != "$pos lineend"]} {
#@ 	set pos [$w index "$pos + 1 char"]
#@     }
#@     set new [$w get "$pos - 1 char"][$w get  "$pos - 2 char"]
#@     if {[$w compare "$pos - 1 char" == 1.0]} {
#@ 	return
#@     }
#@     $w delete "$pos - 2 char" $pos
#@     $w insert insert $new
#@     $w see insert
#@ }
#@ 
#@ # ::tk_textCopy --
#@ # This procedure copies the selection from a text widget into the
#@ # clipboard.
#@ #
#@ # Arguments:
#@ # w -		Name of a text widget.
#@ 
#@ proc ::tk_textCopy w {
#@     if {![catch {set data [$w get sel.first sel.last]}]} {
#@ 	clipboard clear -displayof $w
#@ 	clipboard append -displayof $w $data
#@     }
#@ }
#@ 
#@ # ::tk_textCut --
#@ # This procedure copies the selection from a text widget into the
#@ # clipboard, then deletes the selection (if it exists in the given
#@ # widget).
#@ #
#@ # Arguments:
#@ # w -		Name of a text widget.
#@ 
#@ proc ::tk_textCut w {
#@     if {![catch {set data [$w get sel.first sel.last]}]} {
#@ 	clipboard clear -displayof $w
#@ 	clipboard append -displayof $w $data
#@ 	$w delete sel.first sel.last
#@     }
#@ }
#@ 
#@ # ::tk_textPaste --
#@ # This procedure pastes the contents of the clipboard to the insertion
#@ # point in a text widget.
#@ #
#@ # Arguments:
#@ # w -		Name of a text widget.
#@ 
#@ proc ::tk_textPaste w {
#@     global tcl_platform
#@     if {![catch {::tk::GetSelection $w CLIPBOARD} sel]} {
#@ 	set oldSeparator [$w cget -autoseparators]
#@ 	if { $oldSeparator } {
#@ 	    $w configure -autoseparators 0
#@ 	    $w edit separator
#@ 	}
#@ 	if {[string compare [tk windowingsystem] "x11"]} {
#@ 	    catch { $w delete sel.first sel.last }
#@ 	}
#@ 	$w insert insert $sel
#@ 	if { $oldSeparator } {
#@ 	    $w edit separator
#@ 	    $w configure -autoseparators 1
#@ 	}
#@     }
#@ }
#@ 
#@ # ::tk::TextNextWord --
#@ # Returns the index of the next word position after a given position in the
#@ # text.  The next word is platform dependent and may be either the next
#@ # end-of-word position or the next start-of-word position after the next
#@ # end-of-word position.
#@ #
#@ # Arguments:
#@ # w -		The text window in which the cursor is to move.
#@ # start -	Position at which to start search.
#@ 
#@ if {[string equal $tcl_platform(platform) "windows"]}  {
#@     proc ::tk::TextNextWord {w start} {
#@ 	TextNextPos $w [TextNextPos $w $start tcl_endOfWord] 	    tcl_startOfNextWord
#@     }
#@ } else {
#@     proc ::tk::TextNextWord {w start} {
#@ 	TextNextPos $w $start tcl_endOfWord
#@     }
#@ }
#@ 
#@ # ::tk::TextNextPos --
#@ # Returns the index of the next position after the given starting
#@ # position in the text as computed by a specified function.
#@ #
#@ # Arguments:
#@ # w -		The text window in which the cursor is to move.
#@ # start -	Position at which to start search.
#@ # op -		Function to use to find next position.
#@ 
#@ proc ::tk::TextNextPos {w start op} {
#@     set text ""
#@     set cur $start
#@     while {[$w compare $cur < end]} {
#@ 	set text $text[$w get $cur "$cur lineend + 1c"]
#@ 	set pos [$op $text 0]
#@ 	if {$pos >= 0} {
#@ 	    ## Adjust for embedded windows and images
#@ 	    ## dump gives us 3 items per window/image
#@ 	    set dump [$w dump -image -window $start "$start + $pos c"]
#@ 	    if {[llength $dump]} {
#@ 		set pos [expr {$pos + ([llength $dump]/3)}]
#@ 	    }
#@ 	    return [$w index "$start + $pos c"]
#@ 	}
#@ 	set cur [$w index "$cur lineend +1c"]
#@     }
#@     return end
#@ }
#@ 
#@ # ::tk::TextPrevPos --
#@ # Returns the index of the previous position before the given starting
#@ # position in the text as computed by a specified function.
#@ #
#@ # Arguments:
#@ # w -		The text window in which the cursor is to move.
#@ # start -	Position at which to start search.
#@ # op -		Function to use to find next position.
#@ 
#@ proc ::tk::TextPrevPos {w start op} {
#@     set text ""
#@     set cur $start
#@     while {[$w compare $cur > 0.0]} {
#@ 	set text [$w get "$cur linestart - 1c" $cur]$text
#@ 	set pos [$op $text end]
#@ 	if {$pos >= 0} {
#@ 	    ## Adjust for embedded windows and images
#@ 	    ## dump gives us 3 items per window/image
#@ 	    set dump [$w dump -image -window "$cur linestart" "$start - 1c"]
#@ 	    if {[llength $dump]} {
#@ 		## This is a hokey extra hack for control-arrow movement
#@ 		## that should be in a while loop to be correct (hobbs)
#@ 		if {[$w compare [lindex $dump 2] > 			"$cur linestart - 1c + $pos c"]} {
#@ 		    incr pos -1
#@ 		}
#@ 		set pos [expr {$pos + ([llength $dump]/3)}]
#@ 	    }
#@ 	    return [$w index "$cur linestart - 1c + $pos c"]
#@ 	}
#@ 	set cur [$w index "$cur linestart - 1c"]
#@     }
#@     return 0.0
#@ }
#@ 
#@ # ::tk::TextScanMark --
#@ #
#@ # Marks the start of a possible scan drag operation
#@ #
#@ # Arguments:
#@ # w -	The text window from which the text to get
#@ # x -	x location on screen
#@ # y -	y location on screen
#@ 
#@ proc ::tk::TextScanMark {w x y} {
#@     $w scan mark $x $y
#@     set ::tk::Priv(x) $x
#@     set ::tk::Priv(y) $y
#@     set ::tk::Priv(mouseMoved) 0
#@ }
#@ 
#@ # ::tk::TextScanDrag --
#@ #
#@ # Marks the start of a possible scan drag operation
#@ #
#@ # Arguments:
#@ # w -	The text window from which the text to get
#@ # x -	x location on screen
#@ # y -	y location on screen
#@ 
#@ proc ::tk::TextScanDrag {w x y} {
#@     # Make sure these exist, as some weird situations can trigger the
#@     # motion binding without the initial press.  [Bug #220269]
#@     if {![info exists ::tk::Priv(x)]} { set ::tk::Priv(x) $x }
#@     if {![info exists ::tk::Priv(y)]} { set ::tk::Priv(y) $y }
#@     if {($x != $::tk::Priv(x)) || ($y != $::tk::Priv(y))} {
#@ 	set ::tk::Priv(mouseMoved) 1
#@     }
#@     if {[info exists ::tk::Priv(mouseMoved)] && $::tk::Priv(mouseMoved)} {
#@ 	$w scan dragto $x $y
#@     }
#@ }
#@ # -- End source /usr/cad/synopsys/synthesis/cur/auxx/tcllib/lib/tk8.4/text.tcl

#@ # ----------------------------------------------------------------------
#@ # Default bindings for keyboard traversal.
#@ # ----------------------------------------------------------------------
#@ 
#@ event add <<PrevWindow>> <Shift-Tab>
#@ bind all <Tab> {tk::TabToWindow [tk_focusNext %W]}
#@ bind all <<PrevWindow>> {tk::TabToWindow [tk_focusPrev %W]}
#@ 
#@ # ::tk::CancelRepeat --
#@ # This procedure is invoked to cancel an auto-repeat action described
#@ # by ::tk::Priv(afterId).  It's used by several widgets to auto-scroll
#@ # the widget when the mouse is dragged out of the widget with a
#@ # button pressed.
#@ #
#@ # Arguments:
#@ # None.
#@ 
#@ proc ::tk::CancelRepeat {} {
#@     variable ::tk::Priv
#@     after cancel $Priv(afterId)
#@     set Priv(afterId) {}
#@ }
#@ 
#@ # ::tk::TabToWindow --
#@ # This procedure moves the focus to the given widget.  If the widget
#@ # is an entry or a spinbox, it selects the entire contents of the widget.
#@ #
#@ # Arguments:
#@ # w - Window to which focus should be set.
#@ 
#@ proc ::tk::TabToWindow {w} {
#@     if {[string equal [winfo class $w] Entry] 	    || [string equal [winfo class $w] Spinbox]} {
#@ 	$w selection range 0 end
#@ 	$w icursor end
#@     }
#@     focus $w
#@ }
#@ 
#@ # ::tk::UnderlineAmpersand --
#@ # This procedure takes some text with ampersand and returns
#@ # text w/o ampersand and position of the ampersand.
#@ # Double ampersands are converted to single ones.
#@ # Position returned is -1 when there is no ampersand.
#@ #
#@ proc ::tk::UnderlineAmpersand {text} {
#@     set idx [string first "&" $text]
#@     if {$idx >= 0} {
#@ 	set underline $idx
#@ 	# ignore "&&"
#@ 	while {[string match "&" [string index $text [expr {$idx + 1}]]]} {
#@ 	    set base [expr {$idx + 2}]
#@ 	    set idx  [string first "&" [string range $text $base end]]
#@ 	    if {$idx < 0} {
#@ 		break
#@ 	    } else {
#@ 		set underline [expr {$underline + $idx + 1}]
#@ 		incr idx $base
#@ 	    }
#@ 	}
#@     }
#@     if {$idx >= 0} {
#@ 	regsub -all -- {&([^&])} $text {\1} text
#@     } 
#@     return [list $text $idx]
#@ }
#@ 
#@ # ::tk::SetAmpText -- 
#@ # Given widget path and text with "magic ampersands",
#@ # sets -text and -underline options for the widget
#@ #
#@ proc ::tk::SetAmpText {widget text} {
#@     foreach {newtext under} [::tk::UnderlineAmpersand $text] {
#@ 	$widget configure -text $newtext -underline $under
#@     }
#@ }
#@ 
#@ # ::tk::AmpWidget --
#@ # Creates new widget, turning -text option into -text and
#@ # -underline options, returned by ::tk::UnderlineAmpersand.
#@ #
#@ proc ::tk::AmpWidget {class path args} {
#@     set wcmd [list $class $path]
#@     foreach {opt val} $args {
#@ 	if {[string equal $opt {-text}]} {
#@ 	    foreach {newtext under} [::tk::UnderlineAmpersand $val] {
#@ 		lappend wcmd -text $newtext -underline $under
#@ 	    }
#@ 	} else {
#@ 	    lappend wcmd $opt $val
#@ 	}
#@     }
#@     eval $wcmd
#@     if {$class=="button"} {
#@ 	bind $path <<AltUnderlined>> [list $path invoke]
#@     }
#@     return $path
#@ }
#@ 
#@ # ::tk::FindAltKeyTarget --
#@ # search recursively through the hierarchy of visible widgets
#@ # to find button or label which has $char as underlined character
#@ #
#@ proc ::tk::FindAltKeyTarget {path char} {
#@     switch [winfo class $path] {
#@ 	Button -
#@ 	Label {
#@ 	    if {[string equal -nocase $char 		[string index [$path cget -text] 		[$path cget -underline]]]} {return $path} else {return {}}
#@ 	}
#@ 	default {
#@ 	    foreach child 		[concat [grid slaves $path] 		[pack slaves $path] 		[place slaves $path] ] {
#@ 		if {""!=[set target [::tk::FindAltKeyTarget $child $char]]} {
#@ 		    return $target
#@ 		}
#@ 	    }
#@ 	}
#@     }
#@     return {}
#@ }
#@ 
#@ # ::tk::AltKeyInDialog --
#@ # <Alt-Key> event handler for standard dialogs. Sends <<AltUnderlined>>
#@ # to button or label which has appropriate underlined character
#@ #
#@ proc ::tk::AltKeyInDialog {path key} {
#@     set target [::tk::FindAltKeyTarget $path $key]
#@     if { $target == ""} return
#@     event generate $target <<AltUnderlined>>
#@ }
#@ 
#@ # ::tk::mcmaxamp --
#@ # Replacement for mcmax, used for texts with "magic ampersand" in it.
#@ #
#@ 
#@ proc ::tk::mcmaxamp {args} {
#@     set maxlen 0
#@     foreach arg $args {
#@ 	set length [string length [lindex [::tk::UnderlineAmpersand [mc $arg]] 0]]
#@ 	if {$length>$maxlen} {
#@ 	    set maxlen $length
#@ 	}
#@     }
#@     return $maxlen
#@ }
#@ # For now, turn off the custom mdef proc for the mac:
#@ 
#@ if {[string equal [tk windowingsystem] "aqua"]} {
#@     namespace eval ::tk::mac {
#@ 	set useCustomMDEF 0
#@     }
#@ }
#@ # -- End source /usr/cad/synopsys/synthesis/cur/auxx/tcllib/lib/tk8.4/tk.tcl

